var D_ = Object.create;
var ka = Object.defineProperty
  , I_ = Object.defineProperties
  , A_ = Object.getOwnPropertyDescriptor
  , __ = Object.getOwnPropertyDescriptors
  , S_ = Object.getOwnPropertyNames
  , pu = Object.getOwnPropertySymbols
  , M_ = Object.getPrototypeOf
  , s0 = Object.prototype.hasOwnProperty
  , Fv = Object.prototype.propertyIsEnumerable;
var Rv = (t,e,n)=>e in t ? ka(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n
  , ee = (t,e)=>{
    for (var n in e ||= {})
        s0.call(e, n) && Rv(t, n, e[n]);
    if (pu)
        for (var n of pu(e))
            Fv.call(e, n) && Rv(t, n, e[n]);
    return t
}
  , me = (t,e)=>I_(t, __(e));
var Nv = (t=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(t,{
    get: (e,n)=>(typeof require < "u" ? require : e)[n]
}) : t)(function(t) {
    if (typeof require < "u")
        return require.apply(this, arguments);
    throw Error('Dynamic require of "' + t + '" is not supported')
});
var Nr = (t,e)=>{
    var n = {};
    for (var r in t)
        s0.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && pu)
        for (var r of pu(t))
            e.indexOf(r) < 0 && Fv.call(t, r) && (n[r] = t[r]);
    return n
}
;
var vn = (t,e)=>()=>(t && (e = t(t = 0)),
e);
var Ce = (t,e)=>()=>(e || t((e = {
    exports: {}
}).exports, e),
e.exports)
  , a0 = (t,e)=>{
    for (var n in e)
        ka(t, n, {
            get: e[n],
            enumerable: !0
        })
}
  , Pv = (t,e,n,r)=>{
    if (e && typeof e == "object" || typeof e == "function")
        for (let i of S_(e))
            !s0.call(t, i) && i !== n && ka(t, i, {
                get: ()=>e[i],
                enumerable: !(r = A_(e, i)) || r.enumerable
            });
    return t
}
;
var Gn = (t,e,n)=>(n = t != null ? D_(M_(t)) : {},
Pv(e || !t || !t.__esModule ? ka(n, "default", {
    value: t,
    enumerable: !0
}) : n, t))
  , c0 = t=>Pv(ka({}, "__esModule", {
    value: !0
}), t);
var $ = (t,e,n)=>new Promise((r,i)=>{
    var o = c=>{
        try {
            a(n.next(c))
        } catch (u) {
            i(u)
        }
    }
      , s = c=>{
        try {
            a(n.throw(c))
        } catch (u) {
            i(u)
        }
    }
      , a = c=>c.done ? r(c.value) : Promise.resolve(c.value).then(o, s);
    a((n = n.apply(t, e)).next())
}
);
var Sm = Ce(yf=>{
    "use strict";
    yf.byteLength = rF;
    yf.toByteArray = oF;
    yf.fromByteArray = cF;
    var Yr = []
      , lr = []
      , nF = typeof Uint8Array < "u" ? Uint8Array : Array
      , _m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (jo = 0,
    jE = _m.length; jo < jE; ++jo)
        Yr[jo] = _m[jo],
        lr[_m.charCodeAt(jo)] = jo;
    var jo, jE;
    lr[45] = 62;
    lr[95] = 63;
    function $E(t) {
        var e = t.length;
        if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var n = t.indexOf("=");
        n === -1 && (n = e);
        var r = n === e ? 0 : 4 - n % 4;
        return [n, r]
    }
    function rF(t) {
        var e = $E(t)
          , n = e[0]
          , r = e[1];
        return (n + r) * 3 / 4 - r
    }
    function iF(t, e, n) {
        return (e + n) * 3 / 4 - n
    }
    function oF(t) {
        var e, n = $E(t), r = n[0], i = n[1], o = new nF(iF(t, r, i)), s = 0, a = i > 0 ? r - 4 : r, c;
        for (c = 0; c < a; c += 4)
            e = lr[t.charCodeAt(c)] << 18 | lr[t.charCodeAt(c + 1)] << 12 | lr[t.charCodeAt(c + 2)] << 6 | lr[t.charCodeAt(c + 3)],
            o[s++] = e >> 16 & 255,
            o[s++] = e >> 8 & 255,
            o[s++] = e & 255;
        return i === 2 && (e = lr[t.charCodeAt(c)] << 2 | lr[t.charCodeAt(c + 1)] >> 4,
        o[s++] = e & 255),
        i === 1 && (e = lr[t.charCodeAt(c)] << 10 | lr[t.charCodeAt(c + 1)] << 4 | lr[t.charCodeAt(c + 2)] >> 2,
        o[s++] = e >> 8 & 255,
        o[s++] = e & 255),
        o
    }
    function sF(t) {
        return Yr[t >> 18 & 63] + Yr[t >> 12 & 63] + Yr[t >> 6 & 63] + Yr[t & 63]
    }
    function aF(t, e, n) {
        for (var r, i = [], o = e; o < n; o += 3)
            r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255),
            i.push(sF(r));
        return i.join("")
    }
    function cF(t) {
        for (var e, n = t.length, r = n % 3, i = [], o = 16383, s = 0, a = n - r; s < a; s += o)
            i.push(aF(t, s, s + o > a ? a : s + o));
        return r === 1 ? (e = t[n - 1],
        i.push(Yr[e >> 2] + Yr[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1],
        i.push(Yr[e >> 10] + Yr[e >> 4 & 63] + Yr[e << 2 & 63] + "=")),
        i.join("")
    }
}
);
var km = Ce(Mm=>{
    "use strict";
    Mm.read = function(t, e, n, r, i) {
        var o, s, a = i * 8 - r - 1, c = (1 << a) - 1, u = c >> 1, l = -7, d = n ? i - 1 : 0, y = n ? -1 : 1, v = t[e + d];
        for (d += y,
        o = v & (1 << -l) - 1,
        v >>= -l,
        l += a; l > 0; o = o * 256 + t[e + d],
        d += y,
        l -= 8)
            ;
        for (s = o & (1 << -l) - 1,
        o >>= -l,
        l += r; l > 0; s = s * 256 + t[e + d],
        d += y,
        l -= 8)
            ;
        if (o === 0)
            o = 1 - u;
        else {
            if (o === c)
                return s ? NaN : (v ? -1 : 1) * (1 / 0);
            s = s + Math.pow(2, r),
            o = o - u
        }
        return (v ? -1 : 1) * s * Math.pow(2, o - r)
    }
    ;
    Mm.write = function(t, e, n, r, i, o) {
        var s, a, c, u = o * 8 - i - 1, l = (1 << u) - 1, d = l >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = r ? 0 : o - 1, E = r ? 1 : -1, D = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e),
        isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
        s = l) : (s = Math.floor(Math.log(e) / Math.LN2),
        e * (c = Math.pow(2, -s)) < 1 && (s--,
        c *= 2),
        s + d >= 1 ? e += y / c : e += y * Math.pow(2, 1 - d),
        e * c >= 2 && (s++,
        c /= 2),
        s + d >= l ? (a = 0,
        s = l) : s + d >= 1 ? (a = (e * c - 1) * Math.pow(2, i),
        s = s + d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, i),
        s = 0)); i >= 8; t[n + v] = a & 255,
        v += E,
        a /= 256,
        i -= 8)
            ;
        for (s = s << i | a,
        u += i; u > 0; t[n + v] = s & 255,
        v += E,
        s /= 256,
        u -= 8)
            ;
        t[n + v - E] |= D * 128
    }
}
);
var kc = Ce(na=>{
    "use strict";
    var Tm = Sm()
      , ea = km()
      , HE = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    na.Buffer = Z;
    na.SlowBuffer = pF;
    na.INSPECT_MAX_BYTES = 50;
    var vf = 2147483647;
    na.kMaxLength = vf;
    Z.TYPED_ARRAY_SUPPORT = uF();
    !Z.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function uF() {
        try {
            let t = new Uint8Array(1)
              , e = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(e, Uint8Array.prototype),
            Object.setPrototypeOf(t, e),
            t.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(Z.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (Z.isBuffer(this))
                return this.buffer
        }
    });
    Object.defineProperty(Z.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (Z.isBuffer(this))
                return this.byteOffset
        }
    });
    function mi(t) {
        if (t > vf)
            throw new RangeError('The value "' + t + '" is invalid for option "size"');
        let e = new Uint8Array(t);
        return Object.setPrototypeOf(e, Z.prototype),
        e
    }
    function Z(t, e, n) {
        if (typeof t == "number") {
            if (typeof e == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return Nm(t)
        }
        return GE(t, e, n)
    }
    Z.poolSize = 8192;
    function GE(t, e, n) {
        if (typeof t == "string")
            return fF(t, e);
        if (ArrayBuffer.isView(t))
            return dF(t);
        if (t == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
        if (Zr(t, ArrayBuffer) || t && Zr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr(t, SharedArrayBuffer) || t && Zr(t.buffer, SharedArrayBuffer)))
            return Rm(t, e, n);
        if (typeof t == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        let r = t.valueOf && t.valueOf();
        if (r != null && r !== t)
            return Z.from(r, e, n);
        let i = hF(t);
        if (i)
            return i;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
            return Z.from(t[Symbol.toPrimitive]("string"), e, n);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
    }
    Z.from = function(t, e, n) {
        return GE(t, e, n)
    }
    ;
    Object.setPrototypeOf(Z.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Z, Uint8Array);
    function KE(t) {
        if (typeof t != "number")
            throw new TypeError('"size" argument must be of type number');
        if (t < 0)
            throw new RangeError('The value "' + t + '" is invalid for option "size"')
    }
    function lF(t, e, n) {
        return KE(t),
        t <= 0 ? mi(t) : e !== void 0 ? typeof n == "string" ? mi(t).fill(e, n) : mi(t).fill(e) : mi(t)
    }
    Z.alloc = function(t, e, n) {
        return lF(t, e, n)
    }
    ;
    function Nm(t) {
        return KE(t),
        mi(t < 0 ? 0 : Pm(t) | 0)
    }
    Z.allocUnsafe = function(t) {
        return Nm(t)
    }
    ;
    Z.allocUnsafeSlow = function(t) {
        return Nm(t)
    }
    ;
    function fF(t, e) {
        if ((typeof e != "string" || e === "") && (e = "utf8"),
        !Z.isEncoding(e))
            throw new TypeError("Unknown encoding: " + e);
        let n = YE(t, e) | 0
          , r = mi(n)
          , i = r.write(t, e);
        return i !== n && (r = r.slice(0, i)),
        r
    }
    function Bm(t) {
        let e = t.length < 0 ? 0 : Pm(t.length) | 0
          , n = mi(e);
        for (let r = 0; r < e; r += 1)
            n[r] = t[r] & 255;
        return n
    }
    function dF(t) {
        if (Zr(t, Uint8Array)) {
            let e = new Uint8Array(t);
            return Rm(e.buffer, e.byteOffset, e.byteLength)
        }
        return Bm(t)
    }
    function Rm(t, e, n) {
        if (e < 0 || t.byteLength < e)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (t.byteLength < e + (n || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let r;
        return e === void 0 && n === void 0 ? r = new Uint8Array(t) : n === void 0 ? r = new Uint8Array(t,e) : r = new Uint8Array(t,e,n),
        Object.setPrototypeOf(r, Z.prototype),
        r
    }
    function hF(t) {
        if (Z.isBuffer(t)) {
            let e = Pm(t.length) | 0
              , n = mi(e);
            return n.length === 0 || t.copy(n, 0, 0, e),
            n
        }
        if (t.length !== void 0)
            return typeof t.length != "number" || Lm(t.length) ? mi(0) : Bm(t);
        if (t.type === "Buffer" && Array.isArray(t.data))
            return Bm(t.data)
    }
    function Pm(t) {
        if (t >= vf)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + vf.toString(16) + " bytes");
        return t | 0
    }
    function pF(t) {
        return +t != t && (t = 0),
        Z.alloc(+t)
    }
    Z.isBuffer = function(e) {
        return e != null && e._isBuffer === !0 && e !== Z.prototype
    }
    ;
    Z.compare = function(e, n) {
        if (Zr(e, Uint8Array) && (e = Z.from(e, e.offset, e.byteLength)),
        Zr(n, Uint8Array) && (n = Z.from(n, n.offset, n.byteLength)),
        !Z.isBuffer(e) || !Z.isBuffer(n))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === n)
            return 0;
        let r = e.length
          , i = n.length;
        for (let o = 0, s = Math.min(r, i); o < s; ++o)
            if (e[o] !== n[o]) {
                r = e[o],
                i = n[o];
                break
            }
        return r < i ? -1 : i < r ? 1 : 0
    }
    ;
    Z.isEncoding = function(e) {
        switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ;
    Z.concat = function(e, n) {
        if (!Array.isArray(e))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0)
            return Z.alloc(0);
        let r;
        if (n === void 0)
            for (n = 0,
            r = 0; r < e.length; ++r)
                n += e[r].length;
        let i = Z.allocUnsafe(n)
          , o = 0;
        for (r = 0; r < e.length; ++r) {
            let s = e[r];
            if (Zr(s, Uint8Array))
                o + s.length > i.length ? (Z.isBuffer(s) || (s = Z.from(s)),
                s.copy(i, o)) : Uint8Array.prototype.set.call(i, s, o);
            else if (Z.isBuffer(s))
                s.copy(i, o);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            o += s.length
        }
        return i
    }
    ;
    function YE(t, e) {
        if (Z.isBuffer(t))
            return t.length;
        if (ArrayBuffer.isView(t) || Zr(t, ArrayBuffer))
            return t.byteLength;
        if (typeof t != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
        let n = t.length
          , r = arguments.length > 2 && arguments[2] === !0;
        if (!r && n === 0)
            return 0;
        let i = !1;
        for (; ; )
            switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
                return n;
            case "utf8":
            case "utf-8":
                return Fm(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return n * 2;
            case "hex":
                return n >>> 1;
            case "base64":
                return iC(t).length;
            default:
                if (i)
                    return r ? -1 : Fm(t).length;
                e = ("" + e).toLowerCase(),
                i = !0
            }
    }
    Z.byteLength = YE;
    function gF(t, e, n) {
        let r = !1;
        if ((e === void 0 || e < 0) && (e = 0),
        e > this.length || ((n === void 0 || n > this.length) && (n = this.length),
        n <= 0) || (n >>>= 0,
        e >>>= 0,
        n <= e))
            return "";
        for (t || (t = "utf8"); ; )
            switch (t) {
            case "hex":
                return IF(this, e, n);
            case "utf8":
            case "utf-8":
                return XE(this, e, n);
            case "ascii":
                return CF(this, e, n);
            case "latin1":
            case "binary":
                return DF(this, e, n);
            case "base64":
                return bF(this, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return AF(this, e, n);
            default:
                if (r)
                    throw new TypeError("Unknown encoding: " + t);
                t = (t + "").toLowerCase(),
                r = !0
            }
    }
    Z.prototype._isBuffer = !0;
    function $o(t, e, n) {
        let r = t[e];
        t[e] = t[n],
        t[n] = r
    }
    Z.prototype.swap16 = function() {
        let e = this.length;
        if (e % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let n = 0; n < e; n += 2)
            $o(this, n, n + 1);
        return this
    }
    ;
    Z.prototype.swap32 = function() {
        let e = this.length;
        if (e % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let n = 0; n < e; n += 4)
            $o(this, n, n + 3),
            $o(this, n + 1, n + 2);
        return this
    }
    ;
    Z.prototype.swap64 = function() {
        let e = this.length;
        if (e % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let n = 0; n < e; n += 8)
            $o(this, n, n + 7),
            $o(this, n + 1, n + 6),
            $o(this, n + 2, n + 5),
            $o(this, n + 3, n + 4);
        return this
    }
    ;
    Z.prototype.toString = function() {
        let e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? XE(this, 0, e) : gF.apply(this, arguments)
    }
    ;
    Z.prototype.toLocaleString = Z.prototype.toString;
    Z.prototype.equals = function(e) {
        if (!Z.isBuffer(e))
            throw new TypeError("Argument must be a Buffer");
        return this === e ? !0 : Z.compare(this, e) === 0
    }
    ;
    Z.prototype.inspect = function() {
        let e = ""
          , n = na.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(),
        this.length > n && (e += " ... "),
        "<Buffer " + e + ">"
    }
    ;
    HE && (Z.prototype[HE] = Z.prototype.inspect);
    Z.prototype.compare = function(e, n, r, i, o) {
        if (Zr(e, Uint8Array) && (e = Z.from(e, e.offset, e.byteLength)),
        !Z.isBuffer(e))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (n === void 0 && (n = 0),
        r === void 0 && (r = e ? e.length : 0),
        i === void 0 && (i = 0),
        o === void 0 && (o = this.length),
        n < 0 || r > e.length || i < 0 || o > this.length)
            throw new RangeError("out of range index");
        if (i >= o && n >= r)
            return 0;
        if (i >= o)
            return -1;
        if (n >= r)
            return 1;
        if (n >>>= 0,
        r >>>= 0,
        i >>>= 0,
        o >>>= 0,
        this === e)
            return 0;
        let s = o - i
          , a = r - n
          , c = Math.min(s, a)
          , u = this.slice(i, o)
          , l = e.slice(n, r);
        for (let d = 0; d < c; ++d)
            if (u[d] !== l[d]) {
                s = u[d],
                a = l[d];
                break
            }
        return s < a ? -1 : a < s ? 1 : 0
    }
    ;
    function ZE(t, e, n, r, i) {
        if (t.length === 0)
            return -1;
        if (typeof n == "string" ? (r = n,
        n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
        n = +n,
        Lm(n) && (n = i ? 0 : t.length - 1),
        n < 0 && (n = t.length + n),
        n >= t.length) {
            if (i)
                return -1;
            n = t.length - 1
        } else if (n < 0)
            if (i)
                n = 0;
            else
                return -1;
        if (typeof e == "string" && (e = Z.from(e, r)),
        Z.isBuffer(e))
            return e.length === 0 ? -1 : zE(t, e, n, r, i);
        if (typeof e == "number")
            return e = e & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : zE(t, [e], n, r, i);
        throw new TypeError("val must be string, number or Buffer")
    }
    function zE(t, e, n, r, i) {
        let o = 1
          , s = t.length
          , a = e.length;
        if (r !== void 0 && (r = String(r).toLowerCase(),
        r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")) {
            if (t.length < 2 || e.length < 2)
                return -1;
            o = 2,
            s /= 2,
            a /= 2,
            n /= 2
        }
        function c(l, d) {
            return o === 1 ? l[d] : l.readUInt16BE(d * o)
        }
        let u;
        if (i) {
            let l = -1;
            for (u = n; u < s; u++)
                if (c(t, u) === c(e, l === -1 ? 0 : u - l)) {
                    if (l === -1 && (l = u),
                    u - l + 1 === a)
                        return l * o
                } else
                    l !== -1 && (u -= u - l),
                    l = -1
        } else
            for (n + a > s && (n = s - a),
            u = n; u >= 0; u--) {
                let l = !0;
                for (let d = 0; d < a; d++)
                    if (c(t, u + d) !== c(e, d)) {
                        l = !1;
                        break
                    }
                if (l)
                    return u
            }
        return -1
    }
    Z.prototype.includes = function(e, n, r) {
        return this.indexOf(e, n, r) !== -1
    }
    ;
    Z.prototype.indexOf = function(e, n, r) {
        return ZE(this, e, n, r, !0)
    }
    ;
    Z.prototype.lastIndexOf = function(e, n, r) {
        return ZE(this, e, n, r, !1)
    }
    ;
    function mF(t, e, n, r) {
        n = Number(n) || 0;
        let i = t.length - n;
        r ? (r = Number(r),
        r > i && (r = i)) : r = i;
        let o = e.length;
        r > o / 2 && (r = o / 2);
        let s;
        for (s = 0; s < r; ++s) {
            let a = parseInt(e.substr(s * 2, 2), 16);
            if (Lm(a))
                return s;
            t[n + s] = a
        }
        return s
    }
    function yF(t, e, n, r) {
        return xf(Fm(e, t.length - n), t, n, r)
    }
    function vF(t, e, n, r) {
        return xf(kF(e), t, n, r)
    }
    function xF(t, e, n, r) {
        return xf(iC(e), t, n, r)
    }
    function wF(t, e, n, r) {
        return xf(TF(e, t.length - n), t, n, r)
    }
    Z.prototype.write = function(e, n, r, i) {
        if (n === void 0)
            i = "utf8",
            r = this.length,
            n = 0;
        else if (r === void 0 && typeof n == "string")
            i = n,
            r = this.length,
            n = 0;
        else if (isFinite(n))
            n = n >>> 0,
            isFinite(r) ? (r = r >>> 0,
            i === void 0 && (i = "utf8")) : (i = r,
            r = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - n;
        if ((r === void 0 || r > o) && (r = o),
        e.length > 0 && (r < 0 || n < 0) || n > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        i || (i = "utf8");
        let s = !1;
        for (; ; )
            switch (i) {
            case "hex":
                return mF(this, e, n, r);
            case "utf8":
            case "utf-8":
                return yF(this, e, n, r);
            case "ascii":
            case "latin1":
            case "binary":
                return vF(this, e, n, r);
            case "base64":
                return xF(this, e, n, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return wF(this, e, n, r);
            default:
                if (s)
                    throw new TypeError("Unknown encoding: " + i);
                i = ("" + i).toLowerCase(),
                s = !0
            }
    }
    ;
    Z.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function bF(t, e, n) {
        return e === 0 && n === t.length ? Tm.fromByteArray(t) : Tm.fromByteArray(t.slice(e, n))
    }
    function XE(t, e, n) {
        n = Math.min(t.length, n);
        let r = []
          , i = e;
        for (; i < n; ) {
            let o = t[i]
              , s = null
              , a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (i + a <= n) {
                let c, u, l, d;
                switch (a) {
                case 1:
                    o < 128 && (s = o);
                    break;
                case 2:
                    c = t[i + 1],
                    (c & 192) === 128 && (d = (o & 31) << 6 | c & 63,
                    d > 127 && (s = d));
                    break;
                case 3:
                    c = t[i + 1],
                    u = t[i + 2],
                    (c & 192) === 128 && (u & 192) === 128 && (d = (o & 15) << 12 | (c & 63) << 6 | u & 63,
                    d > 2047 && (d < 55296 || d > 57343) && (s = d));
                    break;
                case 4:
                    c = t[i + 1],
                    u = t[i + 2],
                    l = t[i + 3],
                    (c & 192) === 128 && (u & 192) === 128 && (l & 192) === 128 && (d = (o & 15) << 18 | (c & 63) << 12 | (u & 63) << 6 | l & 63,
                    d > 65535 && d < 1114112 && (s = d))
                }
            }
            s === null ? (s = 65533,
            a = 1) : s > 65535 && (s -= 65536,
            r.push(s >>> 10 & 1023 | 55296),
            s = 56320 | s & 1023),
            r.push(s),
            i += a
        }
        return EF(r)
    }
    var qE = 4096;
    function EF(t) {
        let e = t.length;
        if (e <= qE)
            return String.fromCharCode.apply(String, t);
        let n = ""
          , r = 0;
        for (; r < e; )
            n += String.fromCharCode.apply(String, t.slice(r, r += qE));
        return n
    }
    function CF(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let i = e; i < n; ++i)
            r += String.fromCharCode(t[i] & 127);
        return r
    }
    function DF(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let i = e; i < n; ++i)
            r += String.fromCharCode(t[i]);
        return r
    }
    function IF(t, e, n) {
        let r = t.length;
        (!e || e < 0) && (e = 0),
        (!n || n < 0 || n > r) && (n = r);
        let i = "";
        for (let o = e; o < n; ++o)
            i += BF[t[o]];
        return i
    }
    function AF(t, e, n) {
        let r = t.slice(e, n)
          , i = "";
        for (let o = 0; o < r.length - 1; o += 2)
            i += String.fromCharCode(r[o] + r[o + 1] * 256);
        return i
    }
    Z.prototype.slice = function(e, n) {
        let r = this.length;
        e = ~~e,
        n = n === void 0 ? r : ~~n,
        e < 0 ? (e += r,
        e < 0 && (e = 0)) : e > r && (e = r),
        n < 0 ? (n += r,
        n < 0 && (n = 0)) : n > r && (n = r),
        n < e && (n = e);
        let i = this.subarray(e, n);
        return Object.setPrototypeOf(i, Z.prototype),
        i
    }
    ;
    function un(t, e, n) {
        if (t % 1 !== 0 || t < 0)
            throw new RangeError("offset is not uint");
        if (t + e > n)
            throw new RangeError("Trying to access beyond buffer length")
    }
    Z.prototype.readUintLE = Z.prototype.readUIntLE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || un(e, n, this.length);
        let i = this[e]
          , o = 1
          , s = 0;
        for (; ++s < n && (o *= 256); )
            i += this[e + s] * o;
        return i
    }
    ;
    Z.prototype.readUintBE = Z.prototype.readUIntBE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || un(e, n, this.length);
        let i = this[e + --n]
          , o = 1;
        for (; n > 0 && (o *= 256); )
            i += this[e + --n] * o;
        return i
    }
    ;
    Z.prototype.readUint8 = Z.prototype.readUInt8 = function(e, n) {
        return e = e >>> 0,
        n || un(e, 1, this.length),
        this[e]
    }
    ;
    Z.prototype.readUint16LE = Z.prototype.readUInt16LE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 2, this.length),
        this[e] | this[e + 1] << 8
    }
    ;
    Z.prototype.readUint16BE = Z.prototype.readUInt16BE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 2, this.length),
        this[e] << 8 | this[e + 1]
    }
    ;
    Z.prototype.readUint32LE = Z.prototype.readUInt32LE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 4, this.length),
        (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
    }
    ;
    Z.prototype.readUint32BE = Z.prototype.readUInt32BE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 4, this.length),
        this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
    }
    ;
    Z.prototype.readBigUInt64LE = Zi(function(e) {
        e = e >>> 0,
        ta(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Mc(e, this.length - 8);
        let i = n + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24
          , o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
        return BigInt(i) + (BigInt(o) << BigInt(32))
    });
    Z.prototype.readBigUInt64BE = Zi(function(e) {
        e = e >>> 0,
        ta(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Mc(e, this.length - 8);
        let i = n * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e]
          , o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
        return (BigInt(i) << BigInt(32)) + BigInt(o)
    });
    Z.prototype.readIntLE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || un(e, n, this.length);
        let i = this[e]
          , o = 1
          , s = 0;
        for (; ++s < n && (o *= 256); )
            i += this[e + s] * o;
        return o *= 128,
        i >= o && (i -= Math.pow(2, 8 * n)),
        i
    }
    ;
    Z.prototype.readIntBE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || un(e, n, this.length);
        let i = n
          , o = 1
          , s = this[e + --i];
        for (; i > 0 && (o *= 256); )
            s += this[e + --i] * o;
        return o *= 128,
        s >= o && (s -= Math.pow(2, 8 * n)),
        s
    }
    ;
    Z.prototype.readInt8 = function(e, n) {
        return e = e >>> 0,
        n || un(e, 1, this.length),
        this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
    }
    ;
    Z.prototype.readInt16LE = function(e, n) {
        e = e >>> 0,
        n || un(e, 2, this.length);
        let r = this[e] | this[e + 1] << 8;
        return r & 32768 ? r | 4294901760 : r
    }
    ;
    Z.prototype.readInt16BE = function(e, n) {
        e = e >>> 0,
        n || un(e, 2, this.length);
        let r = this[e + 1] | this[e] << 8;
        return r & 32768 ? r | 4294901760 : r
    }
    ;
    Z.prototype.readInt32LE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 4, this.length),
        this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
    }
    ;
    Z.prototype.readInt32BE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 4, this.length),
        this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
    }
    ;
    Z.prototype.readBigInt64LE = Zi(function(e) {
        e = e >>> 0,
        ta(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Mc(e, this.length - 8);
        let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
        return (BigInt(i) << BigInt(32)) + BigInt(n + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
    });
    Z.prototype.readBigInt64BE = Zi(function(e) {
        e = e >>> 0,
        ta(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Mc(e, this.length - 8);
        let i = (n << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
        return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r)
    });
    Z.prototype.readFloatLE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 4, this.length),
        ea.read(this, e, !0, 23, 4)
    }
    ;
    Z.prototype.readFloatBE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 4, this.length),
        ea.read(this, e, !1, 23, 4)
    }
    ;
    Z.prototype.readDoubleLE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 8, this.length),
        ea.read(this, e, !0, 52, 8)
    }
    ;
    Z.prototype.readDoubleBE = function(e, n) {
        return e = e >>> 0,
        n || un(e, 8, this.length),
        ea.read(this, e, !1, 52, 8)
    }
    ;
    function Hn(t, e, n, r, i, o) {
        if (!Z.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > i || e < o)
            throw new RangeError('"value" argument is out of bounds');
        if (n + r > t.length)
            throw new RangeError("Index out of range")
    }
    Z.prototype.writeUintLE = Z.prototype.writeUIntLE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        r = r >>> 0,
        !i) {
            let a = Math.pow(2, 8 * r) - 1;
            Hn(this, e, n, r, a, 0)
        }
        let o = 1
          , s = 0;
        for (this[n] = e & 255; ++s < r && (o *= 256); )
            this[n + s] = e / o & 255;
        return n + r
    }
    ;
    Z.prototype.writeUintBE = Z.prototype.writeUIntBE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        r = r >>> 0,
        !i) {
            let a = Math.pow(2, 8 * r) - 1;
            Hn(this, e, n, r, a, 0)
        }
        let o = r - 1
          , s = 1;
        for (this[n + o] = e & 255; --o >= 0 && (s *= 256); )
            this[n + o] = e / s & 255;
        return n + r
    }
    ;
    Z.prototype.writeUint8 = Z.prototype.writeUInt8 = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 1, 255, 0),
        this[n] = e & 255,
        n + 1
    }
    ;
    Z.prototype.writeUint16LE = Z.prototype.writeUInt16LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 2, 65535, 0),
        this[n] = e & 255,
        this[n + 1] = e >>> 8,
        n + 2
    }
    ;
    Z.prototype.writeUint16BE = Z.prototype.writeUInt16BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 2, 65535, 0),
        this[n] = e >>> 8,
        this[n + 1] = e & 255,
        n + 2
    }
    ;
    Z.prototype.writeUint32LE = Z.prototype.writeUInt32LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 4, 4294967295, 0),
        this[n + 3] = e >>> 24,
        this[n + 2] = e >>> 16,
        this[n + 1] = e >>> 8,
        this[n] = e & 255,
        n + 4
    }
    ;
    Z.prototype.writeUint32BE = Z.prototype.writeUInt32BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 4, 4294967295, 0),
        this[n] = e >>> 24,
        this[n + 1] = e >>> 16,
        this[n + 2] = e >>> 8,
        this[n + 3] = e & 255,
        n + 4
    }
    ;
    function QE(t, e, n, r, i) {
        rC(e, r, i, t, n, 7);
        let o = Number(e & BigInt(4294967295));
        t[n++] = o,
        o = o >> 8,
        t[n++] = o,
        o = o >> 8,
        t[n++] = o,
        o = o >> 8,
        t[n++] = o;
        let s = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[n++] = s,
        s = s >> 8,
        t[n++] = s,
        s = s >> 8,
        t[n++] = s,
        s = s >> 8,
        t[n++] = s,
        n
    }
    function JE(t, e, n, r, i) {
        rC(e, r, i, t, n, 7);
        let o = Number(e & BigInt(4294967295));
        t[n + 7] = o,
        o = o >> 8,
        t[n + 6] = o,
        o = o >> 8,
        t[n + 5] = o,
        o = o >> 8,
        t[n + 4] = o;
        let s = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[n + 3] = s,
        s = s >> 8,
        t[n + 2] = s,
        s = s >> 8,
        t[n + 1] = s,
        s = s >> 8,
        t[n] = s,
        n + 8
    }
    Z.prototype.writeBigUInt64LE = Zi(function(e, n=0) {
        return QE(this, e, n, BigInt(0), BigInt("0xffffffffffffffff"))
    });
    Z.prototype.writeBigUInt64BE = Zi(function(e, n=0) {
        return JE(this, e, n, BigInt(0), BigInt("0xffffffffffffffff"))
    });
    Z.prototype.writeIntLE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        !i) {
            let c = Math.pow(2, 8 * r - 1);
            Hn(this, e, n, r, c - 1, -c)
        }
        let o = 0
          , s = 1
          , a = 0;
        for (this[n] = e & 255; ++o < r && (s *= 256); )
            e < 0 && a === 0 && this[n + o - 1] !== 0 && (a = 1),
            this[n + o] = (e / s >> 0) - a & 255;
        return n + r
    }
    ;
    Z.prototype.writeIntBE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        !i) {
            let c = Math.pow(2, 8 * r - 1);
            Hn(this, e, n, r, c - 1, -c)
        }
        let o = r - 1
          , s = 1
          , a = 0;
        for (this[n + o] = e & 255; --o >= 0 && (s *= 256); )
            e < 0 && a === 0 && this[n + o + 1] !== 0 && (a = 1),
            this[n + o] = (e / s >> 0) - a & 255;
        return n + r
    }
    ;
    Z.prototype.writeInt8 = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 1, 127, -128),
        e < 0 && (e = 255 + e + 1),
        this[n] = e & 255,
        n + 1
    }
    ;
    Z.prototype.writeInt16LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 2, 32767, -32768),
        this[n] = e & 255,
        this[n + 1] = e >>> 8,
        n + 2
    }
    ;
    Z.prototype.writeInt16BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 2, 32767, -32768),
        this[n] = e >>> 8,
        this[n + 1] = e & 255,
        n + 2
    }
    ;
    Z.prototype.writeInt32LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 4, 2147483647, -2147483648),
        this[n] = e & 255,
        this[n + 1] = e >>> 8,
        this[n + 2] = e >>> 16,
        this[n + 3] = e >>> 24,
        n + 4
    }
    ;
    Z.prototype.writeInt32BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || Hn(this, e, n, 4, 2147483647, -2147483648),
        e < 0 && (e = 4294967295 + e + 1),
        this[n] = e >>> 24,
        this[n + 1] = e >>> 16,
        this[n + 2] = e >>> 8,
        this[n + 3] = e & 255,
        n + 4
    }
    ;
    Z.prototype.writeBigInt64LE = Zi(function(e, n=0) {
        return QE(this, e, n, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    Z.prototype.writeBigInt64BE = Zi(function(e, n=0) {
        return JE(this, e, n, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function eC(t, e, n, r, i, o) {
        if (n + r > t.length)
            throw new RangeError("Index out of range");
        if (n < 0)
            throw new RangeError("Index out of range")
    }
    function tC(t, e, n, r, i) {
        return e = +e,
        n = n >>> 0,
        i || eC(t, e, n, 4, 34028234663852886e22, -34028234663852886e22),
        ea.write(t, e, n, r, 23, 4),
        n + 4
    }
    Z.prototype.writeFloatLE = function(e, n, r) {
        return tC(this, e, n, !0, r)
    }
    ;
    Z.prototype.writeFloatBE = function(e, n, r) {
        return tC(this, e, n, !1, r)
    }
    ;
    function nC(t, e, n, r, i) {
        return e = +e,
        n = n >>> 0,
        i || eC(t, e, n, 8, 17976931348623157e292, -17976931348623157e292),
        ea.write(t, e, n, r, 52, 8),
        n + 8
    }
    Z.prototype.writeDoubleLE = function(e, n, r) {
        return nC(this, e, n, !0, r)
    }
    ;
    Z.prototype.writeDoubleBE = function(e, n, r) {
        return nC(this, e, n, !1, r)
    }
    ;
    Z.prototype.copy = function(e, n, r, i) {
        if (!Z.isBuffer(e))
            throw new TypeError("argument should be a Buffer");
        if (r || (r = 0),
        !i && i !== 0 && (i = this.length),
        n >= e.length && (n = e.length),
        n || (n = 0),
        i > 0 && i < r && (i = r),
        i === r || e.length === 0 || this.length === 0)
            return 0;
        if (n < 0)
            throw new RangeError("targetStart out of bounds");
        if (r < 0 || r >= this.length)
            throw new RangeError("Index out of range");
        if (i < 0)
            throw new RangeError("sourceEnd out of bounds");
        i > this.length && (i = this.length),
        e.length - n < i - r && (i = e.length - n + r);
        let o = i - r;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(n, r, i) : Uint8Array.prototype.set.call(e, this.subarray(r, i), n),
        o
    }
    ;
    Z.prototype.fill = function(e, n, r, i) {
        if (typeof e == "string") {
            if (typeof n == "string" ? (i = n,
            n = 0,
            r = this.length) : typeof r == "string" && (i = r,
            r = this.length),
            i !== void 0 && typeof i != "string")
                throw new TypeError("encoding must be a string");
            if (typeof i == "string" && !Z.isEncoding(i))
                throw new TypeError("Unknown encoding: " + i);
            if (e.length === 1) {
                let s = e.charCodeAt(0);
                (i === "utf8" && s < 128 || i === "latin1") && (e = s)
            }
        } else
            typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (n < 0 || this.length < n || this.length < r)
            throw new RangeError("Out of range index");
        if (r <= n)
            return this;
        n = n >>> 0,
        r = r === void 0 ? this.length : r >>> 0,
        e || (e = 0);
        let o;
        if (typeof e == "number")
            for (o = n; o < r; ++o)
                this[o] = e;
        else {
            let s = Z.isBuffer(e) ? e : Z.from(e, i)
              , a = s.length;
            if (a === 0)
                throw new TypeError('The value "' + e + '" is invalid for argument "value"');
            for (o = 0; o < r - n; ++o)
                this[o + n] = s[o % a]
        }
        return this
    }
    ;
    var Js = {};
    function Om(t, e, n) {
        Js[t] = class extends n {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: e.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${t}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return t
            }
            set code(i) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: i,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${t}]: ${this.message}`
            }
        }
    }
    Om("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
        return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError);
    Om("ERR_INVALID_ARG_TYPE", function(t, e) {
        return `The "${t}" argument must be of type number. Received type ${typeof e}`
    }, TypeError);
    Om("ERR_OUT_OF_RANGE", function(t, e, n) {
        let r = `The value of "${t}" is out of range.`
          , i = n;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = WE(String(n)) : typeof n == "bigint" && (i = String(n),
        (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = WE(i)),
        i += "n"),
        r += ` It must be ${e}. Received ${i}`,
        r
    }, RangeError);
    function WE(t) {
        let e = ""
          , n = t.length
          , r = t[0] === "-" ? 1 : 0;
        for (; n >= r + 4; n -= 3)
            e = `_${t.slice(n - 3, n)}${e}`;
        return `${t.slice(0, n)}${e}`
    }
    function _F(t, e, n) {
        ta(e, "offset"),
        (t[e] === void 0 || t[e + n] === void 0) && Mc(e, t.length - (n + 1))
    }
    function rC(t, e, n, r, i, o) {
        if (t > n || t < e) {
            let s = typeof e == "bigint" ? "n" : "", a;
            throw o > 3 ? e === 0 || e === BigInt(0) ? a = `>= 0${s} and < 2${s} ** ${(o + 1) * 8}${s}` : a = `>= -(2${s} ** ${(o + 1) * 8 - 1}${s}) and < 2 ** ${(o + 1) * 8 - 1}${s}` : a = `>= ${e}${s} and <= ${n}${s}`,
            new Js.ERR_OUT_OF_RANGE("value",a,t)
        }
        _F(r, i, o)
    }
    function ta(t, e) {
        if (typeof t != "number")
            throw new Js.ERR_INVALID_ARG_TYPE(e,"number",t)
    }
    function Mc(t, e, n) {
        throw Math.floor(t) !== t ? (ta(t, n),
        new Js.ERR_OUT_OF_RANGE(n || "offset","an integer",t)) : e < 0 ? new Js.ERR_BUFFER_OUT_OF_BOUNDS : new Js.ERR_OUT_OF_RANGE(n || "offset",`>= ${n ? 1 : 0} and <= ${e}`,t)
    }
    var SF = /[^+/0-9A-Za-z-_]/g;
    function MF(t) {
        if (t = t.split("=")[0],
        t = t.trim().replace(SF, ""),
        t.length < 2)
            return "";
        for (; t.length % 4 !== 0; )
            t = t + "=";
        return t
    }
    function Fm(t, e) {
        e = e || 1 / 0;
        let n, r = t.length, i = null, o = [];
        for (let s = 0; s < r; ++s) {
            if (n = t.charCodeAt(s),
            n > 55295 && n < 57344) {
                if (!i) {
                    if (n > 56319) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue
                    } else if (s + 1 === r) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue
                    }
                    i = n;
                    continue
                }
                if (n < 56320) {
                    (e -= 3) > -1 && o.push(239, 191, 189),
                    i = n;
                    continue
                }
                n = (i - 55296 << 10 | n - 56320) + 65536
            } else
                i && (e -= 3) > -1 && o.push(239, 191, 189);
            if (i = null,
            n < 128) {
                if ((e -= 1) < 0)
                    break;
                o.push(n)
            } else if (n < 2048) {
                if ((e -= 2) < 0)
                    break;
                o.push(n >> 6 | 192, n & 63 | 128)
            } else if (n < 65536) {
                if ((e -= 3) < 0)
                    break;
                o.push(n >> 12 | 224, n >> 6 & 63 | 128, n & 63 | 128)
            } else if (n < 1114112) {
                if ((e -= 4) < 0)
                    break;
                o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, n & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return o
    }
    function kF(t) {
        let e = [];
        for (let n = 0; n < t.length; ++n)
            e.push(t.charCodeAt(n) & 255);
        return e
    }
    function TF(t, e) {
        let n, r, i, o = [];
        for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
            n = t.charCodeAt(s),
            r = n >> 8,
            i = n % 256,
            o.push(i),
            o.push(r);
        return o
    }
    function iC(t) {
        return Tm.toByteArray(MF(t))
    }
    function xf(t, e, n, r) {
        let i;
        for (i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
            e[i + n] = t[i];
        return i
    }
    function Zr(t, e) {
        return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name
    }
    function Lm(t) {
        return t !== t
    }
    var BF = function() {
        let t = "0123456789abcdef"
          , e = new Array(256);
        for (let n = 0; n < 16; ++n) {
            let r = n * 16;
            for (let i = 0; i < 16; ++i)
                e[r + i] = t[n] + t[i]
        }
        return e
    }();
    function Zi(t) {
        return typeof BigInt > "u" ? RF : t
    }
    function RF() {
        throw new Error("BigInt not supported")
    }
}
);
var jC = Ce(ua=>{
    "use strict";
    var iy = Sm()
      , aa = km()
      , IC = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    ua.Buffer = X;
    ua.SlowBuffer = L3;
    ua.INSPECT_MAX_BYTES = 50;
    var Tf = 2147483647;
    ua.kMaxLength = Tf;
    X.TYPED_ARRAY_SUPPORT = R3();
    !X.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function R3() {
        try {
            let t = new Uint8Array(1)
              , e = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(e, Uint8Array.prototype),
            Object.setPrototypeOf(t, e),
            t.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(X.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (X.isBuffer(this))
                return this.buffer
        }
    });
    Object.defineProperty(X.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (X.isBuffer(this))
                return this.byteOffset
        }
    });
    function Ei(t) {
        if (t > Tf)
            throw new RangeError('The value "' + t + '" is invalid for option "size"');
        let e = new Uint8Array(t);
        return Object.setPrototypeOf(e, X.prototype),
        e
    }
    function X(t, e, n) {
        if (typeof t == "number") {
            if (typeof e == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return cy(t)
        }
        return MC(t, e, n)
    }
    X.poolSize = 8192;
    function MC(t, e, n) {
        if (typeof t == "string")
            return N3(t, e);
        if (ArrayBuffer.isView(t))
            return P3(t);
        if (t == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
        if (Qr(t, ArrayBuffer) || t && Qr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Qr(t, SharedArrayBuffer) || t && Qr(t.buffer, SharedArrayBuffer)))
            return sy(t, e, n);
        if (typeof t == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        let r = t.valueOf && t.valueOf();
        if (r != null && r !== t)
            return X.from(r, e, n);
        let i = O3(t);
        if (i)
            return i;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
            return X.from(t[Symbol.toPrimitive]("string"), e, n);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
    }
    X.from = function(t, e, n) {
        return MC(t, e, n)
    }
    ;
    Object.setPrototypeOf(X.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(X, Uint8Array);
    function kC(t) {
        if (typeof t != "number")
            throw new TypeError('"size" argument must be of type number');
        if (t < 0)
            throw new RangeError('The value "' + t + '" is invalid for option "size"')
    }
    function F3(t, e, n) {
        return kC(t),
        t <= 0 ? Ei(t) : e !== void 0 ? typeof n == "string" ? Ei(t).fill(e, n) : Ei(t).fill(e) : Ei(t)
    }
    X.alloc = function(t, e, n) {
        return F3(t, e, n)
    }
    ;
    function cy(t) {
        return kC(t),
        Ei(t < 0 ? 0 : uy(t) | 0)
    }
    X.allocUnsafe = function(t) {
        return cy(t)
    }
    ;
    X.allocUnsafeSlow = function(t) {
        return cy(t)
    }
    ;
    function N3(t, e) {
        if ((typeof e != "string" || e === "") && (e = "utf8"),
        !X.isEncoding(e))
            throw new TypeError("Unknown encoding: " + e);
        let n = TC(t, e) | 0
          , r = Ei(n)
          , i = r.write(t, e);
        return i !== n && (r = r.slice(0, i)),
        r
    }
    function oy(t) {
        let e = t.length < 0 ? 0 : uy(t.length) | 0
          , n = Ei(e);
        for (let r = 0; r < e; r += 1)
            n[r] = t[r] & 255;
        return n
    }
    function P3(t) {
        if (Qr(t, Uint8Array)) {
            let e = new Uint8Array(t);
            return sy(e.buffer, e.byteOffset, e.byteLength)
        }
        return oy(t)
    }
    function sy(t, e, n) {
        if (e < 0 || t.byteLength < e)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (t.byteLength < e + (n || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let r;
        return e === void 0 && n === void 0 ? r = new Uint8Array(t) : n === void 0 ? r = new Uint8Array(t,e) : r = new Uint8Array(t,e,n),
        Object.setPrototypeOf(r, X.prototype),
        r
    }
    function O3(t) {
        if (X.isBuffer(t)) {
            let e = uy(t.length) | 0
              , n = Ei(e);
            return n.length === 0 || t.copy(n, 0, 0, e),
            n
        }
        if (t.length !== void 0)
            return typeof t.length != "number" || fy(t.length) ? Ei(0) : oy(t);
        if (t.type === "Buffer" && Array.isArray(t.data))
            return oy(t.data)
    }
    function uy(t) {
        if (t >= Tf)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Tf.toString(16) + " bytes");
        return t | 0
    }
    function L3(t) {
        return +t != t && (t = 0),
        X.alloc(+t)
    }
    X.isBuffer = function(e) {
        return e != null && e._isBuffer === !0 && e !== X.prototype
    }
    ;
    X.compare = function(e, n) {
        if (Qr(e, Uint8Array) && (e = X.from(e, e.offset, e.byteLength)),
        Qr(n, Uint8Array) && (n = X.from(n, n.offset, n.byteLength)),
        !X.isBuffer(e) || !X.isBuffer(n))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === n)
            return 0;
        let r = e.length
          , i = n.length;
        for (let o = 0, s = Math.min(r, i); o < s; ++o)
            if (e[o] !== n[o]) {
                r = e[o],
                i = n[o];
                break
            }
        return r < i ? -1 : i < r ? 1 : 0
    }
    ;
    X.isEncoding = function(e) {
        switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ;
    X.concat = function(e, n) {
        if (!Array.isArray(e))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0)
            return X.alloc(0);
        let r;
        if (n === void 0)
            for (n = 0,
            r = 0; r < e.length; ++r)
                n += e[r].length;
        let i = X.allocUnsafe(n)
          , o = 0;
        for (r = 0; r < e.length; ++r) {
            let s = e[r];
            if (Qr(s, Uint8Array))
                o + s.length > i.length ? (X.isBuffer(s) || (s = X.from(s)),
                s.copy(i, o)) : Uint8Array.prototype.set.call(i, s, o);
            else if (X.isBuffer(s))
                s.copy(i, o);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            o += s.length
        }
        return i
    }
    ;
    function TC(t, e) {
        if (X.isBuffer(t))
            return t.length;
        if (ArrayBuffer.isView(t) || Qr(t, ArrayBuffer))
            return t.byteLength;
        if (typeof t != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
        let n = t.length
          , r = arguments.length > 2 && arguments[2] === !0;
        if (!r && n === 0)
            return 0;
        let i = !1;
        for (; ; )
            switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
                return n;
            case "utf8":
            case "utf-8":
                return ay(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return n * 2;
            case "hex":
                return n >>> 1;
            case "base64":
                return VC(t).length;
            default:
                if (i)
                    return r ? -1 : ay(t).length;
                e = ("" + e).toLowerCase(),
                i = !0
            }
    }
    X.byteLength = TC;
    function U3(t, e, n) {
        let r = !1;
        if ((e === void 0 || e < 0) && (e = 0),
        e > this.length || ((n === void 0 || n > this.length) && (n = this.length),
        n <= 0) || (n >>>= 0,
        e >>>= 0,
        n <= e))
            return "";
        for (t || (t = "utf8"); ; )
            switch (t) {
            case "hex":
                return Y3(this, e, n);
            case "utf8":
            case "utf-8":
                return RC(this, e, n);
            case "ascii":
                return G3(this, e, n);
            case "latin1":
            case "binary":
                return K3(this, e, n);
            case "base64":
                return q3(this, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Z3(this, e, n);
            default:
                if (r)
                    throw new TypeError("Unknown encoding: " + t);
                t = (t + "").toLowerCase(),
                r = !0
            }
    }
    X.prototype._isBuffer = !0;
    function Go(t, e, n) {
        let r = t[e];
        t[e] = t[n],
        t[n] = r
    }
    X.prototype.swap16 = function() {
        let e = this.length;
        if (e % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let n = 0; n < e; n += 2)
            Go(this, n, n + 1);
        return this
    }
    ;
    X.prototype.swap32 = function() {
        let e = this.length;
        if (e % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let n = 0; n < e; n += 4)
            Go(this, n, n + 3),
            Go(this, n + 1, n + 2);
        return this
    }
    ;
    X.prototype.swap64 = function() {
        let e = this.length;
        if (e % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let n = 0; n < e; n += 8)
            Go(this, n, n + 7),
            Go(this, n + 1, n + 6),
            Go(this, n + 2, n + 5),
            Go(this, n + 3, n + 4);
        return this
    }
    ;
    X.prototype.toString = function() {
        let e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? RC(this, 0, e) : U3.apply(this, arguments)
    }
    ;
    X.prototype.toLocaleString = X.prototype.toString;
    X.prototype.equals = function(e) {
        if (!X.isBuffer(e))
            throw new TypeError("Argument must be a Buffer");
        return this === e ? !0 : X.compare(this, e) === 0
    }
    ;
    X.prototype.inspect = function() {
        let e = ""
          , n = ua.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(),
        this.length > n && (e += " ... "),
        "<Buffer " + e + ">"
    }
    ;
    IC && (X.prototype[IC] = X.prototype.inspect);
    X.prototype.compare = function(e, n, r, i, o) {
        if (Qr(e, Uint8Array) && (e = X.from(e, e.offset, e.byteLength)),
        !X.isBuffer(e))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (n === void 0 && (n = 0),
        r === void 0 && (r = e ? e.length : 0),
        i === void 0 && (i = 0),
        o === void 0 && (o = this.length),
        n < 0 || r > e.length || i < 0 || o > this.length)
            throw new RangeError("out of range index");
        if (i >= o && n >= r)
            return 0;
        if (i >= o)
            return -1;
        if (n >= r)
            return 1;
        if (n >>>= 0,
        r >>>= 0,
        i >>>= 0,
        o >>>= 0,
        this === e)
            return 0;
        let s = o - i
          , a = r - n
          , c = Math.min(s, a)
          , u = this.slice(i, o)
          , l = e.slice(n, r);
        for (let d = 0; d < c; ++d)
            if (u[d] !== l[d]) {
                s = u[d],
                a = l[d];
                break
            }
        return s < a ? -1 : a < s ? 1 : 0
    }
    ;
    function BC(t, e, n, r, i) {
        if (t.length === 0)
            return -1;
        if (typeof n == "string" ? (r = n,
        n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
        n = +n,
        fy(n) && (n = i ? 0 : t.length - 1),
        n < 0 && (n = t.length + n),
        n >= t.length) {
            if (i)
                return -1;
            n = t.length - 1
        } else if (n < 0)
            if (i)
                n = 0;
            else
                return -1;
        if (typeof e == "string" && (e = X.from(e, r)),
        X.isBuffer(e))
            return e.length === 0 ? -1 : AC(t, e, n, r, i);
        if (typeof e == "number")
            return e = e & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : AC(t, [e], n, r, i);
        throw new TypeError("val must be string, number or Buffer")
    }
    function AC(t, e, n, r, i) {
        let o = 1
          , s = t.length
          , a = e.length;
        if (r !== void 0 && (r = String(r).toLowerCase(),
        r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")) {
            if (t.length < 2 || e.length < 2)
                return -1;
            o = 2,
            s /= 2,
            a /= 2,
            n /= 2
        }
        function c(l, d) {
            return o === 1 ? l[d] : l.readUInt16BE(d * o)
        }
        let u;
        if (i) {
            let l = -1;
            for (u = n; u < s; u++)
                if (c(t, u) === c(e, l === -1 ? 0 : u - l)) {
                    if (l === -1 && (l = u),
                    u - l + 1 === a)
                        return l * o
                } else
                    l !== -1 && (u -= u - l),
                    l = -1
        } else
            for (n + a > s && (n = s - a),
            u = n; u >= 0; u--) {
                let l = !0;
                for (let d = 0; d < a; d++)
                    if (c(t, u + d) !== c(e, d)) {
                        l = !1;
                        break
                    }
                if (l)
                    return u
            }
        return -1
    }
    X.prototype.includes = function(e, n, r) {
        return this.indexOf(e, n, r) !== -1
    }
    ;
    X.prototype.indexOf = function(e, n, r) {
        return BC(this, e, n, r, !0)
    }
    ;
    X.prototype.lastIndexOf = function(e, n, r) {
        return BC(this, e, n, r, !1)
    }
    ;
    function V3(t, e, n, r) {
        n = Number(n) || 0;
        let i = t.length - n;
        r ? (r = Number(r),
        r > i && (r = i)) : r = i;
        let o = e.length;
        r > o / 2 && (r = o / 2);
        let s;
        for (s = 0; s < r; ++s) {
            let a = parseInt(e.substr(s * 2, 2), 16);
            if (fy(a))
                return s;
            t[n + s] = a
        }
        return s
    }
    function j3(t, e, n, r) {
        return Bf(ay(e, t.length - n), t, n, r)
    }
    function $3(t, e, n, r) {
        return Bf(e4(e), t, n, r)
    }
    function H3(t, e, n, r) {
        return Bf(VC(e), t, n, r)
    }
    function z3(t, e, n, r) {
        return Bf(t4(e, t.length - n), t, n, r)
    }
    X.prototype.write = function(e, n, r, i) {
        if (n === void 0)
            i = "utf8",
            r = this.length,
            n = 0;
        else if (r === void 0 && typeof n == "string")
            i = n,
            r = this.length,
            n = 0;
        else if (isFinite(n))
            n = n >>> 0,
            isFinite(r) ? (r = r >>> 0,
            i === void 0 && (i = "utf8")) : (i = r,
            r = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - n;
        if ((r === void 0 || r > o) && (r = o),
        e.length > 0 && (r < 0 || n < 0) || n > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        i || (i = "utf8");
        let s = !1;
        for (; ; )
            switch (i) {
            case "hex":
                return V3(this, e, n, r);
            case "utf8":
            case "utf-8":
                return j3(this, e, n, r);
            case "ascii":
            case "latin1":
            case "binary":
                return $3(this, e, n, r);
            case "base64":
                return H3(this, e, n, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return z3(this, e, n, r);
            default:
                if (s)
                    throw new TypeError("Unknown encoding: " + i);
                i = ("" + i).toLowerCase(),
                s = !0
            }
    }
    ;
    X.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function q3(t, e, n) {
        return e === 0 && n === t.length ? iy.fromByteArray(t) : iy.fromByteArray(t.slice(e, n))
    }
    function RC(t, e, n) {
        n = Math.min(t.length, n);
        let r = []
          , i = e;
        for (; i < n; ) {
            let o = t[i]
              , s = null
              , a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (i + a <= n) {
                let c, u, l, d;
                switch (a) {
                case 1:
                    o < 128 && (s = o);
                    break;
                case 2:
                    c = t[i + 1],
                    (c & 192) === 128 && (d = (o & 31) << 6 | c & 63,
                    d > 127 && (s = d));
                    break;
                case 3:
                    c = t[i + 1],
                    u = t[i + 2],
                    (c & 192) === 128 && (u & 192) === 128 && (d = (o & 15) << 12 | (c & 63) << 6 | u & 63,
                    d > 2047 && (d < 55296 || d > 57343) && (s = d));
                    break;
                case 4:
                    c = t[i + 1],
                    u = t[i + 2],
                    l = t[i + 3],
                    (c & 192) === 128 && (u & 192) === 128 && (l & 192) === 128 && (d = (o & 15) << 18 | (c & 63) << 12 | (u & 63) << 6 | l & 63,
                    d > 65535 && d < 1114112 && (s = d))
                }
            }
            s === null ? (s = 65533,
            a = 1) : s > 65535 && (s -= 65536,
            r.push(s >>> 10 & 1023 | 55296),
            s = 56320 | s & 1023),
            r.push(s),
            i += a
        }
        return W3(r)
    }
    var _C = 4096;
    function W3(t) {
        let e = t.length;
        if (e <= _C)
            return String.fromCharCode.apply(String, t);
        let n = ""
          , r = 0;
        for (; r < e; )
            n += String.fromCharCode.apply(String, t.slice(r, r += _C));
        return n
    }
    function G3(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let i = e; i < n; ++i)
            r += String.fromCharCode(t[i] & 127);
        return r
    }
    function K3(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let i = e; i < n; ++i)
            r += String.fromCharCode(t[i]);
        return r
    }
    function Y3(t, e, n) {
        let r = t.length;
        (!e || e < 0) && (e = 0),
        (!n || n < 0 || n > r) && (n = r);
        let i = "";
        for (let o = e; o < n; ++o)
            i += n4[t[o]];
        return i
    }
    function Z3(t, e, n) {
        let r = t.slice(e, n)
          , i = "";
        for (let o = 0; o < r.length - 1; o += 2)
            i += String.fromCharCode(r[o] + r[o + 1] * 256);
        return i
    }
    X.prototype.slice = function(e, n) {
        let r = this.length;
        e = ~~e,
        n = n === void 0 ? r : ~~n,
        e < 0 ? (e += r,
        e < 0 && (e = 0)) : e > r && (e = r),
        n < 0 ? (n += r,
        n < 0 && (n = 0)) : n > r && (n = r),
        n < e && (n = e);
        let i = this.subarray(e, n);
        return Object.setPrototypeOf(i, X.prototype),
        i
    }
    ;
    function ln(t, e, n) {
        if (t % 1 !== 0 || t < 0)
            throw new RangeError("offset is not uint");
        if (t + e > n)
            throw new RangeError("Trying to access beyond buffer length")
    }
    X.prototype.readUintLE = X.prototype.readUIntLE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || ln(e, n, this.length);
        let i = this[e]
          , o = 1
          , s = 0;
        for (; ++s < n && (o *= 256); )
            i += this[e + s] * o;
        return i
    }
    ;
    X.prototype.readUintBE = X.prototype.readUIntBE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || ln(e, n, this.length);
        let i = this[e + --n]
          , o = 1;
        for (; n > 0 && (o *= 256); )
            i += this[e + --n] * o;
        return i
    }
    ;
    X.prototype.readUint8 = X.prototype.readUInt8 = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 1, this.length),
        this[e]
    }
    ;
    X.prototype.readUint16LE = X.prototype.readUInt16LE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 2, this.length),
        this[e] | this[e + 1] << 8
    }
    ;
    X.prototype.readUint16BE = X.prototype.readUInt16BE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 2, this.length),
        this[e] << 8 | this[e + 1]
    }
    ;
    X.prototype.readUint32LE = X.prototype.readUInt32LE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 4, this.length),
        (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
    }
    ;
    X.prototype.readUint32BE = X.prototype.readUInt32BE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 4, this.length),
        this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
    }
    ;
    X.prototype.readBigUInt64LE = oo(function(e) {
        e = e >>> 0,
        ca(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Fc(e, this.length - 8);
        let i = n + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24
          , o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
        return BigInt(i) + (BigInt(o) << BigInt(32))
    });
    X.prototype.readBigUInt64BE = oo(function(e) {
        e = e >>> 0,
        ca(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Fc(e, this.length - 8);
        let i = n * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e]
          , o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
        return (BigInt(i) << BigInt(32)) + BigInt(o)
    });
    X.prototype.readIntLE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || ln(e, n, this.length);
        let i = this[e]
          , o = 1
          , s = 0;
        for (; ++s < n && (o *= 256); )
            i += this[e + s] * o;
        return o *= 128,
        i >= o && (i -= Math.pow(2, 8 * n)),
        i
    }
    ;
    X.prototype.readIntBE = function(e, n, r) {
        e = e >>> 0,
        n = n >>> 0,
        r || ln(e, n, this.length);
        let i = n
          , o = 1
          , s = this[e + --i];
        for (; i > 0 && (o *= 256); )
            s += this[e + --i] * o;
        return o *= 128,
        s >= o && (s -= Math.pow(2, 8 * n)),
        s
    }
    ;
    X.prototype.readInt8 = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 1, this.length),
        this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
    }
    ;
    X.prototype.readInt16LE = function(e, n) {
        e = e >>> 0,
        n || ln(e, 2, this.length);
        let r = this[e] | this[e + 1] << 8;
        return r & 32768 ? r | 4294901760 : r
    }
    ;
    X.prototype.readInt16BE = function(e, n) {
        e = e >>> 0,
        n || ln(e, 2, this.length);
        let r = this[e + 1] | this[e] << 8;
        return r & 32768 ? r | 4294901760 : r
    }
    ;
    X.prototype.readInt32LE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 4, this.length),
        this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
    }
    ;
    X.prototype.readInt32BE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 4, this.length),
        this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
    }
    ;
    X.prototype.readBigInt64LE = oo(function(e) {
        e = e >>> 0,
        ca(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Fc(e, this.length - 8);
        let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
        return (BigInt(i) << BigInt(32)) + BigInt(n + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
    });
    X.prototype.readBigInt64BE = oo(function(e) {
        e = e >>> 0,
        ca(e, "offset");
        let n = this[e]
          , r = this[e + 7];
        (n === void 0 || r === void 0) && Fc(e, this.length - 8);
        let i = (n << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
        return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r)
    });
    X.prototype.readFloatLE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 4, this.length),
        aa.read(this, e, !0, 23, 4)
    }
    ;
    X.prototype.readFloatBE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 4, this.length),
        aa.read(this, e, !1, 23, 4)
    }
    ;
    X.prototype.readDoubleLE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 8, this.length),
        aa.read(this, e, !0, 52, 8)
    }
    ;
    X.prototype.readDoubleBE = function(e, n) {
        return e = e >>> 0,
        n || ln(e, 8, this.length),
        aa.read(this, e, !1, 52, 8)
    }
    ;
    function zn(t, e, n, r, i, o) {
        if (!X.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > i || e < o)
            throw new RangeError('"value" argument is out of bounds');
        if (n + r > t.length)
            throw new RangeError("Index out of range")
    }
    X.prototype.writeUintLE = X.prototype.writeUIntLE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        r = r >>> 0,
        !i) {
            let a = Math.pow(2, 8 * r) - 1;
            zn(this, e, n, r, a, 0)
        }
        let o = 1
          , s = 0;
        for (this[n] = e & 255; ++s < r && (o *= 256); )
            this[n + s] = e / o & 255;
        return n + r
    }
    ;
    X.prototype.writeUintBE = X.prototype.writeUIntBE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        r = r >>> 0,
        !i) {
            let a = Math.pow(2, 8 * r) - 1;
            zn(this, e, n, r, a, 0)
        }
        let o = r - 1
          , s = 1;
        for (this[n + o] = e & 255; --o >= 0 && (s *= 256); )
            this[n + o] = e / s & 255;
        return n + r
    }
    ;
    X.prototype.writeUint8 = X.prototype.writeUInt8 = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 1, 255, 0),
        this[n] = e & 255,
        n + 1
    }
    ;
    X.prototype.writeUint16LE = X.prototype.writeUInt16LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 2, 65535, 0),
        this[n] = e & 255,
        this[n + 1] = e >>> 8,
        n + 2
    }
    ;
    X.prototype.writeUint16BE = X.prototype.writeUInt16BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 2, 65535, 0),
        this[n] = e >>> 8,
        this[n + 1] = e & 255,
        n + 2
    }
    ;
    X.prototype.writeUint32LE = X.prototype.writeUInt32LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 4, 4294967295, 0),
        this[n + 3] = e >>> 24,
        this[n + 2] = e >>> 16,
        this[n + 1] = e >>> 8,
        this[n] = e & 255,
        n + 4
    }
    ;
    X.prototype.writeUint32BE = X.prototype.writeUInt32BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 4, 4294967295, 0),
        this[n] = e >>> 24,
        this[n + 1] = e >>> 16,
        this[n + 2] = e >>> 8,
        this[n + 3] = e & 255,
        n + 4
    }
    ;
    function FC(t, e, n, r, i) {
        UC(e, r, i, t, n, 7);
        let o = Number(e & BigInt(4294967295));
        t[n++] = o,
        o = o >> 8,
        t[n++] = o,
        o = o >> 8,
        t[n++] = o,
        o = o >> 8,
        t[n++] = o;
        let s = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[n++] = s,
        s = s >> 8,
        t[n++] = s,
        s = s >> 8,
        t[n++] = s,
        s = s >> 8,
        t[n++] = s,
        n
    }
    function NC(t, e, n, r, i) {
        UC(e, r, i, t, n, 7);
        let o = Number(e & BigInt(4294967295));
        t[n + 7] = o,
        o = o >> 8,
        t[n + 6] = o,
        o = o >> 8,
        t[n + 5] = o,
        o = o >> 8,
        t[n + 4] = o;
        let s = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[n + 3] = s,
        s = s >> 8,
        t[n + 2] = s,
        s = s >> 8,
        t[n + 1] = s,
        s = s >> 8,
        t[n] = s,
        n + 8
    }
    X.prototype.writeBigUInt64LE = oo(function(e, n=0) {
        return FC(this, e, n, BigInt(0), BigInt("0xffffffffffffffff"))
    });
    X.prototype.writeBigUInt64BE = oo(function(e, n=0) {
        return NC(this, e, n, BigInt(0), BigInt("0xffffffffffffffff"))
    });
    X.prototype.writeIntLE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        !i) {
            let c = Math.pow(2, 8 * r - 1);
            zn(this, e, n, r, c - 1, -c)
        }
        let o = 0
          , s = 1
          , a = 0;
        for (this[n] = e & 255; ++o < r && (s *= 256); )
            e < 0 && a === 0 && this[n + o - 1] !== 0 && (a = 1),
            this[n + o] = (e / s >> 0) - a & 255;
        return n + r
    }
    ;
    X.prototype.writeIntBE = function(e, n, r, i) {
        if (e = +e,
        n = n >>> 0,
        !i) {
            let c = Math.pow(2, 8 * r - 1);
            zn(this, e, n, r, c - 1, -c)
        }
        let o = r - 1
          , s = 1
          , a = 0;
        for (this[n + o] = e & 255; --o >= 0 && (s *= 256); )
            e < 0 && a === 0 && this[n + o + 1] !== 0 && (a = 1),
            this[n + o] = (e / s >> 0) - a & 255;
        return n + r
    }
    ;
    X.prototype.writeInt8 = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 1, 127, -128),
        e < 0 && (e = 255 + e + 1),
        this[n] = e & 255,
        n + 1
    }
    ;
    X.prototype.writeInt16LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 2, 32767, -32768),
        this[n] = e & 255,
        this[n + 1] = e >>> 8,
        n + 2
    }
    ;
    X.prototype.writeInt16BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 2, 32767, -32768),
        this[n] = e >>> 8,
        this[n + 1] = e & 255,
        n + 2
    }
    ;
    X.prototype.writeInt32LE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 4, 2147483647, -2147483648),
        this[n] = e & 255,
        this[n + 1] = e >>> 8,
        this[n + 2] = e >>> 16,
        this[n + 3] = e >>> 24,
        n + 4
    }
    ;
    X.prototype.writeInt32BE = function(e, n, r) {
        return e = +e,
        n = n >>> 0,
        r || zn(this, e, n, 4, 2147483647, -2147483648),
        e < 0 && (e = 4294967295 + e + 1),
        this[n] = e >>> 24,
        this[n + 1] = e >>> 16,
        this[n + 2] = e >>> 8,
        this[n + 3] = e & 255,
        n + 4
    }
    ;
    X.prototype.writeBigInt64LE = oo(function(e, n=0) {
        return FC(this, e, n, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    X.prototype.writeBigInt64BE = oo(function(e, n=0) {
        return NC(this, e, n, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function PC(t, e, n, r, i, o) {
        if (n + r > t.length)
            throw new RangeError("Index out of range");
        if (n < 0)
            throw new RangeError("Index out of range")
    }
    function OC(t, e, n, r, i) {
        return e = +e,
        n = n >>> 0,
        i || PC(t, e, n, 4, 34028234663852886e22, -34028234663852886e22),
        aa.write(t, e, n, r, 23, 4),
        n + 4
    }
    X.prototype.writeFloatLE = function(e, n, r) {
        return OC(this, e, n, !0, r)
    }
    ;
    X.prototype.writeFloatBE = function(e, n, r) {
        return OC(this, e, n, !1, r)
    }
    ;
    function LC(t, e, n, r, i) {
        return e = +e,
        n = n >>> 0,
        i || PC(t, e, n, 8, 17976931348623157e292, -17976931348623157e292),
        aa.write(t, e, n, r, 52, 8),
        n + 8
    }
    X.prototype.writeDoubleLE = function(e, n, r) {
        return LC(this, e, n, !0, r)
    }
    ;
    X.prototype.writeDoubleBE = function(e, n, r) {
        return LC(this, e, n, !1, r)
    }
    ;
    X.prototype.copy = function(e, n, r, i) {
        if (!X.isBuffer(e))
            throw new TypeError("argument should be a Buffer");
        if (r || (r = 0),
        !i && i !== 0 && (i = this.length),
        n >= e.length && (n = e.length),
        n || (n = 0),
        i > 0 && i < r && (i = r),
        i === r || e.length === 0 || this.length === 0)
            return 0;
        if (n < 0)
            throw new RangeError("targetStart out of bounds");
        if (r < 0 || r >= this.length)
            throw new RangeError("Index out of range");
        if (i < 0)
            throw new RangeError("sourceEnd out of bounds");
        i > this.length && (i = this.length),
        e.length - n < i - r && (i = e.length - n + r);
        let o = i - r;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(n, r, i) : Uint8Array.prototype.set.call(e, this.subarray(r, i), n),
        o
    }
    ;
    X.prototype.fill = function(e, n, r, i) {
        if (typeof e == "string") {
            if (typeof n == "string" ? (i = n,
            n = 0,
            r = this.length) : typeof r == "string" && (i = r,
            r = this.length),
            i !== void 0 && typeof i != "string")
                throw new TypeError("encoding must be a string");
            if (typeof i == "string" && !X.isEncoding(i))
                throw new TypeError("Unknown encoding: " + i);
            if (e.length === 1) {
                let s = e.charCodeAt(0);
                (i === "utf8" && s < 128 || i === "latin1") && (e = s)
            }
        } else
            typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (n < 0 || this.length < n || this.length < r)
            throw new RangeError("Out of range index");
        if (r <= n)
            return this;
        n = n >>> 0,
        r = r === void 0 ? this.length : r >>> 0,
        e || (e = 0);
        let o;
        if (typeof e == "number")
            for (o = n; o < r; ++o)
                this[o] = e;
        else {
            let s = X.isBuffer(e) ? e : X.from(e, i)
              , a = s.length;
            if (a === 0)
                throw new TypeError('The value "' + e + '" is invalid for argument "value"');
            for (o = 0; o < r - n; ++o)
                this[o + n] = s[o % a]
        }
        return this
    }
    ;
    var sa = {};
    function ly(t, e, n) {
        sa[t] = class extends n {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: e.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${t}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return t
            }
            set code(i) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: i,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${t}]: ${this.message}`
            }
        }
    }
    ly("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
        return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError);
    ly("ERR_INVALID_ARG_TYPE", function(t, e) {
        return `The "${t}" argument must be of type number. Received type ${typeof e}`
    }, TypeError);
    ly("ERR_OUT_OF_RANGE", function(t, e, n) {
        let r = `The value of "${t}" is out of range.`
          , i = n;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = SC(String(n)) : typeof n == "bigint" && (i = String(n),
        (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = SC(i)),
        i += "n"),
        r += ` It must be ${e}. Received ${i}`,
        r
    }, RangeError);
    function SC(t) {
        let e = ""
          , n = t.length
          , r = t[0] === "-" ? 1 : 0;
        for (; n >= r + 4; n -= 3)
            e = `_${t.slice(n - 3, n)}${e}`;
        return `${t.slice(0, n)}${e}`
    }
    function X3(t, e, n) {
        ca(e, "offset"),
        (t[e] === void 0 || t[e + n] === void 0) && Fc(e, t.length - (n + 1))
    }
    function UC(t, e, n, r, i, o) {
        if (t > n || t < e) {
            let s = typeof e == "bigint" ? "n" : "", a;
            throw o > 3 ? e === 0 || e === BigInt(0) ? a = `>= 0${s} and < 2${s} ** ${(o + 1) * 8}${s}` : a = `>= -(2${s} ** ${(o + 1) * 8 - 1}${s}) and < 2 ** ${(o + 1) * 8 - 1}${s}` : a = `>= ${e}${s} and <= ${n}${s}`,
            new sa.ERR_OUT_OF_RANGE("value",a,t)
        }
        X3(r, i, o)
    }
    function ca(t, e) {
        if (typeof t != "number")
            throw new sa.ERR_INVALID_ARG_TYPE(e,"number",t)
    }
    function Fc(t, e, n) {
        throw Math.floor(t) !== t ? (ca(t, n),
        new sa.ERR_OUT_OF_RANGE(n || "offset","an integer",t)) : e < 0 ? new sa.ERR_BUFFER_OUT_OF_BOUNDS : new sa.ERR_OUT_OF_RANGE(n || "offset",`>= ${n ? 1 : 0} and <= ${e}`,t)
    }
    var Q3 = /[^+/0-9A-Za-z-_]/g;
    function J3(t) {
        if (t = t.split("=")[0],
        t = t.trim().replace(Q3, ""),
        t.length < 2)
            return "";
        for (; t.length % 4 !== 0; )
            t = t + "=";
        return t
    }
    function ay(t, e) {
        e = e || 1 / 0;
        let n, r = t.length, i = null, o = [];
        for (let s = 0; s < r; ++s) {
            if (n = t.charCodeAt(s),
            n > 55295 && n < 57344) {
                if (!i) {
                    if (n > 56319) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue
                    } else if (s + 1 === r) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue
                    }
                    i = n;
                    continue
                }
                if (n < 56320) {
                    (e -= 3) > -1 && o.push(239, 191, 189),
                    i = n;
                    continue
                }
                n = (i - 55296 << 10 | n - 56320) + 65536
            } else
                i && (e -= 3) > -1 && o.push(239, 191, 189);
            if (i = null,
            n < 128) {
                if ((e -= 1) < 0)
                    break;
                o.push(n)
            } else if (n < 2048) {
                if ((e -= 2) < 0)
                    break;
                o.push(n >> 6 | 192, n & 63 | 128)
            } else if (n < 65536) {
                if ((e -= 3) < 0)
                    break;
                o.push(n >> 12 | 224, n >> 6 & 63 | 128, n & 63 | 128)
            } else if (n < 1114112) {
                if ((e -= 4) < 0)
                    break;
                o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, n & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return o
    }
    function e4(t) {
        let e = [];
        for (let n = 0; n < t.length; ++n)
            e.push(t.charCodeAt(n) & 255);
        return e
    }
    function t4(t, e) {
        let n, r, i, o = [];
        for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
            n = t.charCodeAt(s),
            r = n >> 8,
            i = n % 256,
            o.push(i),
            o.push(r);
        return o
    }
    function VC(t) {
        return iy.toByteArray(J3(t))
    }
    function Bf(t, e, n, r) {
        let i;
        for (i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
            e[i + n] = t[i];
        return i
    }
    function Qr(t, e) {
        return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name
    }
    function fy(t) {
        return t !== t
    }
    var n4 = function() {
        let t = "0123456789abcdef"
          , e = new Array(256);
        for (let n = 0; n < 16; ++n) {
            let r = n * 16;
            for (let i = 0; i < 16; ++i)
                e[r + i] = t[n] + t[i]
        }
        return e
    }();
    function oo(t) {
        return typeof BigInt > "u" ? r4 : t
    }
    function r4() {
        throw new Error("BigInt not supported")
    }
}
);
var Rf = Ce(($C,dy)=>{
    "use strict";
    (function(t, e) {
        "use strict";
        function n(T, f) {
            if (!T)
                throw new Error(f || "Assertion failed")
        }
        function r(T, f) {
            T.super_ = f;
            var g = function() {};
            g.prototype = f.prototype,
            T.prototype = new g,
            T.prototype.constructor = T
        }
        function i(T, f, g) {
            if (i.isBN(T))
                return T;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            T !== null && ((f === "le" || f === "be") && (g = f,
            f = 10),
            this._init(T || 0, f || 10, g || "be"))
        }
        typeof t == "object" ? t.exports = i : e.BN = i,
        i.BN = i,
        i.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = jC().Buffer
        } catch {}
        i.isBN = function(f) {
            return f instanceof i ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words)
        }
        ,
        i.max = function(f, g) {
            return f.cmp(g) > 0 ? f : g
        }
        ,
        i.min = function(f, g) {
            return f.cmp(g) < 0 ? f : g
        }
        ,
        i.prototype._init = function(f, g, x) {
            if (typeof f == "number")
                return this._initNumber(f, g, x);
            if (typeof f == "object")
                return this._initArray(f, g, x);
            g === "hex" && (g = 16),
            n(g === (g | 0) && g >= 2 && g <= 36),
            f = f.toString().replace(/\s+/g, "");
            var I = 0;
            f[0] === "-" && (I++,
            this.negative = 1),
            I < f.length && (g === 16 ? this._parseHex(f, I, x) : (this._parseBase(f, g, I),
            x === "le" && this._initArray(this.toArray(), g, x)))
        }
        ,
        i.prototype._initNumber = function(f, g, x) {
            f < 0 && (this.negative = 1,
            f = -f),
            f < 67108864 ? (this.words = [f & 67108863],
            this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863],
            this.length = 2) : (n(f < 9007199254740992),
            this.words = [f & 67108863, f / 67108864 & 67108863, 1],
            this.length = 3),
            x === "le" && this._initArray(this.toArray(), g, x)
        }
        ,
        i.prototype._initArray = function(f, g, x) {
            if (n(typeof f.length == "number"),
            f.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(f.length / 3),
            this.words = new Array(this.length);
            for (var I = 0; I < this.length; I++)
                this.words[I] = 0;
            var A, C, k = 0;
            if (x === "be")
                for (I = f.length - 1,
                A = 0; I >= 0; I -= 3)
                    C = f[I] | f[I - 1] << 8 | f[I - 2] << 16,
                    this.words[A] |= C << k & 67108863,
                    this.words[A + 1] = C >>> 26 - k & 67108863,
                    k += 24,
                    k >= 26 && (k -= 26,
                    A++);
            else if (x === "le")
                for (I = 0,
                A = 0; I < f.length; I += 3)
                    C = f[I] | f[I + 1] << 8 | f[I + 2] << 16,
                    this.words[A] |= C << k & 67108863,
                    this.words[A + 1] = C >>> 26 - k & 67108863,
                    k += 24,
                    k >= 26 && (k -= 26,
                    A++);
            return this._strip()
        }
        ;
        function s(T, f) {
            var g = T.charCodeAt(f);
            if (g >= 48 && g <= 57)
                return g - 48;
            if (g >= 65 && g <= 70)
                return g - 55;
            if (g >= 97 && g <= 102)
                return g - 87;
            n(!1, "Invalid character in " + T)
        }
        function a(T, f, g) {
            var x = s(T, g);
            return g - 1 >= f && (x |= s(T, g - 1) << 4),
            x
        }
        i.prototype._parseHex = function(f, g, x) {
            this.length = Math.ceil((f.length - g) / 6),
            this.words = new Array(this.length);
            for (var I = 0; I < this.length; I++)
                this.words[I] = 0;
            var A = 0, C = 0, k;
            if (x === "be")
                for (I = f.length - 1; I >= g; I -= 2)
                    k = a(f, g, I) << A,
                    this.words[C] |= k & 67108863,
                    A >= 18 ? (A -= 18,
                    C += 1,
                    this.words[C] |= k >>> 26) : A += 8;
            else {
                var b = f.length - g;
                for (I = b % 2 === 0 ? g + 1 : g; I < f.length; I += 2)
                    k = a(f, g, I) << A,
                    this.words[C] |= k & 67108863,
                    A >= 18 ? (A -= 18,
                    C += 1,
                    this.words[C] |= k >>> 26) : A += 8
            }
            this._strip()
        }
        ;
        function c(T, f, g, x) {
            for (var I = 0, A = 0, C = Math.min(T.length, g), k = f; k < C; k++) {
                var b = T.charCodeAt(k) - 48;
                I *= x,
                b >= 49 ? A = b - 49 + 10 : b >= 17 ? A = b - 17 + 10 : A = b,
                n(b >= 0 && A < x, "Invalid character"),
                I += A
            }
            return I
        }
        i.prototype._parseBase = function(f, g, x) {
            this.words = [0],
            this.length = 1;
            for (var I = 0, A = 1; A <= 67108863; A *= g)
                I++;
            I--,
            A = A / g | 0;
            for (var C = f.length - x, k = C % I, b = Math.min(C, C - k) + x, h = 0, B = x; B < b; B += I)
                h = c(f, B, B + I, g),
                this.imuln(A),
                this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
            if (k !== 0) {
                var Y = 1;
                for (h = c(f, B, f.length, g),
                B = 0; B < k; B++)
                    Y *= g;
                this.imuln(Y),
                this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h)
            }
            this._strip()
        }
        ,
        i.prototype.copy = function(f) {
            f.words = new Array(this.length);
            for (var g = 0; g < this.length; g++)
                f.words[g] = this.words[g];
            f.length = this.length,
            f.negative = this.negative,
            f.red = this.red
        }
        ;
        function u(T, f) {
            T.words = f.words,
            T.length = f.length,
            T.negative = f.negative,
            T.red = f.red
        }
        if (i.prototype._move = function(f) {
            u(f, this)
        }
        ,
        i.prototype.clone = function() {
            var f = new i(null);
            return this.copy(f),
            f
        }
        ,
        i.prototype._expand = function(f) {
            for (; this.length < f; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        i.prototype._strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        i.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        typeof Symbol < "u" && typeof Symbol.for == "function")
            try {
                i.prototype[Symbol.for("nodejs.util.inspect.custom")] = l
            } catch {
                i.prototype.inspect = l
            }
        else
            i.prototype.inspect = l;
        function l() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var d = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , y = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , v = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        i.prototype.toString = function(f, g) {
            f = f || 10,
            g = g | 0 || 1;
            var x;
            if (f === 16 || f === "hex") {
                x = "";
                for (var I = 0, A = 0, C = 0; C < this.length; C++) {
                    var k = this.words[C]
                      , b = ((k << I | A) & 16777215).toString(16);
                    A = k >>> 24 - I & 16777215,
                    I += 2,
                    I >= 26 && (I -= 26,
                    C--),
                    A !== 0 || C !== this.length - 1 ? x = d[6 - b.length] + b + x : x = b + x
                }
                for (A !== 0 && (x = A.toString(16) + x); x.length % g !== 0; )
                    x = "0" + x;
                return this.negative !== 0 && (x = "-" + x),
                x
            }
            if (f === (f | 0) && f >= 2 && f <= 36) {
                var h = y[f]
                  , B = v[f];
                x = "";
                var Y = this.clone();
                for (Y.negative = 0; !Y.isZero(); ) {
                    var ne = Y.modrn(B).toString(f);
                    Y = Y.idivn(B),
                    Y.isZero() ? x = ne + x : x = d[h - ne.length] + ne + x
                }
                for (this.isZero() && (x = "0" + x); x.length % g !== 0; )
                    x = "0" + x;
                return this.negative !== 0 && (x = "-" + x),
                x
            }
            n(!1, "Base should be between 2 and 36")
        }
        ,
        i.prototype.toNumber = function() {
            var f = this.words[0];
            return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -f : f
        }
        ,
        i.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        o && (i.prototype.toBuffer = function(f, g) {
            return this.toArrayLike(o, f, g)
        }
        ),
        i.prototype.toArray = function(f, g) {
            return this.toArrayLike(Array, f, g)
        }
        ;
        var E = function(f, g) {
            return f.allocUnsafe ? f.allocUnsafe(g) : new f(g)
        };
        i.prototype.toArrayLike = function(f, g, x) {
            this._strip();
            var I = this.byteLength()
              , A = x || Math.max(1, I);
            n(I <= A, "byte array longer than desired length"),
            n(A > 0, "Requested array length <= 0");
            var C = E(f, A)
              , k = g === "le" ? "LE" : "BE";
            return this["_toArrayLike" + k](C, I),
            C
        }
        ,
        i.prototype._toArrayLikeLE = function(f, g) {
            for (var x = 0, I = 0, A = 0, C = 0; A < this.length; A++) {
                var k = this.words[A] << C | I;
                f[x++] = k & 255,
                x < f.length && (f[x++] = k >> 8 & 255),
                x < f.length && (f[x++] = k >> 16 & 255),
                C === 6 ? (x < f.length && (f[x++] = k >> 24 & 255),
                I = 0,
                C = 0) : (I = k >>> 24,
                C += 2)
            }
            if (x < f.length)
                for (f[x++] = I; x < f.length; )
                    f[x++] = 0
        }
        ,
        i.prototype._toArrayLikeBE = function(f, g) {
            for (var x = f.length - 1, I = 0, A = 0, C = 0; A < this.length; A++) {
                var k = this.words[A] << C | I;
                f[x--] = k & 255,
                x >= 0 && (f[x--] = k >> 8 & 255),
                x >= 0 && (f[x--] = k >> 16 & 255),
                C === 6 ? (x >= 0 && (f[x--] = k >> 24 & 255),
                I = 0,
                C = 0) : (I = k >>> 24,
                C += 2)
            }
            if (x >= 0)
                for (f[x--] = I; x >= 0; )
                    f[x--] = 0
        }
        ,
        Math.clz32 ? i.prototype._countBits = function(f) {
            return 32 - Math.clz32(f)
        }
        : i.prototype._countBits = function(f) {
            var g = f
              , x = 0;
            return g >= 4096 && (x += 13,
            g >>>= 13),
            g >= 64 && (x += 7,
            g >>>= 7),
            g >= 8 && (x += 4,
            g >>>= 4),
            g >= 2 && (x += 2,
            g >>>= 2),
            x + g
        }
        ,
        i.prototype._zeroBits = function(f) {
            if (f === 0)
                return 26;
            var g = f
              , x = 0;
            return g & 8191 || (x += 13,
            g >>>= 13),
            g & 127 || (x += 7,
            g >>>= 7),
            g & 15 || (x += 4,
            g >>>= 4),
            g & 3 || (x += 2,
            g >>>= 2),
            g & 1 || x++,
            x
        }
        ,
        i.prototype.bitLength = function() {
            var f = this.words[this.length - 1]
              , g = this._countBits(f);
            return (this.length - 1) * 26 + g
        }
        ;
        function D(T) {
            for (var f = new Array(T.bitLength()), g = 0; g < f.length; g++) {
                var x = g / 26 | 0
                  , I = g % 26;
                f[g] = T.words[x] >>> I & 1
            }
            return f
        }
        i.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var f = 0, g = 0; g < this.length; g++) {
                var x = this._zeroBits(this.words[g]);
                if (f += x,
                x !== 26)
                    break
            }
            return f
        }
        ,
        i.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        i.prototype.toTwos = function(f) {
            return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone()
        }
        ,
        i.prototype.fromTwos = function(f) {
            return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone()
        }
        ,
        i.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        i.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        i.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        i.prototype.iuor = function(f) {
            for (; this.length < f.length; )
                this.words[this.length++] = 0;
            for (var g = 0; g < f.length; g++)
                this.words[g] = this.words[g] | f.words[g];
            return this._strip()
        }
        ,
        i.prototype.ior = function(f) {
            return n((this.negative | f.negative) === 0),
            this.iuor(f)
        }
        ,
        i.prototype.or = function(f) {
            return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this)
        }
        ,
        i.prototype.uor = function(f) {
            return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this)
        }
        ,
        i.prototype.iuand = function(f) {
            var g;
            this.length > f.length ? g = f : g = this;
            for (var x = 0; x < g.length; x++)
                this.words[x] = this.words[x] & f.words[x];
            return this.length = g.length,
            this._strip()
        }
        ,
        i.prototype.iand = function(f) {
            return n((this.negative | f.negative) === 0),
            this.iuand(f)
        }
        ,
        i.prototype.and = function(f) {
            return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this)
        }
        ,
        i.prototype.uand = function(f) {
            return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this)
        }
        ,
        i.prototype.iuxor = function(f) {
            var g, x;
            this.length > f.length ? (g = this,
            x = f) : (g = f,
            x = this);
            for (var I = 0; I < x.length; I++)
                this.words[I] = g.words[I] ^ x.words[I];
            if (this !== g)
                for (; I < g.length; I++)
                    this.words[I] = g.words[I];
            return this.length = g.length,
            this._strip()
        }
        ,
        i.prototype.ixor = function(f) {
            return n((this.negative | f.negative) === 0),
            this.iuxor(f)
        }
        ,
        i.prototype.xor = function(f) {
            return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this)
        }
        ,
        i.prototype.uxor = function(f) {
            return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this)
        }
        ,
        i.prototype.inotn = function(f) {
            n(typeof f == "number" && f >= 0);
            var g = Math.ceil(f / 26) | 0
              , x = f % 26;
            this._expand(g),
            x > 0 && g--;
            for (var I = 0; I < g; I++)
                this.words[I] = ~this.words[I] & 67108863;
            return x > 0 && (this.words[I] = ~this.words[I] & 67108863 >> 26 - x),
            this._strip()
        }
        ,
        i.prototype.notn = function(f) {
            return this.clone().inotn(f)
        }
        ,
        i.prototype.setn = function(f, g) {
            n(typeof f == "number" && f >= 0);
            var x = f / 26 | 0
              , I = f % 26;
            return this._expand(x + 1),
            g ? this.words[x] = this.words[x] | 1 << I : this.words[x] = this.words[x] & ~(1 << I),
            this._strip()
        }
        ,
        i.prototype.iadd = function(f) {
            var g;
            if (this.negative !== 0 && f.negative === 0)
                return this.negative = 0,
                g = this.isub(f),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && f.negative !== 0)
                return f.negative = 0,
                g = this.isub(f),
                f.negative = 1,
                g._normSign();
            var x, I;
            this.length > f.length ? (x = this,
            I = f) : (x = f,
            I = this);
            for (var A = 0, C = 0; C < I.length; C++)
                g = (x.words[C] | 0) + (I.words[C] | 0) + A,
                this.words[C] = g & 67108863,
                A = g >>> 26;
            for (; A !== 0 && C < x.length; C++)
                g = (x.words[C] | 0) + A,
                this.words[C] = g & 67108863,
                A = g >>> 26;
            if (this.length = x.length,
            A !== 0)
                this.words[this.length] = A,
                this.length++;
            else if (x !== this)
                for (; C < x.length; C++)
                    this.words[C] = x.words[C];
            return this
        }
        ,
        i.prototype.add = function(f) {
            var g;
            return f.negative !== 0 && this.negative === 0 ? (f.negative = 0,
            g = this.sub(f),
            f.negative ^= 1,
            g) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            g = f.sub(this),
            this.negative = 1,
            g) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this)
        }
        ,
        i.prototype.isub = function(f) {
            if (f.negative !== 0) {
                f.negative = 0;
                var g = this.iadd(f);
                return f.negative = 1,
                g._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(f),
                this.negative = 1,
                this._normSign();
            var x = this.cmp(f);
            if (x === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var I, A;
            x > 0 ? (I = this,
            A = f) : (I = f,
            A = this);
            for (var C = 0, k = 0; k < A.length; k++)
                g = (I.words[k] | 0) - (A.words[k] | 0) + C,
                C = g >> 26,
                this.words[k] = g & 67108863;
            for (; C !== 0 && k < I.length; k++)
                g = (I.words[k] | 0) + C,
                C = g >> 26,
                this.words[k] = g & 67108863;
            if (C === 0 && k < I.length && I !== this)
                for (; k < I.length; k++)
                    this.words[k] = I.words[k];
            return this.length = Math.max(this.length, k),
            I !== this && (this.negative = 1),
            this._strip()
        }
        ,
        i.prototype.sub = function(f) {
            return this.clone().isub(f)
        }
        ;
        function S(T, f, g) {
            g.negative = f.negative ^ T.negative;
            var x = T.length + f.length | 0;
            g.length = x,
            x = x - 1 | 0;
            var I = T.words[0] | 0
              , A = f.words[0] | 0
              , C = I * A
              , k = C & 67108863
              , b = C / 67108864 | 0;
            g.words[0] = k;
            for (var h = 1; h < x; h++) {
                for (var B = b >>> 26, Y = b & 67108863, ne = Math.min(h, f.length - 1), K = Math.max(0, h - T.length + 1); K <= ne; K++) {
                    var se = h - K | 0;
                    I = T.words[se] | 0,
                    A = f.words[K] | 0,
                    C = I * A + Y,
                    B += C / 67108864 | 0,
                    Y = C & 67108863
                }
                g.words[h] = Y | 0,
                b = B | 0
            }
            return b !== 0 ? g.words[h] = b | 0 : g.length--,
            g._strip()
        }
        var w = function(f, g, x) {
            var I = f.words, A = g.words, C = x.words, k = 0, b, h, B, Y = I[0] | 0, ne = Y & 8191, K = Y >>> 13, se = I[1] | 0, de = se & 8191, xe = se >>> 13, Ke = I[2] | 0, ye = Ke & 8191, pe = Ke >>> 13, ot = I[3] | 0, Fe = ot & 8191, Ye = ot >>> 13, yn = I[4] | 0, st = yn & 8191, ft = yn >>> 13, on = I[5] | 0, je = on & 8191, ze = on >>> 13, jt = I[6] | 0, dt = jt & 8191, nt = jt >>> 13, $t = I[7] | 0, vt = $t & 8191, _ = $t >>> 13, p = I[8] | 0, m = p & 8191, R = p >>> 13, U = I[9] | 0, j = U & 8191, G = U >>> 13, Be = A[0] | 0, ke = Be & 8191, Ae = Be >>> 13, xt = A[1] | 0, Ee = xt & 8191, Bt = xt >>> 13, _a = A[2] | 0, Rt = _a & 8191, Ft = _a >>> 13, du = A[3] | 0, _t = du & 8191, Nt = du >>> 13, hu = A[4] | 0, St = hu & 8191, Pt = hu >>> 13, Sa = A[5] | 0, Xe = Sa & 8191, gt = Sa >>> 13, Ma = A[6] | 0, Ot = Ma & 8191, Ht = Ma >>> 13, kv = A[7] | 0, zt = kv & 8191, qt = kv >>> 13, Tv = A[8] | 0, Wt = Tv & 8191, Gt = Tv >>> 13, Bv = A[9] | 0, Kt = Bv & 8191, Yt = Bv >>> 13;
            x.negative = f.negative ^ g.negative,
            x.length = 19,
            b = Math.imul(ne, ke),
            h = Math.imul(ne, Ae),
            h = h + Math.imul(K, ke) | 0,
            B = Math.imul(K, Ae);
            var jh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (jh >>> 26) | 0,
            jh &= 67108863,
            b = Math.imul(de, ke),
            h = Math.imul(de, Ae),
            h = h + Math.imul(xe, ke) | 0,
            B = Math.imul(xe, Ae),
            b = b + Math.imul(ne, Ee) | 0,
            h = h + Math.imul(ne, Bt) | 0,
            h = h + Math.imul(K, Ee) | 0,
            B = B + Math.imul(K, Bt) | 0;
            var $h = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + ($h >>> 26) | 0,
            $h &= 67108863,
            b = Math.imul(ye, ke),
            h = Math.imul(ye, Ae),
            h = h + Math.imul(pe, ke) | 0,
            B = Math.imul(pe, Ae),
            b = b + Math.imul(de, Ee) | 0,
            h = h + Math.imul(de, Bt) | 0,
            h = h + Math.imul(xe, Ee) | 0,
            B = B + Math.imul(xe, Bt) | 0,
            b = b + Math.imul(ne, Rt) | 0,
            h = h + Math.imul(ne, Ft) | 0,
            h = h + Math.imul(K, Rt) | 0,
            B = B + Math.imul(K, Ft) | 0;
            var Hh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Hh >>> 26) | 0,
            Hh &= 67108863,
            b = Math.imul(Fe, ke),
            h = Math.imul(Fe, Ae),
            h = h + Math.imul(Ye, ke) | 0,
            B = Math.imul(Ye, Ae),
            b = b + Math.imul(ye, Ee) | 0,
            h = h + Math.imul(ye, Bt) | 0,
            h = h + Math.imul(pe, Ee) | 0,
            B = B + Math.imul(pe, Bt) | 0,
            b = b + Math.imul(de, Rt) | 0,
            h = h + Math.imul(de, Ft) | 0,
            h = h + Math.imul(xe, Rt) | 0,
            B = B + Math.imul(xe, Ft) | 0,
            b = b + Math.imul(ne, _t) | 0,
            h = h + Math.imul(ne, Nt) | 0,
            h = h + Math.imul(K, _t) | 0,
            B = B + Math.imul(K, Nt) | 0;
            var zh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (zh >>> 26) | 0,
            zh &= 67108863,
            b = Math.imul(st, ke),
            h = Math.imul(st, Ae),
            h = h + Math.imul(ft, ke) | 0,
            B = Math.imul(ft, Ae),
            b = b + Math.imul(Fe, Ee) | 0,
            h = h + Math.imul(Fe, Bt) | 0,
            h = h + Math.imul(Ye, Ee) | 0,
            B = B + Math.imul(Ye, Bt) | 0,
            b = b + Math.imul(ye, Rt) | 0,
            h = h + Math.imul(ye, Ft) | 0,
            h = h + Math.imul(pe, Rt) | 0,
            B = B + Math.imul(pe, Ft) | 0,
            b = b + Math.imul(de, _t) | 0,
            h = h + Math.imul(de, Nt) | 0,
            h = h + Math.imul(xe, _t) | 0,
            B = B + Math.imul(xe, Nt) | 0,
            b = b + Math.imul(ne, St) | 0,
            h = h + Math.imul(ne, Pt) | 0,
            h = h + Math.imul(K, St) | 0,
            B = B + Math.imul(K, Pt) | 0;
            var qh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (qh >>> 26) | 0,
            qh &= 67108863,
            b = Math.imul(je, ke),
            h = Math.imul(je, Ae),
            h = h + Math.imul(ze, ke) | 0,
            B = Math.imul(ze, Ae),
            b = b + Math.imul(st, Ee) | 0,
            h = h + Math.imul(st, Bt) | 0,
            h = h + Math.imul(ft, Ee) | 0,
            B = B + Math.imul(ft, Bt) | 0,
            b = b + Math.imul(Fe, Rt) | 0,
            h = h + Math.imul(Fe, Ft) | 0,
            h = h + Math.imul(Ye, Rt) | 0,
            B = B + Math.imul(Ye, Ft) | 0,
            b = b + Math.imul(ye, _t) | 0,
            h = h + Math.imul(ye, Nt) | 0,
            h = h + Math.imul(pe, _t) | 0,
            B = B + Math.imul(pe, Nt) | 0,
            b = b + Math.imul(de, St) | 0,
            h = h + Math.imul(de, Pt) | 0,
            h = h + Math.imul(xe, St) | 0,
            B = B + Math.imul(xe, Pt) | 0,
            b = b + Math.imul(ne, Xe) | 0,
            h = h + Math.imul(ne, gt) | 0,
            h = h + Math.imul(K, Xe) | 0,
            B = B + Math.imul(K, gt) | 0;
            var Wh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Wh >>> 26) | 0,
            Wh &= 67108863,
            b = Math.imul(dt, ke),
            h = Math.imul(dt, Ae),
            h = h + Math.imul(nt, ke) | 0,
            B = Math.imul(nt, Ae),
            b = b + Math.imul(je, Ee) | 0,
            h = h + Math.imul(je, Bt) | 0,
            h = h + Math.imul(ze, Ee) | 0,
            B = B + Math.imul(ze, Bt) | 0,
            b = b + Math.imul(st, Rt) | 0,
            h = h + Math.imul(st, Ft) | 0,
            h = h + Math.imul(ft, Rt) | 0,
            B = B + Math.imul(ft, Ft) | 0,
            b = b + Math.imul(Fe, _t) | 0,
            h = h + Math.imul(Fe, Nt) | 0,
            h = h + Math.imul(Ye, _t) | 0,
            B = B + Math.imul(Ye, Nt) | 0,
            b = b + Math.imul(ye, St) | 0,
            h = h + Math.imul(ye, Pt) | 0,
            h = h + Math.imul(pe, St) | 0,
            B = B + Math.imul(pe, Pt) | 0,
            b = b + Math.imul(de, Xe) | 0,
            h = h + Math.imul(de, gt) | 0,
            h = h + Math.imul(xe, Xe) | 0,
            B = B + Math.imul(xe, gt) | 0,
            b = b + Math.imul(ne, Ot) | 0,
            h = h + Math.imul(ne, Ht) | 0,
            h = h + Math.imul(K, Ot) | 0,
            B = B + Math.imul(K, Ht) | 0;
            var Gh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Gh >>> 26) | 0,
            Gh &= 67108863,
            b = Math.imul(vt, ke),
            h = Math.imul(vt, Ae),
            h = h + Math.imul(_, ke) | 0,
            B = Math.imul(_, Ae),
            b = b + Math.imul(dt, Ee) | 0,
            h = h + Math.imul(dt, Bt) | 0,
            h = h + Math.imul(nt, Ee) | 0,
            B = B + Math.imul(nt, Bt) | 0,
            b = b + Math.imul(je, Rt) | 0,
            h = h + Math.imul(je, Ft) | 0,
            h = h + Math.imul(ze, Rt) | 0,
            B = B + Math.imul(ze, Ft) | 0,
            b = b + Math.imul(st, _t) | 0,
            h = h + Math.imul(st, Nt) | 0,
            h = h + Math.imul(ft, _t) | 0,
            B = B + Math.imul(ft, Nt) | 0,
            b = b + Math.imul(Fe, St) | 0,
            h = h + Math.imul(Fe, Pt) | 0,
            h = h + Math.imul(Ye, St) | 0,
            B = B + Math.imul(Ye, Pt) | 0,
            b = b + Math.imul(ye, Xe) | 0,
            h = h + Math.imul(ye, gt) | 0,
            h = h + Math.imul(pe, Xe) | 0,
            B = B + Math.imul(pe, gt) | 0,
            b = b + Math.imul(de, Ot) | 0,
            h = h + Math.imul(de, Ht) | 0,
            h = h + Math.imul(xe, Ot) | 0,
            B = B + Math.imul(xe, Ht) | 0,
            b = b + Math.imul(ne, zt) | 0,
            h = h + Math.imul(ne, qt) | 0,
            h = h + Math.imul(K, zt) | 0,
            B = B + Math.imul(K, qt) | 0;
            var Kh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Kh >>> 26) | 0,
            Kh &= 67108863,
            b = Math.imul(m, ke),
            h = Math.imul(m, Ae),
            h = h + Math.imul(R, ke) | 0,
            B = Math.imul(R, Ae),
            b = b + Math.imul(vt, Ee) | 0,
            h = h + Math.imul(vt, Bt) | 0,
            h = h + Math.imul(_, Ee) | 0,
            B = B + Math.imul(_, Bt) | 0,
            b = b + Math.imul(dt, Rt) | 0,
            h = h + Math.imul(dt, Ft) | 0,
            h = h + Math.imul(nt, Rt) | 0,
            B = B + Math.imul(nt, Ft) | 0,
            b = b + Math.imul(je, _t) | 0,
            h = h + Math.imul(je, Nt) | 0,
            h = h + Math.imul(ze, _t) | 0,
            B = B + Math.imul(ze, Nt) | 0,
            b = b + Math.imul(st, St) | 0,
            h = h + Math.imul(st, Pt) | 0,
            h = h + Math.imul(ft, St) | 0,
            B = B + Math.imul(ft, Pt) | 0,
            b = b + Math.imul(Fe, Xe) | 0,
            h = h + Math.imul(Fe, gt) | 0,
            h = h + Math.imul(Ye, Xe) | 0,
            B = B + Math.imul(Ye, gt) | 0,
            b = b + Math.imul(ye, Ot) | 0,
            h = h + Math.imul(ye, Ht) | 0,
            h = h + Math.imul(pe, Ot) | 0,
            B = B + Math.imul(pe, Ht) | 0,
            b = b + Math.imul(de, zt) | 0,
            h = h + Math.imul(de, qt) | 0,
            h = h + Math.imul(xe, zt) | 0,
            B = B + Math.imul(xe, qt) | 0,
            b = b + Math.imul(ne, Wt) | 0,
            h = h + Math.imul(ne, Gt) | 0,
            h = h + Math.imul(K, Wt) | 0,
            B = B + Math.imul(K, Gt) | 0;
            var Yh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Yh >>> 26) | 0,
            Yh &= 67108863,
            b = Math.imul(j, ke),
            h = Math.imul(j, Ae),
            h = h + Math.imul(G, ke) | 0,
            B = Math.imul(G, Ae),
            b = b + Math.imul(m, Ee) | 0,
            h = h + Math.imul(m, Bt) | 0,
            h = h + Math.imul(R, Ee) | 0,
            B = B + Math.imul(R, Bt) | 0,
            b = b + Math.imul(vt, Rt) | 0,
            h = h + Math.imul(vt, Ft) | 0,
            h = h + Math.imul(_, Rt) | 0,
            B = B + Math.imul(_, Ft) | 0,
            b = b + Math.imul(dt, _t) | 0,
            h = h + Math.imul(dt, Nt) | 0,
            h = h + Math.imul(nt, _t) | 0,
            B = B + Math.imul(nt, Nt) | 0,
            b = b + Math.imul(je, St) | 0,
            h = h + Math.imul(je, Pt) | 0,
            h = h + Math.imul(ze, St) | 0,
            B = B + Math.imul(ze, Pt) | 0,
            b = b + Math.imul(st, Xe) | 0,
            h = h + Math.imul(st, gt) | 0,
            h = h + Math.imul(ft, Xe) | 0,
            B = B + Math.imul(ft, gt) | 0,
            b = b + Math.imul(Fe, Ot) | 0,
            h = h + Math.imul(Fe, Ht) | 0,
            h = h + Math.imul(Ye, Ot) | 0,
            B = B + Math.imul(Ye, Ht) | 0,
            b = b + Math.imul(ye, zt) | 0,
            h = h + Math.imul(ye, qt) | 0,
            h = h + Math.imul(pe, zt) | 0,
            B = B + Math.imul(pe, qt) | 0,
            b = b + Math.imul(de, Wt) | 0,
            h = h + Math.imul(de, Gt) | 0,
            h = h + Math.imul(xe, Wt) | 0,
            B = B + Math.imul(xe, Gt) | 0,
            b = b + Math.imul(ne, Kt) | 0,
            h = h + Math.imul(ne, Yt) | 0,
            h = h + Math.imul(K, Kt) | 0,
            B = B + Math.imul(K, Yt) | 0;
            var Zh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Zh >>> 26) | 0,
            Zh &= 67108863,
            b = Math.imul(j, Ee),
            h = Math.imul(j, Bt),
            h = h + Math.imul(G, Ee) | 0,
            B = Math.imul(G, Bt),
            b = b + Math.imul(m, Rt) | 0,
            h = h + Math.imul(m, Ft) | 0,
            h = h + Math.imul(R, Rt) | 0,
            B = B + Math.imul(R, Ft) | 0,
            b = b + Math.imul(vt, _t) | 0,
            h = h + Math.imul(vt, Nt) | 0,
            h = h + Math.imul(_, _t) | 0,
            B = B + Math.imul(_, Nt) | 0,
            b = b + Math.imul(dt, St) | 0,
            h = h + Math.imul(dt, Pt) | 0,
            h = h + Math.imul(nt, St) | 0,
            B = B + Math.imul(nt, Pt) | 0,
            b = b + Math.imul(je, Xe) | 0,
            h = h + Math.imul(je, gt) | 0,
            h = h + Math.imul(ze, Xe) | 0,
            B = B + Math.imul(ze, gt) | 0,
            b = b + Math.imul(st, Ot) | 0,
            h = h + Math.imul(st, Ht) | 0,
            h = h + Math.imul(ft, Ot) | 0,
            B = B + Math.imul(ft, Ht) | 0,
            b = b + Math.imul(Fe, zt) | 0,
            h = h + Math.imul(Fe, qt) | 0,
            h = h + Math.imul(Ye, zt) | 0,
            B = B + Math.imul(Ye, qt) | 0,
            b = b + Math.imul(ye, Wt) | 0,
            h = h + Math.imul(ye, Gt) | 0,
            h = h + Math.imul(pe, Wt) | 0,
            B = B + Math.imul(pe, Gt) | 0,
            b = b + Math.imul(de, Kt) | 0,
            h = h + Math.imul(de, Yt) | 0,
            h = h + Math.imul(xe, Kt) | 0,
            B = B + Math.imul(xe, Yt) | 0;
            var Xh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Xh >>> 26) | 0,
            Xh &= 67108863,
            b = Math.imul(j, Rt),
            h = Math.imul(j, Ft),
            h = h + Math.imul(G, Rt) | 0,
            B = Math.imul(G, Ft),
            b = b + Math.imul(m, _t) | 0,
            h = h + Math.imul(m, Nt) | 0,
            h = h + Math.imul(R, _t) | 0,
            B = B + Math.imul(R, Nt) | 0,
            b = b + Math.imul(vt, St) | 0,
            h = h + Math.imul(vt, Pt) | 0,
            h = h + Math.imul(_, St) | 0,
            B = B + Math.imul(_, Pt) | 0,
            b = b + Math.imul(dt, Xe) | 0,
            h = h + Math.imul(dt, gt) | 0,
            h = h + Math.imul(nt, Xe) | 0,
            B = B + Math.imul(nt, gt) | 0,
            b = b + Math.imul(je, Ot) | 0,
            h = h + Math.imul(je, Ht) | 0,
            h = h + Math.imul(ze, Ot) | 0,
            B = B + Math.imul(ze, Ht) | 0,
            b = b + Math.imul(st, zt) | 0,
            h = h + Math.imul(st, qt) | 0,
            h = h + Math.imul(ft, zt) | 0,
            B = B + Math.imul(ft, qt) | 0,
            b = b + Math.imul(Fe, Wt) | 0,
            h = h + Math.imul(Fe, Gt) | 0,
            h = h + Math.imul(Ye, Wt) | 0,
            B = B + Math.imul(Ye, Gt) | 0,
            b = b + Math.imul(ye, Kt) | 0,
            h = h + Math.imul(ye, Yt) | 0,
            h = h + Math.imul(pe, Kt) | 0,
            B = B + Math.imul(pe, Yt) | 0;
            var Qh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Qh >>> 26) | 0,
            Qh &= 67108863,
            b = Math.imul(j, _t),
            h = Math.imul(j, Nt),
            h = h + Math.imul(G, _t) | 0,
            B = Math.imul(G, Nt),
            b = b + Math.imul(m, St) | 0,
            h = h + Math.imul(m, Pt) | 0,
            h = h + Math.imul(R, St) | 0,
            B = B + Math.imul(R, Pt) | 0,
            b = b + Math.imul(vt, Xe) | 0,
            h = h + Math.imul(vt, gt) | 0,
            h = h + Math.imul(_, Xe) | 0,
            B = B + Math.imul(_, gt) | 0,
            b = b + Math.imul(dt, Ot) | 0,
            h = h + Math.imul(dt, Ht) | 0,
            h = h + Math.imul(nt, Ot) | 0,
            B = B + Math.imul(nt, Ht) | 0,
            b = b + Math.imul(je, zt) | 0,
            h = h + Math.imul(je, qt) | 0,
            h = h + Math.imul(ze, zt) | 0,
            B = B + Math.imul(ze, qt) | 0,
            b = b + Math.imul(st, Wt) | 0,
            h = h + Math.imul(st, Gt) | 0,
            h = h + Math.imul(ft, Wt) | 0,
            B = B + Math.imul(ft, Gt) | 0,
            b = b + Math.imul(Fe, Kt) | 0,
            h = h + Math.imul(Fe, Yt) | 0,
            h = h + Math.imul(Ye, Kt) | 0,
            B = B + Math.imul(Ye, Yt) | 0;
            var Jh = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (Jh >>> 26) | 0,
            Jh &= 67108863,
            b = Math.imul(j, St),
            h = Math.imul(j, Pt),
            h = h + Math.imul(G, St) | 0,
            B = Math.imul(G, Pt),
            b = b + Math.imul(m, Xe) | 0,
            h = h + Math.imul(m, gt) | 0,
            h = h + Math.imul(R, Xe) | 0,
            B = B + Math.imul(R, gt) | 0,
            b = b + Math.imul(vt, Ot) | 0,
            h = h + Math.imul(vt, Ht) | 0,
            h = h + Math.imul(_, Ot) | 0,
            B = B + Math.imul(_, Ht) | 0,
            b = b + Math.imul(dt, zt) | 0,
            h = h + Math.imul(dt, qt) | 0,
            h = h + Math.imul(nt, zt) | 0,
            B = B + Math.imul(nt, qt) | 0,
            b = b + Math.imul(je, Wt) | 0,
            h = h + Math.imul(je, Gt) | 0,
            h = h + Math.imul(ze, Wt) | 0,
            B = B + Math.imul(ze, Gt) | 0,
            b = b + Math.imul(st, Kt) | 0,
            h = h + Math.imul(st, Yt) | 0,
            h = h + Math.imul(ft, Kt) | 0,
            B = B + Math.imul(ft, Yt) | 0;
            var e0 = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (e0 >>> 26) | 0,
            e0 &= 67108863,
            b = Math.imul(j, Xe),
            h = Math.imul(j, gt),
            h = h + Math.imul(G, Xe) | 0,
            B = Math.imul(G, gt),
            b = b + Math.imul(m, Ot) | 0,
            h = h + Math.imul(m, Ht) | 0,
            h = h + Math.imul(R, Ot) | 0,
            B = B + Math.imul(R, Ht) | 0,
            b = b + Math.imul(vt, zt) | 0,
            h = h + Math.imul(vt, qt) | 0,
            h = h + Math.imul(_, zt) | 0,
            B = B + Math.imul(_, qt) | 0,
            b = b + Math.imul(dt, Wt) | 0,
            h = h + Math.imul(dt, Gt) | 0,
            h = h + Math.imul(nt, Wt) | 0,
            B = B + Math.imul(nt, Gt) | 0,
            b = b + Math.imul(je, Kt) | 0,
            h = h + Math.imul(je, Yt) | 0,
            h = h + Math.imul(ze, Kt) | 0,
            B = B + Math.imul(ze, Yt) | 0;
            var t0 = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (t0 >>> 26) | 0,
            t0 &= 67108863,
            b = Math.imul(j, Ot),
            h = Math.imul(j, Ht),
            h = h + Math.imul(G, Ot) | 0,
            B = Math.imul(G, Ht),
            b = b + Math.imul(m, zt) | 0,
            h = h + Math.imul(m, qt) | 0,
            h = h + Math.imul(R, zt) | 0,
            B = B + Math.imul(R, qt) | 0,
            b = b + Math.imul(vt, Wt) | 0,
            h = h + Math.imul(vt, Gt) | 0,
            h = h + Math.imul(_, Wt) | 0,
            B = B + Math.imul(_, Gt) | 0,
            b = b + Math.imul(dt, Kt) | 0,
            h = h + Math.imul(dt, Yt) | 0,
            h = h + Math.imul(nt, Kt) | 0,
            B = B + Math.imul(nt, Yt) | 0;
            var n0 = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (n0 >>> 26) | 0,
            n0 &= 67108863,
            b = Math.imul(j, zt),
            h = Math.imul(j, qt),
            h = h + Math.imul(G, zt) | 0,
            B = Math.imul(G, qt),
            b = b + Math.imul(m, Wt) | 0,
            h = h + Math.imul(m, Gt) | 0,
            h = h + Math.imul(R, Wt) | 0,
            B = B + Math.imul(R, Gt) | 0,
            b = b + Math.imul(vt, Kt) | 0,
            h = h + Math.imul(vt, Yt) | 0,
            h = h + Math.imul(_, Kt) | 0,
            B = B + Math.imul(_, Yt) | 0;
            var r0 = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (r0 >>> 26) | 0,
            r0 &= 67108863,
            b = Math.imul(j, Wt),
            h = Math.imul(j, Gt),
            h = h + Math.imul(G, Wt) | 0,
            B = Math.imul(G, Gt),
            b = b + Math.imul(m, Kt) | 0,
            h = h + Math.imul(m, Yt) | 0,
            h = h + Math.imul(R, Kt) | 0,
            B = B + Math.imul(R, Yt) | 0;
            var i0 = (k + b | 0) + ((h & 8191) << 13) | 0;
            k = (B + (h >>> 13) | 0) + (i0 >>> 26) | 0,
            i0 &= 67108863,
            b = Math.imul(j, Kt),
            h = Math.imul(j, Yt),
            h = h + Math.imul(G, Kt) | 0,
            B = Math.imul(G, Yt);
            var o0 = (k + b | 0) + ((h & 8191) << 13) | 0;
            return k = (B + (h >>> 13) | 0) + (o0 >>> 26) | 0,
            o0 &= 67108863,
            C[0] = jh,
            C[1] = $h,
            C[2] = Hh,
            C[3] = zh,
            C[4] = qh,
            C[5] = Wh,
            C[6] = Gh,
            C[7] = Kh,
            C[8] = Yh,
            C[9] = Zh,
            C[10] = Xh,
            C[11] = Qh,
            C[12] = Jh,
            C[13] = e0,
            C[14] = t0,
            C[15] = n0,
            C[16] = r0,
            C[17] = i0,
            C[18] = o0,
            k !== 0 && (C[19] = k,
            x.length++),
            x
        };
        Math.imul || (w = S);
        function M(T, f, g) {
            g.negative = f.negative ^ T.negative,
            g.length = T.length + f.length;
            for (var x = 0, I = 0, A = 0; A < g.length - 1; A++) {
                var C = I;
                I = 0;
                for (var k = x & 67108863, b = Math.min(A, f.length - 1), h = Math.max(0, A - T.length + 1); h <= b; h++) {
                    var B = A - h
                      , Y = T.words[B] | 0
                      , ne = f.words[h] | 0
                      , K = Y * ne
                      , se = K & 67108863;
                    C = C + (K / 67108864 | 0) | 0,
                    se = se + k | 0,
                    k = se & 67108863,
                    C = C + (se >>> 26) | 0,
                    I += C >>> 26,
                    C &= 67108863
                }
                g.words[A] = k,
                x = C,
                C = I
            }
            return x !== 0 ? g.words[A] = x : g.length--,
            g._strip()
        }
        function F(T, f, g) {
            return M(T, f, g)
        }
        i.prototype.mulTo = function(f, g) {
            var x, I = this.length + f.length;
            return this.length === 10 && f.length === 10 ? x = w(this, f, g) : I < 63 ? x = S(this, f, g) : I < 1024 ? x = M(this, f, g) : x = F(this, f, g),
            x
        }
        ;
        function N(T, f) {
            this.x = T,
            this.y = f
        }
        N.prototype.makeRBT = function(f) {
            for (var g = new Array(f), x = i.prototype._countBits(f) - 1, I = 0; I < f; I++)
                g[I] = this.revBin(I, x, f);
            return g
        }
        ,
        N.prototype.revBin = function(f, g, x) {
            if (f === 0 || f === x - 1)
                return f;
            for (var I = 0, A = 0; A < g; A++)
                I |= (f & 1) << g - A - 1,
                f >>= 1;
            return I
        }
        ,
        N.prototype.permute = function(f, g, x, I, A, C) {
            for (var k = 0; k < C; k++)
                I[k] = g[f[k]],
                A[k] = x[f[k]]
        }
        ,
        N.prototype.transform = function(f, g, x, I, A, C) {
            this.permute(C, f, g, x, I, A);
            for (var k = 1; k < A; k <<= 1)
                for (var b = k << 1, h = Math.cos(2 * Math.PI / b), B = Math.sin(2 * Math.PI / b), Y = 0; Y < A; Y += b)
                    for (var ne = h, K = B, se = 0; se < k; se++) {
                        var de = x[Y + se]
                          , xe = I[Y + se]
                          , Ke = x[Y + se + k]
                          , ye = I[Y + se + k]
                          , pe = ne * Ke - K * ye;
                        ye = ne * ye + K * Ke,
                        Ke = pe,
                        x[Y + se] = de + Ke,
                        I[Y + se] = xe + ye,
                        x[Y + se + k] = de - Ke,
                        I[Y + se + k] = xe - ye,
                        se !== b && (pe = h * ne - B * K,
                        K = h * K + B * ne,
                        ne = pe)
                    }
        }
        ,
        N.prototype.guessLen13b = function(f, g) {
            var x = Math.max(g, f) | 1
              , I = x & 1
              , A = 0;
            for (x = x / 2 | 0; x; x = x >>> 1)
                A++;
            return 1 << A + 1 + I
        }
        ,
        N.prototype.conjugate = function(f, g, x) {
            if (!(x <= 1))
                for (var I = 0; I < x / 2; I++) {
                    var A = f[I];
                    f[I] = f[x - I - 1],
                    f[x - I - 1] = A,
                    A = g[I],
                    g[I] = -g[x - I - 1],
                    g[x - I - 1] = -A
                }
        }
        ,
        N.prototype.normalize13b = function(f, g) {
            for (var x = 0, I = 0; I < g / 2; I++) {
                var A = Math.round(f[2 * I + 1] / g) * 8192 + Math.round(f[2 * I] / g) + x;
                f[I] = A & 67108863,
                A < 67108864 ? x = 0 : x = A / 67108864 | 0
            }
            return f
        }
        ,
        N.prototype.convert13b = function(f, g, x, I) {
            for (var A = 0, C = 0; C < g; C++)
                A = A + (f[C] | 0),
                x[2 * C] = A & 8191,
                A = A >>> 13,
                x[2 * C + 1] = A & 8191,
                A = A >>> 13;
            for (C = 2 * g; C < I; ++C)
                x[C] = 0;
            n(A === 0),
            n((A & -8192) === 0)
        }
        ,
        N.prototype.stub = function(f) {
            for (var g = new Array(f), x = 0; x < f; x++)
                g[x] = 0;
            return g
        }
        ,
        N.prototype.mulp = function(f, g, x) {
            var I = 2 * this.guessLen13b(f.length, g.length)
              , A = this.makeRBT(I)
              , C = this.stub(I)
              , k = new Array(I)
              , b = new Array(I)
              , h = new Array(I)
              , B = new Array(I)
              , Y = new Array(I)
              , ne = new Array(I)
              , K = x.words;
            K.length = I,
            this.convert13b(f.words, f.length, k, I),
            this.convert13b(g.words, g.length, B, I),
            this.transform(k, C, b, h, I, A),
            this.transform(B, C, Y, ne, I, A);
            for (var se = 0; se < I; se++) {
                var de = b[se] * Y[se] - h[se] * ne[se];
                h[se] = b[se] * ne[se] + h[se] * Y[se],
                b[se] = de
            }
            return this.conjugate(b, h, I),
            this.transform(b, h, K, C, I, A),
            this.conjugate(K, C, I),
            this.normalize13b(K, I),
            x.negative = f.negative ^ g.negative,
            x.length = f.length + g.length,
            x._strip()
        }
        ,
        i.prototype.mul = function(f) {
            var g = new i(null);
            return g.words = new Array(this.length + f.length),
            this.mulTo(f, g)
        }
        ,
        i.prototype.mulf = function(f) {
            var g = new i(null);
            return g.words = new Array(this.length + f.length),
            F(this, f, g)
        }
        ,
        i.prototype.imul = function(f) {
            return this.clone().mulTo(f, this)
        }
        ,
        i.prototype.imuln = function(f) {
            var g = f < 0;
            g && (f = -f),
            n(typeof f == "number"),
            n(f < 67108864);
            for (var x = 0, I = 0; I < this.length; I++) {
                var A = (this.words[I] | 0) * f
                  , C = (A & 67108863) + (x & 67108863);
                x >>= 26,
                x += A / 67108864 | 0,
                x += C >>> 26,
                this.words[I] = C & 67108863
            }
            return x !== 0 && (this.words[I] = x,
            this.length++),
            g ? this.ineg() : this
        }
        ,
        i.prototype.muln = function(f) {
            return this.clone().imuln(f)
        }
        ,
        i.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        i.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        i.prototype.pow = function(f) {
            var g = D(f);
            if (g.length === 0)
                return new i(1);
            for (var x = this, I = 0; I < g.length && g[I] === 0; I++,
            x = x.sqr())
                ;
            if (++I < g.length)
                for (var A = x.sqr(); I < g.length; I++,
                A = A.sqr())
                    g[I] !== 0 && (x = x.mul(A));
            return x
        }
        ,
        i.prototype.iushln = function(f) {
            n(typeof f == "number" && f >= 0);
            var g = f % 26, x = (f - g) / 26, I = 67108863 >>> 26 - g << 26 - g, A;
            if (g !== 0) {
                var C = 0;
                for (A = 0; A < this.length; A++) {
                    var k = this.words[A] & I
                      , b = (this.words[A] | 0) - k << g;
                    this.words[A] = b | C,
                    C = k >>> 26 - g
                }
                C && (this.words[A] = C,
                this.length++)
            }
            if (x !== 0) {
                for (A = this.length - 1; A >= 0; A--)
                    this.words[A + x] = this.words[A];
                for (A = 0; A < x; A++)
                    this.words[A] = 0;
                this.length += x
            }
            return this._strip()
        }
        ,
        i.prototype.ishln = function(f) {
            return n(this.negative === 0),
            this.iushln(f)
        }
        ,
        i.prototype.iushrn = function(f, g, x) {
            n(typeof f == "number" && f >= 0);
            var I;
            g ? I = (g - g % 26) / 26 : I = 0;
            var A = f % 26
              , C = Math.min((f - A) / 26, this.length)
              , k = 67108863 ^ 67108863 >>> A << A
              , b = x;
            if (I -= C,
            I = Math.max(0, I),
            b) {
                for (var h = 0; h < C; h++)
                    b.words[h] = this.words[h];
                b.length = C
            }
            if (C !== 0)
                if (this.length > C)
                    for (this.length -= C,
                    h = 0; h < this.length; h++)
                        this.words[h] = this.words[h + C];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var B = 0;
            for (h = this.length - 1; h >= 0 && (B !== 0 || h >= I); h--) {
                var Y = this.words[h] | 0;
                this.words[h] = B << 26 - A | Y >>> A,
                B = Y & k
            }
            return b && B !== 0 && (b.words[b.length++] = B),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        i.prototype.ishrn = function(f, g, x) {
            return n(this.negative === 0),
            this.iushrn(f, g, x)
        }
        ,
        i.prototype.shln = function(f) {
            return this.clone().ishln(f)
        }
        ,
        i.prototype.ushln = function(f) {
            return this.clone().iushln(f)
        }
        ,
        i.prototype.shrn = function(f) {
            return this.clone().ishrn(f)
        }
        ,
        i.prototype.ushrn = function(f) {
            return this.clone().iushrn(f)
        }
        ,
        i.prototype.testn = function(f) {
            n(typeof f == "number" && f >= 0);
            var g = f % 26
              , x = (f - g) / 26
              , I = 1 << g;
            if (this.length <= x)
                return !1;
            var A = this.words[x];
            return !!(A & I)
        }
        ,
        i.prototype.imaskn = function(f) {
            n(typeof f == "number" && f >= 0);
            var g = f % 26
              , x = (f - g) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= x)
                return this;
            if (g !== 0 && x++,
            this.length = Math.min(x, this.length),
            g !== 0) {
                var I = 67108863 ^ 67108863 >>> g << g;
                this.words[this.length - 1] &= I
            }
            return this._strip()
        }
        ,
        i.prototype.maskn = function(f) {
            return this.clone().imaskn(f)
        }
        ,
        i.prototype.iaddn = function(f) {
            return n(typeof f == "number"),
            n(f < 67108864),
            f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(f),
            this.negative = 1,
            this) : this._iaddn(f)
        }
        ,
        i.prototype._iaddn = function(f) {
            this.words[0] += f;
            for (var g = 0; g < this.length && this.words[g] >= 67108864; g++)
                this.words[g] -= 67108864,
                g === this.length - 1 ? this.words[g + 1] = 1 : this.words[g + 1]++;
            return this.length = Math.max(this.length, g + 1),
            this
        }
        ,
        i.prototype.isubn = function(f) {
            if (n(typeof f == "number"),
            n(f < 67108864),
            f < 0)
                return this.iaddn(-f);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(f),
                this.negative = 1,
                this;
            if (this.words[0] -= f,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var g = 0; g < this.length && this.words[g] < 0; g++)
                    this.words[g] += 67108864,
                    this.words[g + 1] -= 1;
            return this._strip()
        }
        ,
        i.prototype.addn = function(f) {
            return this.clone().iaddn(f)
        }
        ,
        i.prototype.subn = function(f) {
            return this.clone().isubn(f)
        }
        ,
        i.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        i.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        i.prototype._ishlnsubmul = function(f, g, x) {
            var I = f.length + x, A;
            this._expand(I);
            var C, k = 0;
            for (A = 0; A < f.length; A++) {
                C = (this.words[A + x] | 0) + k;
                var b = (f.words[A] | 0) * g;
                C -= b & 67108863,
                k = (C >> 26) - (b / 67108864 | 0),
                this.words[A + x] = C & 67108863
            }
            for (; A < this.length - x; A++)
                C = (this.words[A + x] | 0) + k,
                k = C >> 26,
                this.words[A + x] = C & 67108863;
            if (k === 0)
                return this._strip();
            for (n(k === -1),
            k = 0,
            A = 0; A < this.length; A++)
                C = -(this.words[A] | 0) + k,
                k = C >> 26,
                this.words[A] = C & 67108863;
            return this.negative = 1,
            this._strip()
        }
        ,
        i.prototype._wordDiv = function(f, g) {
            var x = this.length - f.length
              , I = this.clone()
              , A = f
              , C = A.words[A.length - 1] | 0
              , k = this._countBits(C);
            x = 26 - k,
            x !== 0 && (A = A.ushln(x),
            I.iushln(x),
            C = A.words[A.length - 1] | 0);
            var b = I.length - A.length, h;
            if (g !== "mod") {
                h = new i(null),
                h.length = b + 1,
                h.words = new Array(h.length);
                for (var B = 0; B < h.length; B++)
                    h.words[B] = 0
            }
            var Y = I.clone()._ishlnsubmul(A, 1, b);
            Y.negative === 0 && (I = Y,
            h && (h.words[b] = 1));
            for (var ne = b - 1; ne >= 0; ne--) {
                var K = (I.words[A.length + ne] | 0) * 67108864 + (I.words[A.length + ne - 1] | 0);
                for (K = Math.min(K / C | 0, 67108863),
                I._ishlnsubmul(A, K, ne); I.negative !== 0; )
                    K--,
                    I.negative = 0,
                    I._ishlnsubmul(A, 1, ne),
                    I.isZero() || (I.negative ^= 1);
                h && (h.words[ne] = K)
            }
            return h && h._strip(),
            I._strip(),
            g !== "div" && x !== 0 && I.iushrn(x),
            {
                div: h || null,
                mod: I
            }
        }
        ,
        i.prototype.divmod = function(f, g, x) {
            if (n(!f.isZero()),
            this.isZero())
                return {
                    div: new i(0),
                    mod: new i(0)
                };
            var I, A, C;
            return this.negative !== 0 && f.negative === 0 ? (C = this.neg().divmod(f, g),
            g !== "mod" && (I = C.div.neg()),
            g !== "div" && (A = C.mod.neg(),
            x && A.negative !== 0 && A.iadd(f)),
            {
                div: I,
                mod: A
            }) : this.negative === 0 && f.negative !== 0 ? (C = this.divmod(f.neg(), g),
            g !== "mod" && (I = C.div.neg()),
            {
                div: I,
                mod: C.mod
            }) : this.negative & f.negative ? (C = this.neg().divmod(f.neg(), g),
            g !== "div" && (A = C.mod.neg(),
            x && A.negative !== 0 && A.isub(f)),
            {
                div: C.div,
                mod: A
            }) : f.length > this.length || this.cmp(f) < 0 ? {
                div: new i(0),
                mod: this
            } : f.length === 1 ? g === "div" ? {
                div: this.divn(f.words[0]),
                mod: null
            } : g === "mod" ? {
                div: null,
                mod: new i(this.modrn(f.words[0]))
            } : {
                div: this.divn(f.words[0]),
                mod: new i(this.modrn(f.words[0]))
            } : this._wordDiv(f, g)
        }
        ,
        i.prototype.div = function(f) {
            return this.divmod(f, "div", !1).div
        }
        ,
        i.prototype.mod = function(f) {
            return this.divmod(f, "mod", !1).mod
        }
        ,
        i.prototype.umod = function(f) {
            return this.divmod(f, "mod", !0).mod
        }
        ,
        i.prototype.divRound = function(f) {
            var g = this.divmod(f);
            if (g.mod.isZero())
                return g.div;
            var x = g.div.negative !== 0 ? g.mod.isub(f) : g.mod
              , I = f.ushrn(1)
              , A = f.andln(1)
              , C = x.cmp(I);
            return C < 0 || A === 1 && C === 0 ? g.div : g.div.negative !== 0 ? g.div.isubn(1) : g.div.iaddn(1)
        }
        ,
        i.prototype.modrn = function(f) {
            var g = f < 0;
            g && (f = -f),
            n(f <= 67108863);
            for (var x = (1 << 26) % f, I = 0, A = this.length - 1; A >= 0; A--)
                I = (x * I + (this.words[A] | 0)) % f;
            return g ? -I : I
        }
        ,
        i.prototype.modn = function(f) {
            return this.modrn(f)
        }
        ,
        i.prototype.idivn = function(f) {
            var g = f < 0;
            g && (f = -f),
            n(f <= 67108863);
            for (var x = 0, I = this.length - 1; I >= 0; I--) {
                var A = (this.words[I] | 0) + x * 67108864;
                this.words[I] = A / f | 0,
                x = A % f
            }
            return this._strip(),
            g ? this.ineg() : this
        }
        ,
        i.prototype.divn = function(f) {
            return this.clone().idivn(f)
        }
        ,
        i.prototype.egcd = function(f) {
            n(f.negative === 0),
            n(!f.isZero());
            var g = this
              , x = f.clone();
            g.negative !== 0 ? g = g.umod(f) : g = g.clone();
            for (var I = new i(1), A = new i(0), C = new i(0), k = new i(1), b = 0; g.isEven() && x.isEven(); )
                g.iushrn(1),
                x.iushrn(1),
                ++b;
            for (var h = x.clone(), B = g.clone(); !g.isZero(); ) {
                for (var Y = 0, ne = 1; !(g.words[0] & ne) && Y < 26; ++Y,
                ne <<= 1)
                    ;
                if (Y > 0)
                    for (g.iushrn(Y); Y-- > 0; )
                        (I.isOdd() || A.isOdd()) && (I.iadd(h),
                        A.isub(B)),
                        I.iushrn(1),
                        A.iushrn(1);
                for (var K = 0, se = 1; !(x.words[0] & se) && K < 26; ++K,
                se <<= 1)
                    ;
                if (K > 0)
                    for (x.iushrn(K); K-- > 0; )
                        (C.isOdd() || k.isOdd()) && (C.iadd(h),
                        k.isub(B)),
                        C.iushrn(1),
                        k.iushrn(1);
                g.cmp(x) >= 0 ? (g.isub(x),
                I.isub(C),
                A.isub(k)) : (x.isub(g),
                C.isub(I),
                k.isub(A))
            }
            return {
                a: C,
                b: k,
                gcd: x.iushln(b)
            }
        }
        ,
        i.prototype._invmp = function(f) {
            n(f.negative === 0),
            n(!f.isZero());
            var g = this
              , x = f.clone();
            g.negative !== 0 ? g = g.umod(f) : g = g.clone();
            for (var I = new i(1), A = new i(0), C = x.clone(); g.cmpn(1) > 0 && x.cmpn(1) > 0; ) {
                for (var k = 0, b = 1; !(g.words[0] & b) && k < 26; ++k,
                b <<= 1)
                    ;
                if (k > 0)
                    for (g.iushrn(k); k-- > 0; )
                        I.isOdd() && I.iadd(C),
                        I.iushrn(1);
                for (var h = 0, B = 1; !(x.words[0] & B) && h < 26; ++h,
                B <<= 1)
                    ;
                if (h > 0)
                    for (x.iushrn(h); h-- > 0; )
                        A.isOdd() && A.iadd(C),
                        A.iushrn(1);
                g.cmp(x) >= 0 ? (g.isub(x),
                I.isub(A)) : (x.isub(g),
                A.isub(I))
            }
            var Y;
            return g.cmpn(1) === 0 ? Y = I : Y = A,
            Y.cmpn(0) < 0 && Y.iadd(f),
            Y
        }
        ,
        i.prototype.gcd = function(f) {
            if (this.isZero())
                return f.abs();
            if (f.isZero())
                return this.abs();
            var g = this.clone()
              , x = f.clone();
            g.negative = 0,
            x.negative = 0;
            for (var I = 0; g.isEven() && x.isEven(); I++)
                g.iushrn(1),
                x.iushrn(1);
            do {
                for (; g.isEven(); )
                    g.iushrn(1);
                for (; x.isEven(); )
                    x.iushrn(1);
                var A = g.cmp(x);
                if (A < 0) {
                    var C = g;
                    g = x,
                    x = C
                } else if (A === 0 || x.cmpn(1) === 0)
                    break;
                g.isub(x)
            } while (!0);
            return x.iushln(I)
        }
        ,
        i.prototype.invm = function(f) {
            return this.egcd(f).a.umod(f)
        }
        ,
        i.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        i.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        i.prototype.andln = function(f) {
            return this.words[0] & f
        }
        ,
        i.prototype.bincn = function(f) {
            n(typeof f == "number");
            var g = f % 26
              , x = (f - g) / 26
              , I = 1 << g;
            if (this.length <= x)
                return this._expand(x + 1),
                this.words[x] |= I,
                this;
            for (var A = I, C = x; A !== 0 && C < this.length; C++) {
                var k = this.words[C] | 0;
                k += A,
                A = k >>> 26,
                k &= 67108863,
                this.words[C] = k
            }
            return A !== 0 && (this.words[C] = A,
            this.length++),
            this
        }
        ,
        i.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        i.prototype.cmpn = function(f) {
            var g = f < 0;
            if (this.negative !== 0 && !g)
                return -1;
            if (this.negative === 0 && g)
                return 1;
            this._strip();
            var x;
            if (this.length > 1)
                x = 1;
            else {
                g && (f = -f),
                n(f <= 67108863, "Number is too big");
                var I = this.words[0] | 0;
                x = I === f ? 0 : I < f ? -1 : 1
            }
            return this.negative !== 0 ? -x | 0 : x
        }
        ,
        i.prototype.cmp = function(f) {
            if (this.negative !== 0 && f.negative === 0)
                return -1;
            if (this.negative === 0 && f.negative !== 0)
                return 1;
            var g = this.ucmp(f);
            return this.negative !== 0 ? -g | 0 : g
        }
        ,
        i.prototype.ucmp = function(f) {
            if (this.length > f.length)
                return 1;
            if (this.length < f.length)
                return -1;
            for (var g = 0, x = this.length - 1; x >= 0; x--) {
                var I = this.words[x] | 0
                  , A = f.words[x] | 0;
                if (I !== A) {
                    I < A ? g = -1 : I > A && (g = 1);
                    break
                }
            }
            return g
        }
        ,
        i.prototype.gtn = function(f) {
            return this.cmpn(f) === 1
        }
        ,
        i.prototype.gt = function(f) {
            return this.cmp(f) === 1
        }
        ,
        i.prototype.gten = function(f) {
            return this.cmpn(f) >= 0
        }
        ,
        i.prototype.gte = function(f) {
            return this.cmp(f) >= 0
        }
        ,
        i.prototype.ltn = function(f) {
            return this.cmpn(f) === -1
        }
        ,
        i.prototype.lt = function(f) {
            return this.cmp(f) === -1
        }
        ,
        i.prototype.lten = function(f) {
            return this.cmpn(f) <= 0
        }
        ,
        i.prototype.lte = function(f) {
            return this.cmp(f) <= 0
        }
        ,
        i.prototype.eqn = function(f) {
            return this.cmpn(f) === 0
        }
        ,
        i.prototype.eq = function(f) {
            return this.cmp(f) === 0
        }
        ,
        i.red = function(f) {
            return new V(f)
        }
        ,
        i.prototype.toRed = function(f) {
            return n(!this.red, "Already a number in reduction context"),
            n(this.negative === 0, "red works only with positives"),
            f.convertTo(this)._forceRed(f)
        }
        ,
        i.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        i.prototype._forceRed = function(f) {
            return this.red = f,
            this
        }
        ,
        i.prototype.forceRed = function(f) {
            return n(!this.red, "Already a number in reduction context"),
            this._forceRed(f)
        }
        ,
        i.prototype.redAdd = function(f) {
            return n(this.red, "redAdd works only with red numbers"),
            this.red.add(this, f)
        }
        ,
        i.prototype.redIAdd = function(f) {
            return n(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, f)
        }
        ,
        i.prototype.redSub = function(f) {
            return n(this.red, "redSub works only with red numbers"),
            this.red.sub(this, f)
        }
        ,
        i.prototype.redISub = function(f) {
            return n(this.red, "redISub works only with red numbers"),
            this.red.isub(this, f)
        }
        ,
        i.prototype.redShl = function(f) {
            return n(this.red, "redShl works only with red numbers"),
            this.red.shl(this, f)
        }
        ,
        i.prototype.redMul = function(f) {
            return n(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, f),
            this.red.mul(this, f)
        }
        ,
        i.prototype.redIMul = function(f) {
            return n(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, f),
            this.red.imul(this, f)
        }
        ,
        i.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        i.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        i.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        i.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        i.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        i.prototype.redPow = function(f) {
            return n(this.red && !f.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, f)
        }
        ;
        var P = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function O(T, f) {
            this.name = T,
            this.p = new i(f,16),
            this.n = this.p.bitLength(),
            this.k = new i(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        O.prototype._tmp = function() {
            var f = new i(null);
            return f.words = new Array(Math.ceil(this.n / 13)),
            f
        }
        ,
        O.prototype.ireduce = function(f) {
            var g = f, x;
            do
                this.split(g, this.tmp),
                g = this.imulK(g),
                g = g.iadd(this.tmp),
                x = g.bitLength();
            while (x > this.n);
            var I = x < this.n ? -1 : g.ucmp(this.p);
            return I === 0 ? (g.words[0] = 0,
            g.length = 1) : I > 0 ? g.isub(this.p) : g.strip !== void 0 ? g.strip() : g._strip(),
            g
        }
        ,
        O.prototype.split = function(f, g) {
            f.iushrn(this.n, 0, g)
        }
        ,
        O.prototype.imulK = function(f) {
            return f.imul(this.k)
        }
        ;
        function z() {
            O.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        r(z, O),
        z.prototype.split = function(f, g) {
            for (var x = 4194303, I = Math.min(f.length, 9), A = 0; A < I; A++)
                g.words[A] = f.words[A];
            if (g.length = I,
            f.length <= 9) {
                f.words[0] = 0,
                f.length = 1;
                return
            }
            var C = f.words[9];
            for (g.words[g.length++] = C & x,
            A = 10; A < f.length; A++) {
                var k = f.words[A] | 0;
                f.words[A - 10] = (k & x) << 4 | C >>> 22,
                C = k
            }
            C >>>= 22,
            f.words[A - 10] = C,
            C === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9
        }
        ,
        z.prototype.imulK = function(f) {
            f.words[f.length] = 0,
            f.words[f.length + 1] = 0,
            f.length += 2;
            for (var g = 0, x = 0; x < f.length; x++) {
                var I = f.words[x] | 0;
                g += I * 977,
                f.words[x] = g & 67108863,
                g = I * 64 + (g / 67108864 | 0)
            }
            return f.words[f.length - 1] === 0 && (f.length--,
            f.words[f.length - 1] === 0 && f.length--),
            f
        }
        ;
        function q() {
            O.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        r(q, O);
        function J() {
            O.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        r(J, O);
        function te() {
            O.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        r(te, O),
        te.prototype.imulK = function(f) {
            for (var g = 0, x = 0; x < f.length; x++) {
                var I = (f.words[x] | 0) * 19 + g
                  , A = I & 67108863;
                I >>>= 26,
                f.words[x] = A,
                g = I
            }
            return g !== 0 && (f.words[f.length++] = g),
            f
        }
        ,
        i._prime = function(f) {
            if (P[f])
                return P[f];
            var g;
            if (f === "k256")
                g = new z;
            else if (f === "p224")
                g = new q;
            else if (f === "p192")
                g = new J;
            else if (f === "p25519")
                g = new te;
            else
                throw new Error("Unknown prime " + f);
            return P[f] = g,
            g
        }
        ;
        function V(T) {
            if (typeof T == "string") {
                var f = i._prime(T);
                this.m = f.p,
                this.prime = f
            } else
                n(T.gtn(1), "modulus must be greater than 1"),
                this.m = T,
                this.prime = null
        }
        V.prototype._verify1 = function(f) {
            n(f.negative === 0, "red works only with positives"),
            n(f.red, "red works only with red numbers")
        }
        ,
        V.prototype._verify2 = function(f, g) {
            n((f.negative | g.negative) === 0, "red works only with positives"),
            n(f.red && f.red === g.red, "red works only with red numbers")
        }
        ,
        V.prototype.imod = function(f) {
            return this.prime ? this.prime.ireduce(f)._forceRed(this) : (u(f, f.umod(this.m)._forceRed(this)),
            f)
        }
        ,
        V.prototype.neg = function(f) {
            return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this)
        }
        ,
        V.prototype.add = function(f, g) {
            this._verify2(f, g);
            var x = f.add(g);
            return x.cmp(this.m) >= 0 && x.isub(this.m),
            x._forceRed(this)
        }
        ,
        V.prototype.iadd = function(f, g) {
            this._verify2(f, g);
            var x = f.iadd(g);
            return x.cmp(this.m) >= 0 && x.isub(this.m),
            x
        }
        ,
        V.prototype.sub = function(f, g) {
            this._verify2(f, g);
            var x = f.sub(g);
            return x.cmpn(0) < 0 && x.iadd(this.m),
            x._forceRed(this)
        }
        ,
        V.prototype.isub = function(f, g) {
            this._verify2(f, g);
            var x = f.isub(g);
            return x.cmpn(0) < 0 && x.iadd(this.m),
            x
        }
        ,
        V.prototype.shl = function(f, g) {
            return this._verify1(f),
            this.imod(f.ushln(g))
        }
        ,
        V.prototype.imul = function(f, g) {
            return this._verify2(f, g),
            this.imod(f.imul(g))
        }
        ,
        V.prototype.mul = function(f, g) {
            return this._verify2(f, g),
            this.imod(f.mul(g))
        }
        ,
        V.prototype.isqr = function(f) {
            return this.imul(f, f.clone())
        }
        ,
        V.prototype.sqr = function(f) {
            return this.mul(f, f)
        }
        ,
        V.prototype.sqrt = function(f) {
            if (f.isZero())
                return f.clone();
            var g = this.m.andln(3);
            if (n(g % 2 === 1),
            g === 3) {
                var x = this.m.add(new i(1)).iushrn(2);
                return this.pow(f, x)
            }
            for (var I = this.m.subn(1), A = 0; !I.isZero() && I.andln(1) === 0; )
                A++,
                I.iushrn(1);
            n(!I.isZero());
            var C = new i(1).toRed(this)
              , k = C.redNeg()
              , b = this.m.subn(1).iushrn(1)
              , h = this.m.bitLength();
            for (h = new i(2 * h * h).toRed(this); this.pow(h, b).cmp(k) !== 0; )
                h.redIAdd(k);
            for (var B = this.pow(h, I), Y = this.pow(f, I.addn(1).iushrn(1)), ne = this.pow(f, I), K = A; ne.cmp(C) !== 0; ) {
                for (var se = ne, de = 0; se.cmp(C) !== 0; de++)
                    se = se.redSqr();
                n(de < K);
                var xe = this.pow(B, new i(1).iushln(K - de - 1));
                Y = Y.redMul(xe),
                B = xe.redSqr(),
                ne = ne.redMul(B),
                K = de
            }
            return Y
        }
        ,
        V.prototype.invm = function(f) {
            var g = f._invmp(this.m);
            return g.negative !== 0 ? (g.negative = 0,
            this.imod(g).redNeg()) : this.imod(g)
        }
        ,
        V.prototype.pow = function(f, g) {
            if (g.isZero())
                return new i(1).toRed(this);
            if (g.cmpn(1) === 0)
                return f.clone();
            var x = 4
              , I = new Array(1 << x);
            I[0] = new i(1).toRed(this),
            I[1] = f;
            for (var A = 2; A < I.length; A++)
                I[A] = this.mul(I[A - 1], f);
            var C = I[0]
              , k = 0
              , b = 0
              , h = g.bitLength() % 26;
            for (h === 0 && (h = 26),
            A = g.length - 1; A >= 0; A--) {
                for (var B = g.words[A], Y = h - 1; Y >= 0; Y--) {
                    var ne = B >> Y & 1;
                    if (C !== I[0] && (C = this.sqr(C)),
                    ne === 0 && k === 0) {
                        b = 0;
                        continue
                    }
                    k <<= 1,
                    k |= ne,
                    b++,
                    !(b !== x && (A !== 0 || Y !== 0)) && (C = this.mul(C, I[k]),
                    b = 0,
                    k = 0)
                }
                h = 26
            }
            return C
        }
        ,
        V.prototype.convertTo = function(f) {
            var g = f.umod(this.m);
            return g === f ? g.clone() : g
        }
        ,
        V.prototype.convertFrom = function(f) {
            var g = f.clone();
            return g.red = null,
            g
        }
        ,
        i.mont = function(f) {
            return new Q(f)
        }
        ;
        function Q(T) {
            V.call(this, T),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new i(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        r(Q, V),
        Q.prototype.convertTo = function(f) {
            return this.imod(f.ushln(this.shift))
        }
        ,
        Q.prototype.convertFrom = function(f) {
            var g = this.imod(f.mul(this.rinv));
            return g.red = null,
            g
        }
        ,
        Q.prototype.imul = function(f, g) {
            if (f.isZero() || g.isZero())
                return f.words[0] = 0,
                f.length = 1,
                f;
            var x = f.imul(g)
              , I = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , A = x.isub(I).iushrn(this.shift)
              , C = A;
            return A.cmp(this.m) >= 0 ? C = A.isub(this.m) : A.cmpn(0) < 0 && (C = A.iadd(this.m)),
            C._forceRed(this)
        }
        ,
        Q.prototype.mul = function(f, g) {
            if (f.isZero() || g.isZero())
                return new i(0)._forceRed(this);
            var x = f.mul(g)
              , I = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , A = x.isub(I).iushrn(this.shift)
              , C = A;
            return A.cmp(this.m) >= 0 ? C = A.isub(this.m) : A.cmpn(0) < 0 && (C = A.iadd(this.m)),
            C._forceRed(this)
        }
        ,
        Q.prototype.invm = function(f) {
            var g = this.imod(f._invmp(this.m).mul(this.r2));
            return g._forceRed(this)
        }
    }
    )(typeof dy > "u" || dy, $C)
}
);
var qC = Ce((hy,zC)=>{
    "use strict";
    var Ff = kc()
      , Jr = Ff.Buffer;
    function HC(t, e) {
        for (var n in t)
            e[n] = t[n]
    }
    Jr.from && Jr.alloc && Jr.allocUnsafe && Jr.allocUnsafeSlow ? zC.exports = Ff : (HC(Ff, hy),
    hy.Buffer = Ko);
    function Ko(t, e, n) {
        return Jr(t, e, n)
    }
    Ko.prototype = Object.create(Jr.prototype);
    HC(Jr, Ko);
    Ko.from = function(t, e, n) {
        if (typeof t == "number")
            throw new TypeError("Argument must not be a number");
        return Jr(t, e, n)
    }
    ;
    Ko.alloc = function(t, e, n) {
        if (typeof t != "number")
            throw new TypeError("Argument must be a number");
        var r = Jr(t);
        return e !== void 0 ? typeof n == "string" ? r.fill(e, n) : r.fill(e) : r.fill(0),
        r
    }
    ;
    Ko.allocUnsafe = function(t) {
        if (typeof t != "number")
            throw new TypeError("Argument must be a number");
        return Jr(t)
    }
    ;
    Ko.allocUnsafeSlow = function(t) {
        if (typeof t != "number")
            throw new TypeError("Argument must be a number");
        return Ff.SlowBuffer(t)
    }
}
);
var GC = Ce((I$,WC)=>{
    "use strict";
    var Nf = qC().Buffer;
    function i4(t) {
        if (t.length >= 255)
            throw new TypeError("Alphabet too long");
        for (var e = new Uint8Array(256), n = 0; n < e.length; n++)
            e[n] = 255;
        for (var r = 0; r < t.length; r++) {
            var i = t.charAt(r)
              , o = i.charCodeAt(0);
            if (e[o] !== 255)
                throw new TypeError(i + " is ambiguous");
            e[o] = r
        }
        var s = t.length
          , a = t.charAt(0)
          , c = Math.log(s) / Math.log(256)
          , u = Math.log(256) / Math.log(s);
        function l(v) {
            if ((Array.isArray(v) || v instanceof Uint8Array) && (v = Nf.from(v)),
            !Nf.isBuffer(v))
                throw new TypeError("Expected Buffer");
            if (v.length === 0)
                return "";
            for (var E = 0, D = 0, S = 0, w = v.length; S !== w && v[S] === 0; )
                S++,
                E++;
            for (var M = (w - S) * u + 1 >>> 0, F = new Uint8Array(M); S !== w; ) {
                for (var N = v[S], P = 0, O = M - 1; (N !== 0 || P < D) && O !== -1; O--,
                P++)
                    N += 256 * F[O] >>> 0,
                    F[O] = N % s >>> 0,
                    N = N / s >>> 0;
                if (N !== 0)
                    throw new Error("Non-zero carry");
                D = P,
                S++
            }
            for (var z = M - D; z !== M && F[z] === 0; )
                z++;
            for (var q = a.repeat(E); z < M; ++z)
                q += t.charAt(F[z]);
            return q
        }
        function d(v) {
            if (typeof v != "string")
                throw new TypeError("Expected String");
            if (v.length === 0)
                return Nf.alloc(0);
            for (var E = 0, D = 0, S = 0; v[E] === a; )
                D++,
                E++;
            for (var w = (v.length - E) * c + 1 >>> 0, M = new Uint8Array(w); E < v.length; ) {
                var F = e[v.charCodeAt(E)];
                if (F === 255)
                    return;
                for (var N = 0, P = w - 1; (F !== 0 || N < S) && P !== -1; P--,
                N++)
                    F += s * M[P] >>> 0,
                    M[P] = F % 256 >>> 0,
                    F = F / 256 >>> 0;
                if (F !== 0)
                    throw new Error("Non-zero carry");
                S = N,
                E++
            }
            for (var O = w - S; O !== w && M[O] === 0; )
                O++;
            var z = Nf.allocUnsafe(D + (w - O));
            z.fill(0, 0, D);
            for (var q = D; O !== w; )
                z[q++] = M[O++];
            return z
        }
        function y(v) {
            var E = d(v);
            if (E)
                return E;
            throw new Error("Non-base" + s + " character")
        }
        return {
            encode: l,
            decodeUnsafe: d,
            decode: y
        }
    }
    WC.exports = i4
}
);
var Pf = Ce((A$,KC)=>{
    "use strict";
    var o4 = GC()
      , s4 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    KC.exports = o4(s4)
}
);
var YC = {};
a0(YC, {
    TextDecoder: ()=>Uf,
    TextEncoder: ()=>Vf
});
function Ci(t, e, n) {
    return e <= t && t <= n
}
function jf(t) {
    if (t === void 0)
        return {};
    if (t === Object(t))
        return t;
    throw TypeError("Could not convert argument to dictionary")
}
function c4(t) {
    for (var e = String(t), n = e.length, r = 0, i = []; r < n; ) {
        var o = e.charCodeAt(r);
        if (o < 55296 || o > 57343)
            i.push(o);
        else if (56320 <= o && o <= 57343)
            i.push(65533);
        else if (55296 <= o && o <= 56319)
            if (r === n - 1)
                i.push(65533);
            else {
                var s = t.charCodeAt(r + 1);
                if (56320 <= s && s <= 57343) {
                    var a = o & 1023
                      , c = s & 1023;
                    i.push(65536 + (a << 10) + c),
                    r += 1
                } else
                    i.push(65533)
            }
        r += 1
    }
    return i
}
function u4(t) {
    for (var e = "", n = 0; n < t.length; ++n) {
        var r = t[n];
        r <= 65535 ? e += String.fromCharCode(r) : (r -= 65536,
        e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320))
    }
    return e
}
function my(t) {
    this.tokens = [].slice.call(t)
}
function gy(t, e) {
    if (t)
        throw TypeError("Decoder error");
    return e || 65533
}
function l4() {}
function f4() {}
function Uf(t, e) {
    if (!(this instanceof Uf))
        return new Uf(t,e);
    if (t = t !== void 0 ? String(t).toLowerCase() : Lf,
    t !== Lf)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    e = jf(e),
    this._streaming = !1,
    this._BOMseen = !1,
    this._decoder = null,
    this._fatal = !!e.fatal,
    this._ignoreBOM = !!e.ignoreBOM,
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }),
    Object.defineProperty(this, "fatal", {
        value: this._fatal
    }),
    Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
function Vf(t, e) {
    if (!(this instanceof Vf))
        return new Vf(t,e);
    if (t = t !== void 0 ? String(t).toLowerCase() : Lf,
    t !== Lf)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    e = jf(e),
    this._streaming = !1,
    this._encoder = null,
    this._options = {
        fatal: !!e.fatal
    },
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
function d4(t) {
    var e = t.fatal
      , n = 0
      , r = 0
      , i = 0
      , o = 128
      , s = 191;
    this.handler = function(a, c) {
        if (c === Of && i !== 0)
            return i = 0,
            gy(e);
        if (c === Of)
            return la;
        if (i === 0) {
            if (Ci(c, 0, 127))
                return c;
            if (Ci(c, 194, 223))
                i = 1,
                n = c - 192;
            else if (Ci(c, 224, 239))
                c === 224 && (o = 160),
                c === 237 && (s = 159),
                i = 2,
                n = c - 224;
            else if (Ci(c, 240, 244))
                c === 240 && (o = 144),
                c === 244 && (s = 143),
                i = 3,
                n = c - 240;
            else
                return gy(e);
            return n = n << 6 * i,
            null
        }
        if (!Ci(c, o, s))
            return n = i = r = 0,
            o = 128,
            s = 191,
            a.prepend(c),
            gy(e);
        if (o = 128,
        s = 191,
        r += 1,
        n += c - 128 << 6 * (i - r),
        r !== i)
            return null;
        var u = n;
        return n = i = r = 0,
        u
    }
}
function h4(t) {
    var e = t.fatal;
    this.handler = function(n, r) {
        if (r === Of)
            return la;
        if (Ci(r, 0, 127))
            return r;
        var i, o;
        Ci(r, 128, 2047) ? (i = 1,
        o = 192) : Ci(r, 2048, 65535) ? (i = 2,
        o = 224) : Ci(r, 65536, 1114111) && (i = 3,
        o = 240);
        for (var s = [(r >> 6 * i) + o]; i > 0; ) {
            var a = r >> 6 * (i - 1);
            s.push(128 | a & 63),
            i -= 1
        }
        return s
    }
}
var Of, la, Lf, ZC = vn(()=>{
    "use strict";
    Of = -1;
    my.prototype = {
        endOfStream: function() {
            return !this.tokens.length
        },
        read: function() {
            return this.tokens.length ? this.tokens.shift() : Of
        },
        prepend: function(t) {
            if (Array.isArray(t))
                for (var e = t; e.length; )
                    this.tokens.unshift(e.pop());
            else
                this.tokens.unshift(t)
        },
        push: function(t) {
            if (Array.isArray(t))
                for (var e = t; e.length; )
                    this.tokens.push(e.shift());
            else
                this.tokens.push(t)
        }
    };
    la = -1;
    l4.prototype = {
        handler: function(t, e) {}
    };
    f4.prototype = {
        handler: function(t, e) {}
    };
    Lf = "utf-8";
    Uf.prototype = {
        decode: function(e, n) {
            var r;
            typeof e == "object" && e instanceof ArrayBuffer ? r = new Uint8Array(e) : typeof e == "object" && "buffer"in e && e.buffer instanceof ArrayBuffer ? r = new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : r = new Uint8Array(0),
            n = jf(n),
            this._streaming || (this._decoder = new d4({
                fatal: this._fatal
            }),
            this._BOMseen = !1),
            this._streaming = !!n.stream;
            for (var i = new my(r), o = [], s; !i.endOfStream() && (s = this._decoder.handler(i, i.read()),
            s !== la); )
                s !== null && (Array.isArray(s) ? o.push.apply(o, s) : o.push(s));
            if (!this._streaming) {
                do {
                    if (s = this._decoder.handler(i, i.read()),
                    s === la)
                        break;
                    s !== null && (Array.isArray(s) ? o.push.apply(o, s) : o.push(s))
                } while (!i.endOfStream());
                this._decoder = null
            }
            return o.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (o[0] === 65279 ? (this._BOMseen = !0,
            o.shift()) : this._BOMseen = !0),
            u4(o)
        }
    };
    Vf.prototype = {
        encode: function(e, n) {
            e = e ? String(e) : "",
            n = jf(n),
            this._streaming || (this._encoder = new h4(this._options)),
            this._streaming = !!n.stream;
            for (var r = [], i = new my(c4(e)), o; !i.endOfStream() && (o = this._encoder.handler(i, i.read()),
            o !== la); )
                Array.isArray(o) ? r.push.apply(r, o) : r.push(o);
            if (!this._streaming) {
                for (; o = this._encoder.handler(i, i.read()),
                o !== la; )
                    Array.isArray(o) ? r.push.apply(r, o) : r.push(o);
                this._encoder = null
            }
            return new Uint8Array(r)
        }
    }
}
);
var tD = Ce(yt=>{
    "use strict";
    var p4 = yt && yt.__createBinding || (Object.create ? function(t, e, n, r) {
        r === void 0 && (r = n),
        Object.defineProperty(t, r, {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }
    : function(t, e, n, r) {
        r === void 0 && (r = n),
        t[r] = e[n]
    }
    )
      , g4 = yt && yt.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , ei = yt && yt.__decorate || function(t, e, n, r) {
        var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, s;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            o = Reflect.decorate(t, e, n, r);
        else
            for (var a = t.length - 1; a >= 0; a--)
                (s = t[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(e, n, o) : s(e, n)) || o);
        return i > 3 && o && Object.defineProperty(e, n, o),
        o
    }
      , m4 = yt && yt.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (t != null)
            for (var n in t)
                n !== "default" && Object.hasOwnProperty.call(t, n) && p4(e, t, n);
        return g4(e, t),
        e
    }
      , XC = yt && yt.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(yt, "__esModule", {
        value: !0
    });
    yt.deserializeUnchecked = yt.deserialize = yt.serialize = yt.BinaryReader = yt.BinaryWriter = yt.BorshError = yt.baseDecode = yt.baseEncode = void 0;
    var co = XC(Rf())
      , QC = XC(Pf())
      , y4 = m4((ZC(),
    c0(YC)))
      , v4 = typeof TextDecoder != "function" ? y4.TextDecoder : TextDecoder
      , x4 = new v4("utf-8",{
        fatal: !0
    });
    function w4(t) {
        return typeof t == "string" && (t = Buffer.from(t, "utf8")),
        QC.default.encode(Buffer.from(t))
    }
    yt.baseEncode = w4;
    function b4(t) {
        return Buffer.from(QC.default.decode(t))
    }
    yt.baseDecode = b4;
    var yy = 1024
      , gn = class extends Error {
        constructor(e) {
            super(e),
            this.fieldPath = [],
            this.originalMessage = e
        }
        addToFieldPath(e) {
            this.fieldPath.splice(0, 0, e),
            this.message = this.originalMessage + ": " + this.fieldPath.join(".")
        }
    }
    ;
    yt.BorshError = gn;
    var $f = class {
        constructor() {
            this.buf = Buffer.alloc(yy),
            this.length = 0
        }
        maybeResize() {
            this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(yy)]))
        }
        writeU8(e) {
            this.maybeResize(),
            this.buf.writeUInt8(e, this.length),
            this.length += 1
        }
        writeU16(e) {
            this.maybeResize(),
            this.buf.writeUInt16LE(e, this.length),
            this.length += 2
        }
        writeU32(e) {
            this.maybeResize(),
            this.buf.writeUInt32LE(e, this.length),
            this.length += 4
        }
        writeU64(e) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new co.default(e).toArray("le", 8)))
        }
        writeU128(e) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new co.default(e).toArray("le", 16)))
        }
        writeU256(e) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new co.default(e).toArray("le", 32)))
        }
        writeU512(e) {
            this.maybeResize(),
            this.writeBuffer(Buffer.from(new co.default(e).toArray("le", 64)))
        }
        writeBuffer(e) {
            this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), e, Buffer.alloc(yy)]),
            this.length += e.length
        }
        writeString(e) {
            this.maybeResize();
            let n = Buffer.from(e, "utf8");
            this.writeU32(n.length),
            this.writeBuffer(n)
        }
        writeFixedArray(e) {
            this.writeBuffer(Buffer.from(e))
        }
        writeArray(e, n) {
            this.maybeResize(),
            this.writeU32(e.length);
            for (let r of e)
                this.maybeResize(),
                n(r)
        }
        toArray() {
            return this.buf.subarray(0, this.length)
        }
    }
    ;
    yt.BinaryWriter = $f;
    function ti(t, e, n) {
        let r = n.value;
        n.value = function(...i) {
            try {
                return r.apply(this, i)
            } catch (o) {
                if (o instanceof RangeError) {
                    let s = o.code;
                    if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(s) >= 0)
                        throw new gn("Reached the end of buffer when deserializing")
                }
                throw o
            }
        }
    }
    var Pn = class {
        constructor(e) {
            this.buf = e,
            this.offset = 0
        }
        readU8() {
            let e = this.buf.readUInt8(this.offset);
            return this.offset += 1,
            e
        }
        readU16() {
            let e = this.buf.readUInt16LE(this.offset);
            return this.offset += 2,
            e
        }
        readU32() {
            let e = this.buf.readUInt32LE(this.offset);
            return this.offset += 4,
            e
        }
        readU64() {
            let e = this.readBuffer(8);
            return new co.default(e,"le")
        }
        readU128() {
            let e = this.readBuffer(16);
            return new co.default(e,"le")
        }
        readU256() {
            let e = this.readBuffer(32);
            return new co.default(e,"le")
        }
        readU512() {
            let e = this.readBuffer(64);
            return new co.default(e,"le")
        }
        readBuffer(e) {
            if (this.offset + e > this.buf.length)
                throw new gn(`Expected buffer length ${e} isn't within bounds`);
            let n = this.buf.slice(this.offset, this.offset + e);
            return this.offset += e,
            n
        }
        readString() {
            let e = this.readU32()
              , n = this.readBuffer(e);
            try {
                return x4.decode(n)
            } catch (r) {
                throw new gn(`Error decoding UTF-8 string: ${r}`)
            }
        }
        readFixedArray(e) {
            return new Uint8Array(this.readBuffer(e))
        }
        readArray(e) {
            let n = this.readU32()
              , r = Array();
            for (let i = 0; i < n; ++i)
                r.push(e());
            return r
        }
    }
    ;
    ei([ti], Pn.prototype, "readU8", null);
    ei([ti], Pn.prototype, "readU16", null);
    ei([ti], Pn.prototype, "readU32", null);
    ei([ti], Pn.prototype, "readU64", null);
    ei([ti], Pn.prototype, "readU128", null);
    ei([ti], Pn.prototype, "readU256", null);
    ei([ti], Pn.prototype, "readU512", null);
    ei([ti], Pn.prototype, "readString", null);
    ei([ti], Pn.prototype, "readFixedArray", null);
    ei([ti], Pn.prototype, "readArray", null);
    yt.BinaryReader = Pn;
    function JC(t) {
        return t.charAt(0).toUpperCase() + t.slice(1)
    }
    function Yo(t, e, n, r, i) {
        try {
            if (typeof r == "string")
                i[`write${JC(r)}`](n);
            else if (r instanceof Array)
                if (typeof r[0] == "number") {
                    if (n.length !== r[0])
                        throw new gn(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
                    i.writeFixedArray(n)
                } else if (r.length === 2 && typeof r[1] == "number") {
                    if (n.length !== r[1])
                        throw new gn(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
                    for (let o = 0; o < r[1]; o++)
                        Yo(t, null, n[o], r[0], i)
                } else
                    i.writeArray(n, o=>{
                        Yo(t, e, o, r[0], i)
                    }
                    );
            else if (r.kind !== void 0)
                switch (r.kind) {
                case "option":
                    {
                        n == null ? i.writeU8(0) : (i.writeU8(1),
                        Yo(t, e, n, r.type, i));
                        break
                    }
                case "map":
                    {
                        i.writeU32(n.size),
                        n.forEach((o,s)=>{
                            Yo(t, e, s, r.key, i),
                            Yo(t, e, o, r.value, i)
                        }
                        );
                        break
                    }
                default:
                    throw new gn(`FieldType ${r} unrecognized`)
                }
            else
                eD(t, n, i)
        } catch (o) {
            throw o instanceof gn && o.addToFieldPath(e),
            o
        }
    }
    function eD(t, e, n) {
        if (typeof e.borshSerialize == "function") {
            e.borshSerialize(n);
            return
        }
        let r = t.get(e.constructor);
        if (!r)
            throw new gn(`Class ${e.constructor.name} is missing in schema`);
        if (r.kind === "struct")
            r.fields.map(([i,o])=>{
                Yo(t, i, e[i], o, n)
            }
            );
        else if (r.kind === "enum") {
            let i = e[r.field];
            for (let o = 0; o < r.values.length; ++o) {
                let[s,a] = r.values[o];
                if (s === i) {
                    n.writeU8(o),
                    Yo(t, s, e[s], a, n);
                    break
                }
            }
        } else
            throw new gn(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)
    }
    function E4(t, e, n=$f) {
        let r = new n;
        return eD(t, e, r),
        r.toArray()
    }
    yt.serialize = E4;
    function Zo(t, e, n, r) {
        try {
            if (typeof n == "string")
                return r[`read${JC(n)}`]();
            if (n instanceof Array) {
                if (typeof n[0] == "number")
                    return r.readFixedArray(n[0]);
                if (typeof n[1] == "number") {
                    let i = [];
                    for (let o = 0; o < n[1]; o++)
                        i.push(Zo(t, null, n[0], r));
                    return i
                } else
                    return r.readArray(()=>Zo(t, e, n[0], r))
            }
            if (n.kind === "option")
                return r.readU8() ? Zo(t, e, n.type, r) : void 0;
            if (n.kind === "map") {
                let i = new Map
                  , o = r.readU32();
                for (let s = 0; s < o; s++) {
                    let a = Zo(t, e, n.key, r)
                      , c = Zo(t, e, n.value, r);
                    i.set(a, c)
                }
                return i
            }
            return vy(t, n, r)
        } catch (i) {
            throw i instanceof gn && i.addToFieldPath(e),
            i
        }
    }
    function vy(t, e, n) {
        if (typeof e.borshDeserialize == "function")
            return e.borshDeserialize(n);
        let r = t.get(e);
        if (!r)
            throw new gn(`Class ${e.name} is missing in schema`);
        if (r.kind === "struct") {
            let i = {};
            for (let[o,s] of t.get(e).fields)
                i[o] = Zo(t, o, s, n);
            return new e(i)
        }
        if (r.kind === "enum") {
            let i = n.readU8();
            if (i >= r.values.length)
                throw new gn(`Enum index: ${i} is out of range`);
            let[o,s] = r.values[i]
              , a = Zo(t, o, s, n);
            return new e({
                [o]: a
            })
        }
        throw new gn(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)
    }
    function C4(t, e, n, r=Pn) {
        let i = new r(n)
          , o = vy(t, e, i);
        if (i.offset < n.length)
            throw new gn(`Unexpected ${n.length - i.offset} bytes after deserialized data`);
        return o
    }
    yt.deserialize = C4;
    function D4(t, e, n, r=Pn) {
        let i = new r(n);
        return vy(t, e, i)
    }
    yt.deserializeUnchecked = D4
}
);
var Ey = Ce(W=>{
    "use strict";
    Object.defineProperty(W, "__esModule", {
        value: !0
    });
    W.s16 = W.s8 = W.nu64be = W.u48be = W.u40be = W.u32be = W.u24be = W.u16be = W.nu64 = W.u48 = W.u40 = W.u32 = W.u24 = W.u16 = W.u8 = W.offset = W.greedy = W.Constant = W.UTF8 = W.CString = W.Blob = W.Boolean = W.BitField = W.BitStructure = W.VariantLayout = W.Union = W.UnionLayoutDiscriminator = W.UnionDiscriminator = W.Structure = W.Sequence = W.DoubleBE = W.Double = W.FloatBE = W.Float = W.NearInt64BE = W.NearInt64 = W.NearUInt64BE = W.NearUInt64 = W.IntBE = W.Int = W.UIntBE = W.UInt = W.OffsetLayout = W.GreedyCount = W.ExternalLayout = W.bindConstructorLayout = W.nameWithProperty = W.Layout = W.uint8ArrayToBuffer = W.checkUint8Array = void 0;
    W.constant = W.utf8 = W.cstr = W.blob = W.unionLayoutDiscriminator = W.union = W.seq = W.bits = W.struct = W.f64be = W.f64 = W.f32be = W.f32 = W.ns64be = W.s48be = W.s40be = W.s32be = W.s24be = W.s16be = W.ns64 = W.s48 = W.s40 = W.s32 = W.s24 = void 0;
    var wy = kc();
    function ha(t) {
        if (!(t instanceof Uint8Array))
            throw new TypeError("b must be a Uint8Array")
    }
    W.checkUint8Array = ha;
    function rt(t) {
        return ha(t),
        wy.Buffer.from(t.buffer, t.byteOffset, t.length)
    }
    W.uint8ArrayToBuffer = rt;
    var ut = class {
        constructor(e, n) {
            if (!Number.isInteger(e))
                throw new TypeError("span must be an integer");
            this.span = e,
            this.property = n
        }
        makeDestinationObject() {
            return {}
        }
        getSpan(e, n) {
            if (0 > this.span)
                throw new RangeError("indeterminate span");
            return this.span
        }
        replicate(e) {
            let n = Object.create(this.constructor.prototype);
            return Object.assign(n, this),
            n.property = e,
            n
        }
        fromArray(e) {}
    }
    ;
    W.Layout = ut;
    function by(t, e) {
        return e.property ? t + "[" + e.property + "]" : t
    }
    W.nameWithProperty = by;
    function I4(t, e) {
        if (typeof t != "function")
            throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(t, "layout_"))
            throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof ut))
            throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
            throw new Error("layout is already bound to a constructor");
        t.layout_ = e,
        e.boundConstructor_ = t,
        e.makeDestinationObject = ()=>new t,
        Object.defineProperty(t.prototype, "encode", {
            value(n, r) {
                return e.encode(this, n, r)
            },
            writable: !0
        }),
        Object.defineProperty(t, "decode", {
            value(n, r) {
                return e.decode(n, r)
            },
            writable: !0
        })
    }
    W.bindConstructorLayout = I4;
    var In = class extends ut {
        isCount() {
            throw new Error("ExternalLayout is abstract")
        }
    }
    ;
    W.ExternalLayout = In;
    var Hf = class extends In {
        constructor(e=1, n) {
            if (!Number.isInteger(e) || 0 >= e)
                throw new TypeError("elementSpan must be a (positive) integer");
            super(-1, n),
            this.elementSpan = e
        }
        isCount() {
            return !0
        }
        decode(e, n=0) {
            ha(e);
            let r = e.length - n;
            return Math.floor(r / this.elementSpan)
        }
        encode(e, n, r) {
            return 0
        }
    }
    ;
    W.GreedyCount = Hf;
    var Pc = class extends In {
        constructor(e, n=0, r) {
            if (!(e instanceof ut))
                throw new TypeError("layout must be a Layout");
            if (!Number.isInteger(n))
                throw new TypeError("offset must be integer or undefined");
            super(e.span, r || e.property),
            this.layout = e,
            this.offset = n
        }
        isCount() {
            return this.layout instanceof qn || this.layout instanceof nr
        }
        decode(e, n=0) {
            return this.layout.decode(e, n + this.offset)
        }
        encode(e, n, r=0) {
            return this.layout.encode(e, n, r + this.offset)
        }
    }
    ;
    W.OffsetLayout = Pc;
    var qn = class extends ut {
        constructor(e, n) {
            if (super(e, n),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(e, n=0) {
            return rt(e).readUIntLE(n, this.span)
        }
        encode(e, n, r=0) {
            return rt(n).writeUIntLE(e, r, this.span),
            this.span
        }
    }
    ;
    W.UInt = qn;
    var nr = class extends ut {
        constructor(e, n) {
            if (super(e, n),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(e, n=0) {
            return rt(e).readUIntBE(n, this.span)
        }
        encode(e, n, r=0) {
            return rt(n).writeUIntBE(e, r, this.span),
            this.span
        }
    }
    ;
    W.UIntBE = nr;
    var Di = class extends ut {
        constructor(e, n) {
            if (super(e, n),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(e, n=0) {
            return rt(e).readIntLE(n, this.span)
        }
        encode(e, n, r=0) {
            return rt(n).writeIntLE(e, r, this.span),
            this.span
        }
    }
    ;
    W.Int = Di;
    var uo = class extends ut {
        constructor(e, n) {
            if (super(e, n),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(e, n=0) {
            return rt(e).readIntBE(n, this.span)
        }
        encode(e, n, r=0) {
            return rt(n).writeIntBE(e, r, this.span),
            this.span
        }
    }
    ;
    W.IntBE = uo;
    var xy = Math.pow(2, 32);
    function sd(t) {
        let e = Math.floor(t / xy)
          , n = t - e * xy;
        return {
            hi32: e,
            lo32: n
        }
    }
    function ad(t, e) {
        return t * xy + e
    }
    var zf = class extends ut {
        constructor(e) {
            super(8, e)
        }
        decode(e, n=0) {
            let r = rt(e)
              , i = r.readUInt32LE(n)
              , o = r.readUInt32LE(n + 4);
            return ad(o, i)
        }
        encode(e, n, r=0) {
            let i = sd(e)
              , o = rt(n);
            return o.writeUInt32LE(i.lo32, r),
            o.writeUInt32LE(i.hi32, r + 4),
            8
        }
    }
    ;
    W.NearUInt64 = zf;
    var qf = class extends ut {
        constructor(e) {
            super(8, e)
        }
        decode(e, n=0) {
            let r = rt(e)
              , i = r.readUInt32BE(n)
              , o = r.readUInt32BE(n + 4);
            return ad(i, o)
        }
        encode(e, n, r=0) {
            let i = sd(e)
              , o = rt(n);
            return o.writeUInt32BE(i.hi32, r),
            o.writeUInt32BE(i.lo32, r + 4),
            8
        }
    }
    ;
    W.NearUInt64BE = qf;
    var Wf = class extends ut {
        constructor(e) {
            super(8, e)
        }
        decode(e, n=0) {
            let r = rt(e)
              , i = r.readUInt32LE(n)
              , o = r.readInt32LE(n + 4);
            return ad(o, i)
        }
        encode(e, n, r=0) {
            let i = sd(e)
              , o = rt(n);
            return o.writeUInt32LE(i.lo32, r),
            o.writeInt32LE(i.hi32, r + 4),
            8
        }
    }
    ;
    W.NearInt64 = Wf;
    var Gf = class extends ut {
        constructor(e) {
            super(8, e)
        }
        decode(e, n=0) {
            let r = rt(e)
              , i = r.readInt32BE(n)
              , o = r.readUInt32BE(n + 4);
            return ad(i, o)
        }
        encode(e, n, r=0) {
            let i = sd(e)
              , o = rt(n);
            return o.writeInt32BE(i.hi32, r),
            o.writeUInt32BE(i.lo32, r + 4),
            8
        }
    }
    ;
    W.NearInt64BE = Gf;
    var Kf = class extends ut {
        constructor(e) {
            super(4, e)
        }
        decode(e, n=0) {
            return rt(e).readFloatLE(n)
        }
        encode(e, n, r=0) {
            return rt(n).writeFloatLE(e, r),
            4
        }
    }
    ;
    W.Float = Kf;
    var Yf = class extends ut {
        constructor(e) {
            super(4, e)
        }
        decode(e, n=0) {
            return rt(e).readFloatBE(n)
        }
        encode(e, n, r=0) {
            return rt(n).writeFloatBE(e, r),
            4
        }
    }
    ;
    W.FloatBE = Yf;
    var Zf = class extends ut {
        constructor(e) {
            super(8, e)
        }
        decode(e, n=0) {
            return rt(e).readDoubleLE(n)
        }
        encode(e, n, r=0) {
            return rt(n).writeDoubleLE(e, r),
            8
        }
    }
    ;
    W.Double = Zf;
    var Xf = class extends ut {
        constructor(e) {
            super(8, e)
        }
        decode(e, n=0) {
            return rt(e).readDoubleBE(n)
        }
        encode(e, n, r=0) {
            return rt(n).writeDoubleBE(e, r),
            8
        }
    }
    ;
    W.DoubleBE = Xf;
    var Qf = class extends ut {
        constructor(e, n, r) {
            if (!(e instanceof ut))
                throw new TypeError("elementLayout must be a Layout");
            if (!(n instanceof In && n.isCount() || Number.isInteger(n) && 0 <= n))
                throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let i = -1;
            !(n instanceof In) && 0 < e.span && (i = n * e.span),
            super(i, r),
            this.elementLayout = e,
            this.count = n
        }
        getSpan(e, n=0) {
            if (0 <= this.span)
                return this.span;
            let r = 0
              , i = this.count;
            if (i instanceof In && (i = i.decode(e, n)),
            0 < this.elementLayout.span)
                r = i * this.elementLayout.span;
            else {
                let o = 0;
                for (; o < i; )
                    r += this.elementLayout.getSpan(e, n + r),
                    ++o
            }
            return r
        }
        decode(e, n=0) {
            let r = []
              , i = 0
              , o = this.count;
            for (o instanceof In && (o = o.decode(e, n)); i < o; )
                r.push(this.elementLayout.decode(e, n)),
                n += this.elementLayout.getSpan(e, n),
                i += 1;
            return r
        }
        encode(e, n, r=0) {
            let i = this.elementLayout
              , o = e.reduce((s,a)=>s + i.encode(a, n, r + s), 0);
            return this.count instanceof In && this.count.encode(e.length, n, r),
            o
        }
    }
    ;
    W.Sequence = Qf;
    var Jf = class extends ut {
        constructor(e, n, r) {
            if (!(Array.isArray(e) && e.reduce((o,s)=>o && s instanceof ut, !0)))
                throw new TypeError("fields must be array of Layout instances");
            typeof n == "boolean" && r === void 0 && (r = n,
            n = void 0);
            for (let o of e)
                if (0 > o.span && o.property === void 0)
                    throw new Error("fields cannot contain unnamed variable-length layout");
            let i = -1;
            try {
                i = e.reduce((o,s)=>o + s.getSpan(), 0)
            } catch {}
            super(i, n),
            this.fields = e,
            this.decodePrefixes = !!r
        }
        getSpan(e, n=0) {
            if (0 <= this.span)
                return this.span;
            let r = 0;
            try {
                r = this.fields.reduce((i,o)=>{
                    let s = o.getSpan(e, n);
                    return n += s,
                    i + s
                }
                , 0)
            } catch {
                throw new RangeError("indeterminate span")
            }
            return r
        }
        decode(e, n=0) {
            ha(e);
            let r = this.makeDestinationObject();
            for (let i of this.fields)
                if (i.property !== void 0 && (r[i.property] = i.decode(e, n)),
                n += i.getSpan(e, n),
                this.decodePrefixes && e.length === n)
                    break;
            return r
        }
        encode(e, n, r=0) {
            let i = r
              , o = 0
              , s = 0;
            for (let a of this.fields) {
                let c = a.span;
                if (s = 0 < c ? c : 0,
                a.property !== void 0) {
                    let u = e[a.property];
                    u !== void 0 && (s = a.encode(u, n, r),
                    0 > c && (c = a.getSpan(n, r)))
                }
                o = r,
                r += c
            }
            return o + s - i
        }
        fromArray(e) {
            let n = this.makeDestinationObject();
            for (let r of this.fields)
                r.property !== void 0 && 0 < e.length && (n[r.property] = e.shift());
            return n
        }
        layoutFor(e) {
            if (typeof e != "string")
                throw new TypeError("property must be string");
            for (let n of this.fields)
                if (n.property === e)
                    return n
        }
        offsetOf(e) {
            if (typeof e != "string")
                throw new TypeError("property must be string");
            let n = 0;
            for (let r of this.fields) {
                if (r.property === e)
                    return n;
                0 > r.span ? n = -1 : 0 <= n && (n += r.span)
            }
        }
    }
    ;
    W.Structure = Jf;
    var Oc = class {
        constructor(e) {
            this.property = e
        }
        decode(e, n) {
            throw new Error("UnionDiscriminator is abstract")
        }
        encode(e, n, r) {
            throw new Error("UnionDiscriminator is abstract")
        }
    }
    ;
    W.UnionDiscriminator = Oc;
    var da = class extends Oc {
        constructor(e, n) {
            if (!(e instanceof In && e.isCount()))
                throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(n || e.property || "variant"),
            this.layout = e
        }
        decode(e, n) {
            return this.layout.decode(e, n)
        }
        encode(e, n, r) {
            return this.layout.encode(e, n, r)
        }
    }
    ;
    W.UnionLayoutDiscriminator = da;
    var Lc = class extends ut {
        constructor(e, n, r) {
            let i;
            if (e instanceof qn || e instanceof nr)
                i = new da(new Pc(e));
            else if (e instanceof In && e.isCount())
                i = new da(e);
            else if (e instanceof Oc)
                i = e;
            else
                throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            if (n === void 0 && (n = null),
            !(n === null || n instanceof ut))
                throw new TypeError("defaultLayout must be null or a Layout");
            if (n !== null) {
                if (0 > n.span)
                    throw new Error("defaultLayout must have constant span");
                n.property === void 0 && (n = n.replicate("content"))
            }
            let o = -1;
            n && (o = n.span,
            0 <= o && (e instanceof qn || e instanceof nr) && (o += i.layout.span)),
            super(o, r),
            this.discriminator = i,
            this.usesPrefixDiscriminator = e instanceof qn || e instanceof nr,
            this.defaultLayout = n,
            this.registry = {};
            let s = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(a) {
                return s(a)
            }
            ,
            this.configGetSourceVariant = function(a) {
                s = a.bind(this)
            }
        }
        getSpan(e, n=0) {
            if (0 <= this.span)
                return this.span;
            let r = this.getVariant(e, n);
            if (!r)
                throw new Error("unable to determine span for unrecognized variant");
            return r.getSpan(e, n)
        }
        defaultGetSourceVariant(e) {
            if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
                if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property))
                    return;
                let n = this.registry[e[this.discriminator.property]];
                if (n && (!n.layout || n.property && Object.prototype.hasOwnProperty.call(e, n.property)))
                    return n
            } else
                for (let n in this.registry) {
                    let r = this.registry[n];
                    if (r.property && Object.prototype.hasOwnProperty.call(e, r.property))
                        return r
                }
            throw new Error("unable to infer src variant")
        }
        decode(e, n=0) {
            let r, i = this.discriminator, o = i.decode(e, n), s = this.registry[o];
            if (s === void 0) {
                let a = this.defaultLayout
                  , c = 0;
                this.usesPrefixDiscriminator && (c = i.layout.span),
                r = this.makeDestinationObject(),
                r[i.property] = o,
                r[a.property] = a.decode(e, n + c)
            } else
                r = s.decode(e, n);
            return r
        }
        encode(e, n, r=0) {
            let i = this.getSourceVariant(e);
            if (i === void 0) {
                let o = this.discriminator
                  , s = this.defaultLayout
                  , a = 0;
                return this.usesPrefixDiscriminator && (a = o.layout.span),
                o.encode(e[o.property], n, r),
                a + s.encode(e[s.property], n, r + a)
            }
            return i.encode(e, n, r)
        }
        addVariant(e, n, r) {
            let i = new ed(this,e,n,r);
            return this.registry[e] = i,
            i
        }
        getVariant(e, n=0) {
            let r;
            return e instanceof Uint8Array ? r = this.discriminator.decode(e, n) : r = e,
            this.registry[r]
        }
    }
    ;
    W.Union = Lc;
    var ed = class extends ut {
        constructor(e, n, r, i) {
            if (!(e instanceof Lc))
                throw new TypeError("union must be a Union");
            if (!Number.isInteger(n) || 0 > n)
                throw new TypeError("variant must be a (non-negative) integer");
            if (typeof r == "string" && i === void 0 && (i = r,
            r = null),
            r) {
                if (!(r instanceof ut))
                    throw new TypeError("layout must be a Layout");
                if (e.defaultLayout !== null && 0 <= r.span && r.span > e.defaultLayout.span)
                    throw new Error("variant span exceeds span of containing union");
                if (typeof i != "string")
                    throw new TypeError("variant must have a String property")
            }
            let o = e.span;
            0 > e.span && (o = r ? r.span : 0,
            0 <= o && e.usesPrefixDiscriminator && (o += e.discriminator.layout.span)),
            super(o, i),
            this.union = e,
            this.variant = n,
            this.layout = r || null
        }
        getSpan(e, n=0) {
            if (0 <= this.span)
                return this.span;
            let r = 0;
            this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span);
            let i = 0;
            return this.layout && (i = this.layout.getSpan(e, n + r)),
            r + i
        }
        decode(e, n=0) {
            let r = this.makeDestinationObject();
            if (this !== this.union.getVariant(e, n))
                throw new Error("variant mismatch");
            let i = 0;
            return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
            this.layout ? r[this.property] = this.layout.decode(e, n + i) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant),
            r
        }
        encode(e, n, r=0) {
            let i = 0;
            if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
            this.layout && !Object.prototype.hasOwnProperty.call(e, this.property))
                throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, n, r);
            let o = i;
            if (this.layout && (this.layout.encode(e[this.property], n, r + i),
            o += this.layout.getSpan(n, r + i),
            0 <= this.union.span && o > this.union.span))
                throw new Error("encoded variant overruns containing union");
            return o
        }
        fromArray(e) {
            if (this.layout)
                return this.layout.fromArray(e)
        }
    }
    ;
    W.VariantLayout = ed;
    function fa(t) {
        return 0 > t && (t += 4294967296),
        t
    }
    var Uc = class extends ut {
        constructor(e, n, r) {
            if (!(e instanceof qn || e instanceof nr))
                throw new TypeError("word must be a UInt or UIntBE layout");
            if (typeof n == "string" && r === void 0 && (r = n,
            n = !1),
            4 < e.span)
                throw new RangeError("word cannot exceed 32 bits");
            super(e.span, r),
            this.word = e,
            this.msb = !!n,
            this.fields = [];
            let i = 0;
            this._packedSetValue = function(o) {
                return i = fa(o),
                this
            }
            ,
            this._packedGetValue = function() {
                return i
            }
        }
        decode(e, n=0) {
            let r = this.makeDestinationObject()
              , i = this.word.decode(e, n);
            this._packedSetValue(i);
            for (let o of this.fields)
                o.property !== void 0 && (r[o.property] = o.decode(e));
            return r
        }
        encode(e, n, r=0) {
            let i = this.word.decode(n, r);
            this._packedSetValue(i);
            for (let o of this.fields)
                if (o.property !== void 0) {
                    let s = e[o.property];
                    s !== void 0 && o.encode(s)
                }
            return this.word.encode(this._packedGetValue(), n, r)
        }
        addField(e, n) {
            let r = new Vc(this,e,n);
            return this.fields.push(r),
            r
        }
        addBoolean(e) {
            let n = new td(this,e);
            return this.fields.push(n),
            n
        }
        fieldFor(e) {
            if (typeof e != "string")
                throw new TypeError("property must be string");
            for (let n of this.fields)
                if (n.property === e)
                    return n
        }
    }
    ;
    W.BitStructure = Uc;
    var Vc = class {
        constructor(e, n, r) {
            if (!(e instanceof Uc))
                throw new TypeError("container must be a BitStructure");
            if (!Number.isInteger(n) || 0 >= n)
                throw new TypeError("bits must be positive integer");
            let i = 8 * e.span
              , o = e.fields.reduce((s,a)=>s + a.bits, 0);
            if (n + o > i)
                throw new Error("bits too long for span remainder (" + (i - o) + " of " + i + " remain)");
            this.container = e,
            this.bits = n,
            this.valueMask = (1 << n) - 1,
            n === 32 && (this.valueMask = 4294967295),
            this.start = o,
            this.container.msb && (this.start = i - o - n),
            this.wordMask = fa(this.valueMask << this.start),
            this.property = r
        }
        decode(e, n) {
            let r = this.container._packedGetValue();
            return fa(r & this.wordMask) >>> this.start
        }
        encode(e) {
            if (typeof e != "number" || !Number.isInteger(e) || e !== fa(e & this.valueMask))
                throw new TypeError(by("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
            let n = this.container._packedGetValue()
              , r = fa(e << this.start);
            this.container._packedSetValue(fa(n & ~this.wordMask) | r)
        }
    }
    ;
    W.BitField = Vc;
    var td = class extends Vc {
        constructor(e, n) {
            super(e, 1, n)
        }
        decode(e, n) {
            return !!super.decode(e, n)
        }
        encode(e) {
            typeof e == "boolean" && (e = +e),
            super.encode(e)
        }
    }
    ;
    W.Boolean = td;
    var nd = class extends ut {
        constructor(e, n) {
            if (!(e instanceof In && e.isCount() || Number.isInteger(e) && 0 <= e))
                throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let r = -1;
            e instanceof In || (r = e),
            super(r, n),
            this.length = e
        }
        getSpan(e, n) {
            let r = this.span;
            return 0 > r && (r = this.length.decode(e, n)),
            r
        }
        decode(e, n=0) {
            let r = this.span;
            return 0 > r && (r = this.length.decode(e, n)),
            rt(e).slice(n, n + r)
        }
        encode(e, n, r) {
            let i = this.length;
            if (this.length instanceof In && (i = e.length),
            !(e instanceof Uint8Array && i === e.length))
                throw new TypeError(by("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
            if (r + i > n.length)
                throw new RangeError("encoding overruns Uint8Array");
            let o = rt(e);
            return rt(n).write(o.toString("hex"), r, i, "hex"),
            this.length instanceof In && this.length.encode(i, n, r),
            i
        }
    }
    ;
    W.Blob = nd;
    var rd = class extends ut {
        constructor(e) {
            super(-1, e)
        }
        getSpan(e, n=0) {
            ha(e);
            let r = n;
            for (; r < e.length && e[r] !== 0; )
                r += 1;
            return 1 + r - n
        }
        decode(e, n=0) {
            let r = this.getSpan(e, n);
            return rt(e).slice(n, n + r - 1).toString("utf-8")
        }
        encode(e, n, r=0) {
            typeof e != "string" && (e = String(e));
            let i = wy.Buffer.from(e, "utf8")
              , o = i.length;
            if (r + o > n.length)
                throw new RangeError("encoding overruns Buffer");
            let s = rt(n);
            return i.copy(s, r),
            s[r + o] = 0,
            o + 1
        }
    }
    ;
    W.CString = rd;
    var id = class extends ut {
        constructor(e, n) {
            if (typeof e == "string" && n === void 0 && (n = e,
            e = void 0),
            e === void 0)
                e = -1;
            else if (!Number.isInteger(e))
                throw new TypeError("maxSpan must be an integer");
            super(-1, n),
            this.maxSpan = e
        }
        getSpan(e, n=0) {
            return ha(e),
            e.length - n
        }
        decode(e, n=0) {
            let r = this.getSpan(e, n);
            if (0 <= this.maxSpan && this.maxSpan < r)
                throw new RangeError("text length exceeds maxSpan");
            return rt(e).slice(n, n + r).toString("utf-8")
        }
        encode(e, n, r=0) {
            typeof e != "string" && (e = String(e));
            let i = wy.Buffer.from(e, "utf8")
              , o = i.length;
            if (0 <= this.maxSpan && this.maxSpan < o)
                throw new RangeError("text length exceeds maxSpan");
            if (r + o > n.length)
                throw new RangeError("encoding overruns Buffer");
            return i.copy(rt(n), r),
            o
        }
    }
    ;
    W.UTF8 = id;
    var od = class extends ut {
        constructor(e, n) {
            super(0, n),
            this.value = e
        }
        decode(e, n) {
            return this.value
        }
        encode(e, n, r) {
            return 0
        }
    }
    ;
    W.Constant = od;
    W.greedy = (t,e)=>new Hf(t,e);
    W.offset = (t,e,n)=>new Pc(t,e,n);
    W.u8 = t=>new qn(1,t);
    W.u16 = t=>new qn(2,t);
    W.u24 = t=>new qn(3,t);
    W.u32 = t=>new qn(4,t);
    W.u40 = t=>new qn(5,t);
    W.u48 = t=>new qn(6,t);
    W.nu64 = t=>new zf(t);
    W.u16be = t=>new nr(2,t);
    W.u24be = t=>new nr(3,t);
    W.u32be = t=>new nr(4,t);
    W.u40be = t=>new nr(5,t);
    W.u48be = t=>new nr(6,t);
    W.nu64be = t=>new qf(t);
    W.s8 = t=>new Di(1,t);
    W.s16 = t=>new Di(2,t);
    W.s24 = t=>new Di(3,t);
    W.s32 = t=>new Di(4,t);
    W.s40 = t=>new Di(5,t);
    W.s48 = t=>new Di(6,t);
    W.ns64 = t=>new Wf(t);
    W.s16be = t=>new uo(2,t);
    W.s24be = t=>new uo(3,t);
    W.s32be = t=>new uo(4,t);
    W.s40be = t=>new uo(5,t);
    W.s48be = t=>new uo(6,t);
    W.ns64be = t=>new Gf(t);
    W.f32 = t=>new Kf(t);
    W.f32be = t=>new Yf(t);
    W.f64 = t=>new Zf(t);
    W.f64be = t=>new Xf(t);
    W.struct = (t,e,n)=>new Jf(t,e,n);
    W.bits = (t,e,n)=>new Uc(t,e,n);
    W.seq = (t,e,n)=>new Qf(t,e,n);
    W.union = (t,e,n)=>new Lc(t,e,n);
    W.unionLayoutDiscriminator = (t,e)=>new da(t,e);
    W.blob = (t,e)=>new nd(t,e);
    W.cstr = t=>new rd(t);
    W.utf8 = (t,e)=>new id(t,e);
    W.constant = (t,e)=>new od(t,e)
}
);
var nD = Ce(pa=>{
    "use strict";
    Object.defineProperty(pa, "__esModule", {
        value: !0
    });
    var cd;
    function A4(t) {
        {
            let e = Buffer.from(t);
            e.reverse();
            let n = e.toString("hex");
            return n.length === 0 ? BigInt(0) : BigInt(`0x${n}`)
        }
        return cd.toBigInt(t, !1)
    }
    pa.toBigIntLE = A4;
    function _4(t) {
        {
            let e = t.toString("hex");
            return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`)
        }
        return cd.toBigInt(t, !0)
    }
    pa.toBigIntBE = _4;
    function S4(t, e) {
        {
            let n = t.toString(16)
              , r = Buffer.from(n.padStart(e * 2, "0").slice(0, e * 2), "hex");
            return r.reverse(),
            r
        }
        return cd.fromBigInt(t, Buffer.allocUnsafe(e), !1)
    }
    pa.toBufferLE = S4;
    function M4(t, e) {
        {
            let n = t.toString(16);
            return Buffer.from(n.padStart(e * 2, "0").slice(0, e * 2), "hex")
        }
        return cd.fromBigInt(t, Buffer.allocUnsafe(e), !0)
    }
    pa.toBufferBE = M4
}
);
function $c() {
    if (!fd && (fd = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto),
    !fd))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return fd(N4)
}
var fd, N4, Ay = vn(()=>{
    "use strict";
    N4 = new Uint8Array(16)
}
);
var aD, cD = vn(()=>{
    "use strict";
    aD = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
}
);
function P4(t) {
    return typeof t == "string" && aD.test(t)
}
var lo, Hc = vn(()=>{
    "use strict";
    cD();
    lo = P4
}
);
function O4(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , n = (mn[t[e + 0]] + mn[t[e + 1]] + mn[t[e + 2]] + mn[t[e + 3]] + "-" + mn[t[e + 4]] + mn[t[e + 5]] + "-" + mn[t[e + 6]] + mn[t[e + 7]] + "-" + mn[t[e + 8]] + mn[t[e + 9]] + "-" + mn[t[e + 10]] + mn[t[e + 11]] + mn[t[e + 12]] + mn[t[e + 13]] + mn[t[e + 14]] + mn[t[e + 15]]).toLowerCase();
    if (!lo(n))
        throw TypeError("Stringified UUID is invalid");
    return n
}
var mn, dd, fo, zc = vn(()=>{
    "use strict";
    Hc();
    mn = [];
    for (dd = 0; dd < 256; ++dd)
        mn.push((dd + 256).toString(16).substr(1));
    fo = O4
}
);
function L4(t, e, n) {
    var r = e && n || 0
      , i = e || new Array(16);
    t = t || {};
    var o = t.node || uD
      , s = t.clockseq !== void 0 ? t.clockseq : _y;
    if (o == null || s == null) {
        var a = t.random || (t.rng || $c)();
        o == null && (o = uD = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]),
        s == null && (s = _y = (a[6] << 8 | a[7]) & 16383)
    }
    var c = t.msecs !== void 0 ? t.msecs : Date.now()
      , u = t.nsecs !== void 0 ? t.nsecs : My + 1
      , l = c - Sy + (u - My) / 1e4;
    if (l < 0 && t.clockseq === void 0 && (s = s + 1 & 16383),
    (l < 0 || c > Sy) && t.nsecs === void 0 && (u = 0),
    u >= 1e4)
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    Sy = c,
    My = u,
    _y = s,
    c += 122192928e5;
    var d = ((c & 268435455) * 1e4 + u) % 4294967296;
    i[r++] = d >>> 24 & 255,
    i[r++] = d >>> 16 & 255,
    i[r++] = d >>> 8 & 255,
    i[r++] = d & 255;
    var y = c / 4294967296 * 1e4 & 268435455;
    i[r++] = y >>> 8 & 255,
    i[r++] = y & 255,
    i[r++] = y >>> 24 & 15 | 16,
    i[r++] = y >>> 16 & 255,
    i[r++] = s >>> 8 | 128,
    i[r++] = s & 255;
    for (var v = 0; v < 6; ++v)
        i[r + v] = o[v];
    return e || fo(i)
}
var uD, _y, Sy, My, lD, fD = vn(()=>{
    "use strict";
    Ay();
    zc();
    Sy = 0,
    My = 0;
    lD = L4
}
);
function U4(t) {
    if (!lo(t))
        throw TypeError("Invalid UUID");
    var e, n = new Uint8Array(16);
    return n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24,
    n[1] = e >>> 16 & 255,
    n[2] = e >>> 8 & 255,
    n[3] = e & 255,
    n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8,
    n[5] = e & 255,
    n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8,
    n[7] = e & 255,
    n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8,
    n[9] = e & 255,
    n[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255,
    n[11] = e / 4294967296 & 255,
    n[12] = e >>> 24 & 255,
    n[13] = e >>> 16 & 255,
    n[14] = e >>> 8 & 255,
    n[15] = e & 255,
    n
}
var hd, ky = vn(()=>{
    "use strict";
    Hc();
    hd = U4
}
);
function V4(t) {
    t = unescape(encodeURIComponent(t));
    for (var e = [], n = 0; n < t.length; ++n)
        e.push(t.charCodeAt(n));
    return e
}
function pd(t, e, n) {
    function r(i, o, s, a) {
        if (typeof i == "string" && (i = V4(i)),
        typeof o == "string" && (o = hd(o)),
        o.length !== 16)
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var c = new Uint8Array(16 + i.length);
        if (c.set(o),
        c.set(i, o.length),
        c = n(c),
        c[6] = c[6] & 15 | e,
        c[8] = c[8] & 63 | 128,
        s) {
            a = a || 0;
            for (var u = 0; u < 16; ++u)
                s[a + u] = c[u];
            return s
        }
        return fo(c)
    }
    try {
        r.name = t
    } catch {}
    return r.DNS = j4,
    r.URL = $4,
    r
}
var j4, $4, Ty = vn(()=>{
    "use strict";
    zc();
    ky();
    j4 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    $4 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
}
);
function H4(t) {
    if (typeof t == "string") {
        var e = unescape(encodeURIComponent(t));
        t = new Uint8Array(e.length);
        for (var n = 0; n < e.length; ++n)
            t[n] = e.charCodeAt(n)
    }
    return z4(q4(W4(t), t.length * 8))
}
function z4(t) {
    for (var e = [], n = t.length * 32, r = "0123456789abcdef", i = 0; i < n; i += 8) {
        var o = t[i >> 5] >>> i % 32 & 255
          , s = parseInt(r.charAt(o >>> 4 & 15) + r.charAt(o & 15), 16);
        e.push(s)
    }
    return e
}
function dD(t) {
    return (t + 64 >>> 9 << 4) + 14 + 1
}
function q4(t, e) {
    t[e >> 5] |= 128 << e % 32,
    t[dD(e) - 1] = e;
    for (var n = 1732584193, r = -271733879, i = -1732584194, o = 271733878, s = 0; s < t.length; s += 16) {
        var a = n
          , c = r
          , u = i
          , l = o;
        n = _n(n, r, i, o, t[s], 7, -680876936),
        o = _n(o, n, r, i, t[s + 1], 12, -389564586),
        i = _n(i, o, n, r, t[s + 2], 17, 606105819),
        r = _n(r, i, o, n, t[s + 3], 22, -1044525330),
        n = _n(n, r, i, o, t[s + 4], 7, -176418897),
        o = _n(o, n, r, i, t[s + 5], 12, 1200080426),
        i = _n(i, o, n, r, t[s + 6], 17, -1473231341),
        r = _n(r, i, o, n, t[s + 7], 22, -45705983),
        n = _n(n, r, i, o, t[s + 8], 7, 1770035416),
        o = _n(o, n, r, i, t[s + 9], 12, -1958414417),
        i = _n(i, o, n, r, t[s + 10], 17, -42063),
        r = _n(r, i, o, n, t[s + 11], 22, -1990404162),
        n = _n(n, r, i, o, t[s + 12], 7, 1804603682),
        o = _n(o, n, r, i, t[s + 13], 12, -40341101),
        i = _n(i, o, n, r, t[s + 14], 17, -1502002290),
        r = _n(r, i, o, n, t[s + 15], 22, 1236535329),
        n = Sn(n, r, i, o, t[s + 1], 5, -165796510),
        o = Sn(o, n, r, i, t[s + 6], 9, -1069501632),
        i = Sn(i, o, n, r, t[s + 11], 14, 643717713),
        r = Sn(r, i, o, n, t[s], 20, -373897302),
        n = Sn(n, r, i, o, t[s + 5], 5, -701558691),
        o = Sn(o, n, r, i, t[s + 10], 9, 38016083),
        i = Sn(i, o, n, r, t[s + 15], 14, -660478335),
        r = Sn(r, i, o, n, t[s + 4], 20, -405537848),
        n = Sn(n, r, i, o, t[s + 9], 5, 568446438),
        o = Sn(o, n, r, i, t[s + 14], 9, -1019803690),
        i = Sn(i, o, n, r, t[s + 3], 14, -187363961),
        r = Sn(r, i, o, n, t[s + 8], 20, 1163531501),
        n = Sn(n, r, i, o, t[s + 13], 5, -1444681467),
        o = Sn(o, n, r, i, t[s + 2], 9, -51403784),
        i = Sn(i, o, n, r, t[s + 7], 14, 1735328473),
        r = Sn(r, i, o, n, t[s + 12], 20, -1926607734),
        n = Mn(n, r, i, o, t[s + 5], 4, -378558),
        o = Mn(o, n, r, i, t[s + 8], 11, -2022574463),
        i = Mn(i, o, n, r, t[s + 11], 16, 1839030562),
        r = Mn(r, i, o, n, t[s + 14], 23, -35309556),
        n = Mn(n, r, i, o, t[s + 1], 4, -1530992060),
        o = Mn(o, n, r, i, t[s + 4], 11, 1272893353),
        i = Mn(i, o, n, r, t[s + 7], 16, -155497632),
        r = Mn(r, i, o, n, t[s + 10], 23, -1094730640),
        n = Mn(n, r, i, o, t[s + 13], 4, 681279174),
        o = Mn(o, n, r, i, t[s], 11, -358537222),
        i = Mn(i, o, n, r, t[s + 3], 16, -722521979),
        r = Mn(r, i, o, n, t[s + 6], 23, 76029189),
        n = Mn(n, r, i, o, t[s + 9], 4, -640364487),
        o = Mn(o, n, r, i, t[s + 12], 11, -421815835),
        i = Mn(i, o, n, r, t[s + 15], 16, 530742520),
        r = Mn(r, i, o, n, t[s + 2], 23, -995338651),
        n = kn(n, r, i, o, t[s], 6, -198630844),
        o = kn(o, n, r, i, t[s + 7], 10, 1126891415),
        i = kn(i, o, n, r, t[s + 14], 15, -1416354905),
        r = kn(r, i, o, n, t[s + 5], 21, -57434055),
        n = kn(n, r, i, o, t[s + 12], 6, 1700485571),
        o = kn(o, n, r, i, t[s + 3], 10, -1894986606),
        i = kn(i, o, n, r, t[s + 10], 15, -1051523),
        r = kn(r, i, o, n, t[s + 1], 21, -2054922799),
        n = kn(n, r, i, o, t[s + 8], 6, 1873313359),
        o = kn(o, n, r, i, t[s + 15], 10, -30611744),
        i = kn(i, o, n, r, t[s + 6], 15, -1560198380),
        r = kn(r, i, o, n, t[s + 13], 21, 1309151649),
        n = kn(n, r, i, o, t[s + 4], 6, -145523070),
        o = kn(o, n, r, i, t[s + 11], 10, -1120210379),
        i = kn(i, o, n, r, t[s + 2], 15, 718787259),
        r = kn(r, i, o, n, t[s + 9], 21, -343485551),
        n = ho(n, a),
        r = ho(r, c),
        i = ho(i, u),
        o = ho(o, l)
    }
    return [n, r, i, o]
}
function W4(t) {
    if (t.length === 0)
        return [];
    for (var e = t.length * 8, n = new Uint32Array(dD(e)), r = 0; r < e; r += 8)
        n[r >> 5] |= (t[r / 8] & 255) << r % 32;
    return n
}
function ho(t, e) {
    var n = (t & 65535) + (e & 65535)
      , r = (t >> 16) + (e >> 16) + (n >> 16);
    return r << 16 | n & 65535
}
function G4(t, e) {
    return t << e | t >>> 32 - e
}
function gd(t, e, n, r, i, o) {
    return ho(G4(ho(ho(e, t), ho(r, o)), i), n)
}
function _n(t, e, n, r, i, o, s) {
    return gd(e & n | ~e & r, t, e, i, o, s)
}
function Sn(t, e, n, r, i, o, s) {
    return gd(e & r | n & ~r, t, e, i, o, s)
}
function Mn(t, e, n, r, i, o, s) {
    return gd(e ^ n ^ r, t, e, i, o, s)
}
function kn(t, e, n, r, i, o, s) {
    return gd(n ^ (e | ~r), t, e, i, o, s)
}
var hD, pD = vn(()=>{
    "use strict";
    hD = H4
}
);
var K4, gD, mD = vn(()=>{
    "use strict";
    Ty();
    pD();
    K4 = pd("v3", 48, hD),
    gD = K4
}
);
function Y4(t, e, n) {
    t = t || {};
    var r = t.random || (t.rng || $c)();
    if (r[6] = r[6] & 15 | 64,
    r[8] = r[8] & 63 | 128,
    e) {
        n = n || 0;
        for (var i = 0; i < 16; ++i)
            e[n + i] = r[i];
        return e
    }
    return fo(r)
}
var yD, vD = vn(()=>{
    "use strict";
    Ay();
    zc();
    yD = Y4
}
);
function Z4(t, e, n, r) {
    switch (t) {
    case 0:
        return e & n ^ ~e & r;
    case 1:
        return e ^ n ^ r;
    case 2:
        return e & n ^ e & r ^ n & r;
    case 3:
        return e ^ n ^ r
    }
}
function By(t, e) {
    return t << e | t >>> 32 - e
}
function X4(t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782]
      , n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof t == "string") {
        var r = unescape(encodeURIComponent(t));
        t = [];
        for (var i = 0; i < r.length; ++i)
            t.push(r.charCodeAt(i))
    } else
        Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (var o = t.length / 4 + 2, s = Math.ceil(o / 16), a = new Array(s), c = 0; c < s; ++c) {
        for (var u = new Uint32Array(16), l = 0; l < 16; ++l)
            u[l] = t[c * 64 + l * 4] << 24 | t[c * 64 + l * 4 + 1] << 16 | t[c * 64 + l * 4 + 2] << 8 | t[c * 64 + l * 4 + 3];
        a[c] = u
    }
    a[s - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32),
    a[s - 1][14] = Math.floor(a[s - 1][14]),
    a[s - 1][15] = (t.length - 1) * 8 & 4294967295;
    for (var d = 0; d < s; ++d) {
        for (var y = new Uint32Array(80), v = 0; v < 16; ++v)
            y[v] = a[d][v];
        for (var E = 16; E < 80; ++E)
            y[E] = By(y[E - 3] ^ y[E - 8] ^ y[E - 14] ^ y[E - 16], 1);
        for (var D = n[0], S = n[1], w = n[2], M = n[3], F = n[4], N = 0; N < 80; ++N) {
            var P = Math.floor(N / 20)
              , O = By(D, 5) + Z4(P, S, w, M) + F + e[P] + y[N] >>> 0;
            F = M,
            M = w,
            w = By(S, 30) >>> 0,
            S = D,
            D = O
        }
        n[0] = n[0] + D >>> 0,
        n[1] = n[1] + S >>> 0,
        n[2] = n[2] + w >>> 0,
        n[3] = n[3] + M >>> 0,
        n[4] = n[4] + F >>> 0
    }
    return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255]
}
var xD, wD = vn(()=>{
    "use strict";
    xD = X4
}
);
var Q4, bD, ED = vn(()=>{
    "use strict";
    Ty();
    wD();
    Q4 = pd("v5", 80, xD),
    bD = Q4
}
);
var CD, DD = vn(()=>{
    "use strict";
    CD = "00000000-0000-0000-0000-000000000000"
}
);
function J4(t) {
    if (!lo(t))
        throw TypeError("Invalid UUID");
    return parseInt(t.substr(14, 1), 16)
}
var ID, AD = vn(()=>{
    "use strict";
    Hc();
    ID = J4
}
);
var Ry = {};
a0(Ry, {
    NIL: ()=>CD,
    parse: ()=>hd,
    stringify: ()=>fo,
    v1: ()=>lD,
    v3: ()=>gD,
    v4: ()=>yD,
    v5: ()=>bD,
    validate: ()=>lo,
    version: ()=>ID
});
var Fy = vn(()=>{
    "use strict";
    fD();
    mD();
    vD();
    ED();
    DD();
    AD();
    Hc();
    zc();
    ky()
}
);
var SD = Ce((xH,_D)=>{
    "use strict";
    var eN = (Fy(),
    c0(Ry)).v4
      , tN = function(t, e, n, r) {
        if (typeof t != "string")
            throw new TypeError(t + " must be a string");
        r = r || {};
        let i = typeof r.version == "number" ? r.version : 2;
        if (i !== 1 && i !== 2)
            throw new TypeError(i + " must be 1 or 2");
        let o = {
            method: t
        };
        if (i === 2 && (o.jsonrpc = "2.0"),
        e) {
            if (typeof e != "object" && !Array.isArray(e))
                throw new TypeError(e + " must be an object, array or omitted");
            o.params = e
        }
        if (typeof n > "u") {
            let s = typeof r.generator == "function" ? r.generator : function() {
                return eN()
            }
            ;
            o.id = s(o, r)
        } else
            i === 2 && n === null ? r.notificationIdNull && (o.id = null) : o.id = n;
        return o
    };
    _D.exports = tN
}
);
var kD = Ce((wH,MD)=>{
    "use strict";
    var nN = (Fy(),
    c0(Ry)).v4
      , rN = SD()
      , qc = function(t, e) {
        if (!(this instanceof qc))
            return new qc(t,e);
        e || (e = {}),
        this.options = {
            reviver: typeof e.reviver < "u" ? e.reviver : null,
            replacer: typeof e.replacer < "u" ? e.replacer : null,
            generator: typeof e.generator < "u" ? e.generator : function() {
                return nN()
            }
            ,
            version: typeof e.version < "u" ? e.version : 2,
            notificationIdNull: typeof e.notificationIdNull == "boolean" ? e.notificationIdNull : !1
        },
        this.callServer = t
    };
    MD.exports = qc;
    qc.prototype.request = function(t, e, n, r) {
        let i = this
          , o = null
          , s = Array.isArray(t) && typeof e == "function";
        if (this.options.version === 1 && s)
            throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (s || !s && t && typeof t == "object" && typeof e == "function")
            r = e,
            o = t;
        else {
            typeof n == "function" && (r = n,
            n = void 0);
            let u = typeof r == "function";
            try {
                o = rN(t, e, n, {
                    generator: this.options.generator,
                    version: this.options.version,
                    notificationIdNull: this.options.notificationIdNull
                })
            } catch (l) {
                if (u)
                    return r(l);
                throw l
            }
            if (!u)
                return o
        }
        let c;
        try {
            c = JSON.stringify(o, this.options.replacer)
        } catch (u) {
            return r(u)
        }
        return this.callServer(c, function(u, l) {
            i._parseResponse(u, l, r)
        }),
        o
    }
    ;
    qc.prototype._parseResponse = function(t, e, n) {
        if (t) {
            n(t);
            return
        }
        if (!e)
            return n();
        let r;
        try {
            r = JSON.parse(e, this.options.reviver)
        } catch (i) {
            return n(i)
        }
        if (n.length === 3)
            if (Array.isArray(r)) {
                let i = function(s) {
                    return typeof s.error < "u"
                }
                  , o = function(s) {
                    return !i(s)
                };
                return n(null, r.filter(i), r.filter(o))
            } else
                return n(null, r.error, r.result);
        n(null, r)
    }
}
);
var BD = Ce((bH,Ny)=>{
    "use strict";
    var iN = Object.prototype.hasOwnProperty
      , On = "~";
    function Wc() {}
    Object.create && (Wc.prototype = Object.create(null),
    new Wc().__proto__ || (On = !1));
    function oN(t, e, n) {
        this.fn = t,
        this.context = e,
        this.once = n || !1
    }
    function TD(t, e, n, r, i) {
        if (typeof n != "function")
            throw new TypeError("The listener must be a function");
        var o = new oN(n,r || t,i)
          , s = On ? On + e : e;
        return t._events[s] ? t._events[s].fn ? t._events[s] = [t._events[s], o] : t._events[s].push(o) : (t._events[s] = o,
        t._eventsCount++),
        t
    }
    function md(t, e) {
        --t._eventsCount === 0 ? t._events = new Wc : delete t._events[e]
    }
    function Tn() {
        this._events = new Wc,
        this._eventsCount = 0
    }
    Tn.prototype.eventNames = function() {
        var e = [], n, r;
        if (this._eventsCount === 0)
            return e;
        for (r in n = this._events)
            iN.call(n, r) && e.push(On ? r.slice(1) : r);
        return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(n)) : e
    }
    ;
    Tn.prototype.listeners = function(e) {
        var n = On ? On + e : e
          , r = this._events[n];
        if (!r)
            return [];
        if (r.fn)
            return [r.fn];
        for (var i = 0, o = r.length, s = new Array(o); i < o; i++)
            s[i] = r[i].fn;
        return s
    }
    ;
    Tn.prototype.listenerCount = function(e) {
        var n = On ? On + e : e
          , r = this._events[n];
        return r ? r.fn ? 1 : r.length : 0
    }
    ;
    Tn.prototype.emit = function(e, n, r, i, o, s) {
        var a = On ? On + e : e;
        if (!this._events[a])
            return !1;
        var c = this._events[a], u = arguments.length, l, d;
        if (c.fn) {
            switch (c.once && this.removeListener(e, c.fn, void 0, !0),
            u) {
            case 1:
                return c.fn.call(c.context),
                !0;
            case 2:
                return c.fn.call(c.context, n),
                !0;
            case 3:
                return c.fn.call(c.context, n, r),
                !0;
            case 4:
                return c.fn.call(c.context, n, r, i),
                !0;
            case 5:
                return c.fn.call(c.context, n, r, i, o),
                !0;
            case 6:
                return c.fn.call(c.context, n, r, i, o, s),
                !0
            }
            for (d = 1,
            l = new Array(u - 1); d < u; d++)
                l[d - 1] = arguments[d];
            c.fn.apply(c.context, l)
        } else {
            var y = c.length, v;
            for (d = 0; d < y; d++)
                switch (c[d].once && this.removeListener(e, c[d].fn, void 0, !0),
                u) {
                case 1:
                    c[d].fn.call(c[d].context);
                    break;
                case 2:
                    c[d].fn.call(c[d].context, n);
                    break;
                case 3:
                    c[d].fn.call(c[d].context, n, r);
                    break;
                case 4:
                    c[d].fn.call(c[d].context, n, r, i);
                    break;
                default:
                    if (!l)
                        for (v = 1,
                        l = new Array(u - 1); v < u; v++)
                            l[v - 1] = arguments[v];
                    c[d].fn.apply(c[d].context, l)
                }
        }
        return !0
    }
    ;
    Tn.prototype.on = function(e, n, r) {
        return TD(this, e, n, r, !1)
    }
    ;
    Tn.prototype.once = function(e, n, r) {
        return TD(this, e, n, r, !0)
    }
    ;
    Tn.prototype.removeListener = function(e, n, r, i) {
        var o = On ? On + e : e;
        if (!this._events[o])
            return this;
        if (!n)
            return md(this, o),
            this;
        var s = this._events[o];
        if (s.fn)
            s.fn === n && (!i || s.once) && (!r || s.context === r) && md(this, o);
        else {
            for (var a = 0, c = [], u = s.length; a < u; a++)
                (s[a].fn !== n || i && !s[a].once || r && s[a].context !== r) && c.push(s[a]);
            c.length ? this._events[o] = c.length === 1 ? c[0] : c : md(this, o)
        }
        return this
    }
    ;
    Tn.prototype.removeAllListeners = function(e) {
        var n;
        return e ? (n = On ? On + e : e,
        this._events[n] && md(this, n)) : (this._events = new Wc,
        this._eventsCount = 0),
        this
    }
    ;
    Tn.prototype.off = Tn.prototype.removeListener;
    Tn.prototype.addListener = Tn.prototype.on;
    Tn.prefixed = On;
    Tn.EventEmitter = Tn;
    typeof Ny < "u" && (Ny.exports = Tn)
}
);
var fA = Ce(()=>{
    "use strict"
}
);
var Ge = Ce((rh,dA)=>{
    "use strict";
    (function(t, e) {
        typeof rh == "object" ? dA.exports = rh = e() : typeof define == "function" && define.amd ? define([], e) : t.CryptoJS = e()
    }
    )(rh, function() {
        var t = t || function(e, n) {
            var r;
            if (typeof window < "u" && window.crypto && (r = window.crypto),
            typeof self < "u" && self.crypto && (r = self.crypto),
            typeof globalThis < "u" && globalThis.crypto && (r = globalThis.crypto),
            !r && typeof window < "u" && window.msCrypto && (r = window.msCrypto),
            !r && typeof global < "u" && global.crypto && (r = global.crypto),
            !r && typeof Nv == "function")
                try {
                    r = fA()
                } catch {}
            var i = function() {
                if (r) {
                    if (typeof r.getRandomValues == "function")
                        try {
                            return r.getRandomValues(new Uint32Array(1))[0]
                        } catch {}
                    if (typeof r.randomBytes == "function")
                        try {
                            return r.randomBytes(4).readInt32LE()
                        } catch {}
                }
                throw new Error("Native crypto module could not be used to get secure random number.")
            }
              , o = Object.create || function() {
                function w() {}
                return function(M) {
                    var F;
                    return w.prototype = M,
                    F = new w,
                    w.prototype = null,
                    F
                }
            }()
              , s = {}
              , a = s.lib = {}
              , c = a.Base = function() {
                return {
                    extend: function(w) {
                        var M = o(this);
                        return w && M.mixIn(w),
                        (!M.hasOwnProperty("init") || this.init === M.init) && (M.init = function() {
                            M.$super.init.apply(this, arguments)
                        }
                        ),
                        M.init.prototype = M,
                        M.$super = this,
                        M
                    },
                    create: function() {
                        var w = this.extend();
                        return w.init.apply(w, arguments),
                        w
                    },
                    init: function() {},
                    mixIn: function(w) {
                        for (var M in w)
                            w.hasOwnProperty(M) && (this[M] = w[M]);
                        w.hasOwnProperty("toString") && (this.toString = w.toString)
                    },
                    clone: function() {
                        return this.init.prototype.extend(this)
                    }
                }
            }()
              , u = a.WordArray = c.extend({
                init: function(w, M) {
                    w = this.words = w || [],
                    M != n ? this.sigBytes = M : this.sigBytes = w.length * 4
                },
                toString: function(w) {
                    return (w || d).stringify(this)
                },
                concat: function(w) {
                    var M = this.words
                      , F = w.words
                      , N = this.sigBytes
                      , P = w.sigBytes;
                    if (this.clamp(),
                    N % 4)
                        for (var O = 0; O < P; O++) {
                            var z = F[O >>> 2] >>> 24 - O % 4 * 8 & 255;
                            M[N + O >>> 2] |= z << 24 - (N + O) % 4 * 8
                        }
                    else
                        for (var q = 0; q < P; q += 4)
                            M[N + q >>> 2] = F[q >>> 2];
                    return this.sigBytes += P,
                    this
                },
                clamp: function() {
                    var w = this.words
                      , M = this.sigBytes;
                    w[M >>> 2] &= 4294967295 << 32 - M % 4 * 8,
                    w.length = e.ceil(M / 4)
                },
                clone: function() {
                    var w = c.clone.call(this);
                    return w.words = this.words.slice(0),
                    w
                },
                random: function(w) {
                    for (var M = [], F = 0; F < w; F += 4)
                        M.push(i());
                    return new u.init(M,w)
                }
            })
              , l = s.enc = {}
              , d = l.Hex = {
                stringify: function(w) {
                    for (var M = w.words, F = w.sigBytes, N = [], P = 0; P < F; P++) {
                        var O = M[P >>> 2] >>> 24 - P % 4 * 8 & 255;
                        N.push((O >>> 4).toString(16)),
                        N.push((O & 15).toString(16))
                    }
                    return N.join("")
                },
                parse: function(w) {
                    for (var M = w.length, F = [], N = 0; N < M; N += 2)
                        F[N >>> 3] |= parseInt(w.substr(N, 2), 16) << 24 - N % 8 * 4;
                    return new u.init(F,M / 2)
                }
            }
              , y = l.Latin1 = {
                stringify: function(w) {
                    for (var M = w.words, F = w.sigBytes, N = [], P = 0; P < F; P++) {
                        var O = M[P >>> 2] >>> 24 - P % 4 * 8 & 255;
                        N.push(String.fromCharCode(O))
                    }
                    return N.join("")
                },
                parse: function(w) {
                    for (var M = w.length, F = [], N = 0; N < M; N++)
                        F[N >>> 2] |= (w.charCodeAt(N) & 255) << 24 - N % 4 * 8;
                    return new u.init(F,M)
                }
            }
              , v = l.Utf8 = {
                stringify: function(w) {
                    try {
                        return decodeURIComponent(escape(y.stringify(w)))
                    } catch {
                        throw new Error("Malformed UTF-8 data")
                    }
                },
                parse: function(w) {
                    return y.parse(unescape(encodeURIComponent(w)))
                }
            }
              , E = a.BufferedBlockAlgorithm = c.extend({
                reset: function() {
                    this._data = new u.init,
                    this._nDataBytes = 0
                },
                _append: function(w) {
                    typeof w == "string" && (w = v.parse(w)),
                    this._data.concat(w),
                    this._nDataBytes += w.sigBytes
                },
                _process: function(w) {
                    var M, F = this._data, N = F.words, P = F.sigBytes, O = this.blockSize, z = O * 4, q = P / z;
                    w ? q = e.ceil(q) : q = e.max((q | 0) - this._minBufferSize, 0);
                    var J = q * O
                      , te = e.min(J * 4, P);
                    if (J) {
                        for (var V = 0; V < J; V += O)
                            this._doProcessBlock(N, V);
                        M = N.splice(0, J),
                        F.sigBytes -= te
                    }
                    return new u.init(M,te)
                },
                clone: function() {
                    var w = c.clone.call(this);
                    return w._data = this._data.clone(),
                    w
                },
                _minBufferSize: 0
            })
              , D = a.Hasher = E.extend({
                cfg: c.extend(),
                init: function(w) {
                    this.cfg = this.cfg.extend(w),
                    this.reset()
                },
                reset: function() {
                    E.reset.call(this),
                    this._doReset()
                },
                update: function(w) {
                    return this._append(w),
                    this._process(),
                    this
                },
                finalize: function(w) {
                    w && this._append(w);
                    var M = this._doFinalize();
                    return M
                },
                blockSize: 512 / 32,
                _createHelper: function(w) {
                    return function(M, F) {
                        return new w.init(F).finalize(M)
                    }
                },
                _createHmacHelper: function(w) {
                    return function(M, F) {
                        return new S.HMAC.init(w,F).finalize(M)
                    }
                }
            })
              , S = s.algo = {};
            return s
        }(Math);
        return t
    })
}
);
var fu = Ce((ih,hA)=>{
    "use strict";
    (function(t, e) {
        typeof ih == "object" ? hA.exports = ih = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(ih, function(t) {
        return function(e) {
            var n = t
              , r = n.lib
              , i = r.Base
              , o = r.WordArray
              , s = n.x64 = {}
              , a = s.Word = i.extend({
                init: function(u, l) {
                    this.high = u,
                    this.low = l
                }
            })
              , c = s.WordArray = i.extend({
                init: function(u, l) {
                    u = this.words = u || [],
                    l != e ? this.sigBytes = l : this.sigBytes = u.length * 8
                },
                toX32: function() {
                    for (var u = this.words, l = u.length, d = [], y = 0; y < l; y++) {
                        var v = u[y];
                        d.push(v.high),
                        d.push(v.low)
                    }
                    return o.create(d, this.sigBytes)
                },
                clone: function() {
                    for (var u = i.clone.call(this), l = u.words = this.words.slice(0), d = l.length, y = 0; y < d; y++)
                        l[y] = l[y].clone();
                    return u
                }
            })
        }(),
        t
    })
}
);
var gA = Ce((oh,pA)=>{
    "use strict";
    (function(t, e) {
        typeof oh == "object" ? pA.exports = oh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(oh, function(t) {
        return function() {
            if (typeof ArrayBuffer == "function") {
                var e = t
                  , n = e.lib
                  , r = n.WordArray
                  , i = r.init
                  , o = r.init = function(s) {
                    if (s instanceof ArrayBuffer && (s = new Uint8Array(s)),
                    (s instanceof Int8Array || typeof Uint8ClampedArray < "u" && s instanceof Uint8ClampedArray || s instanceof Int16Array || s instanceof Uint16Array || s instanceof Int32Array || s instanceof Uint32Array || s instanceof Float32Array || s instanceof Float64Array) && (s = new Uint8Array(s.buffer,s.byteOffset,s.byteLength)),
                    s instanceof Uint8Array) {
                        for (var a = s.byteLength, c = [], u = 0; u < a; u++)
                            c[u >>> 2] |= s[u] << 24 - u % 4 * 8;
                        i.call(this, c, a)
                    } else
                        i.apply(this, arguments)
                }
                ;
                o.prototype = r
            }
        }(),
        t.lib.WordArray
    })
}
);
var yA = Ce((sh,mA)=>{
    "use strict";
    (function(t, e) {
        typeof sh == "object" ? mA.exports = sh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(sh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.WordArray
              , i = e.enc
              , o = i.Utf16 = i.Utf16BE = {
                stringify: function(a) {
                    for (var c = a.words, u = a.sigBytes, l = [], d = 0; d < u; d += 2) {
                        var y = c[d >>> 2] >>> 16 - d % 4 * 8 & 65535;
                        l.push(String.fromCharCode(y))
                    }
                    return l.join("")
                },
                parse: function(a) {
                    for (var c = a.length, u = [], l = 0; l < c; l++)
                        u[l >>> 1] |= a.charCodeAt(l) << 16 - l % 2 * 16;
                    return r.create(u, c * 2)
                }
            };
            i.Utf16LE = {
                stringify: function(a) {
                    for (var c = a.words, u = a.sigBytes, l = [], d = 0; d < u; d += 2) {
                        var y = s(c[d >>> 2] >>> 16 - d % 4 * 8 & 65535);
                        l.push(String.fromCharCode(y))
                    }
                    return l.join("")
                },
                parse: function(a) {
                    for (var c = a.length, u = [], l = 0; l < c; l++)
                        u[l >>> 1] |= s(a.charCodeAt(l) << 16 - l % 2 * 16);
                    return r.create(u, c * 2)
                }
            };
            function s(a) {
                return a << 8 & 4278255360 | a >>> 8 & 16711935
            }
        }(),
        t.enc.Utf16
    })
}
);
var wo = Ce((ah,vA)=>{
    "use strict";
    (function(t, e) {
        typeof ah == "object" ? vA.exports = ah = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(ah, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.WordArray
              , i = e.enc
              , o = i.Base64 = {
                stringify: function(a) {
                    var c = a.words
                      , u = a.sigBytes
                      , l = this._map;
                    a.clamp();
                    for (var d = [], y = 0; y < u; y += 3)
                        for (var v = c[y >>> 2] >>> 24 - y % 4 * 8 & 255, E = c[y + 1 >>> 2] >>> 24 - (y + 1) % 4 * 8 & 255, D = c[y + 2 >>> 2] >>> 24 - (y + 2) % 4 * 8 & 255, S = v << 16 | E << 8 | D, w = 0; w < 4 && y + w * .75 < u; w++)
                            d.push(l.charAt(S >>> 6 * (3 - w) & 63));
                    var M = l.charAt(64);
                    if (M)
                        for (; d.length % 4; )
                            d.push(M);
                    return d.join("")
                },
                parse: function(a) {
                    var c = a.length
                      , u = this._map
                      , l = this._reverseMap;
                    if (!l) {
                        l = this._reverseMap = [];
                        for (var d = 0; d < u.length; d++)
                            l[u.charCodeAt(d)] = d
                    }
                    var y = u.charAt(64);
                    if (y) {
                        var v = a.indexOf(y);
                        v !== -1 && (c = v)
                    }
                    return s(a, c, l)
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            };
            function s(a, c, u) {
                for (var l = [], d = 0, y = 0; y < c; y++)
                    if (y % 4) {
                        var v = u[a.charCodeAt(y - 1)] << y % 4 * 2
                          , E = u[a.charCodeAt(y)] >>> 6 - y % 4 * 2
                          , D = v | E;
                        l[d >>> 2] |= D << 24 - d % 4 * 8,
                        d++
                    }
                return r.create(l, d)
            }
        }(),
        t.enc.Base64
    })
}
);
var wA = Ce((ch,xA)=>{
    "use strict";
    (function(t, e) {
        typeof ch == "object" ? xA.exports = ch = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(ch, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.WordArray
              , i = e.enc
              , o = i.Base64url = {
                stringify: function(a, c) {
                    c === void 0 && (c = !0);
                    var u = a.words
                      , l = a.sigBytes
                      , d = c ? this._safe_map : this._map;
                    a.clamp();
                    for (var y = [], v = 0; v < l; v += 3)
                        for (var E = u[v >>> 2] >>> 24 - v % 4 * 8 & 255, D = u[v + 1 >>> 2] >>> 24 - (v + 1) % 4 * 8 & 255, S = u[v + 2 >>> 2] >>> 24 - (v + 2) % 4 * 8 & 255, w = E << 16 | D << 8 | S, M = 0; M < 4 && v + M * .75 < l; M++)
                            y.push(d.charAt(w >>> 6 * (3 - M) & 63));
                    var F = d.charAt(64);
                    if (F)
                        for (; y.length % 4; )
                            y.push(F);
                    return y.join("")
                },
                parse: function(a, c) {
                    c === void 0 && (c = !0);
                    var u = a.length
                      , l = c ? this._safe_map : this._map
                      , d = this._reverseMap;
                    if (!d) {
                        d = this._reverseMap = [];
                        for (var y = 0; y < l.length; y++)
                            d[l.charCodeAt(y)] = y
                    }
                    var v = l.charAt(64);
                    if (v) {
                        var E = a.indexOf(v);
                        E !== -1 && (u = E)
                    }
                    return s(a, u, d)
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
            };
            function s(a, c, u) {
                for (var l = [], d = 0, y = 0; y < c; y++)
                    if (y % 4) {
                        var v = u[a.charCodeAt(y - 1)] << y % 4 * 2
                          , E = u[a.charCodeAt(y)] >>> 6 - y % 4 * 2
                          , D = v | E;
                        l[d >>> 2] |= D << 24 - d % 4 * 8,
                        d++
                    }
                return r.create(l, d)
            }
        }(),
        t.enc.Base64url
    })
}
);
var bo = Ce((uh,bA)=>{
    "use strict";
    (function(t, e) {
        typeof uh == "object" ? bA.exports = uh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(uh, function(t) {
        return function(e) {
            var n = t
              , r = n.lib
              , i = r.WordArray
              , o = r.Hasher
              , s = n.algo
              , a = [];
            (function() {
                for (var v = 0; v < 64; v++)
                    a[v] = e.abs(e.sin(v + 1)) * 4294967296 | 0
            }
            )();
            var c = s.MD5 = o.extend({
                _doReset: function() {
                    this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878])
                },
                _doProcessBlock: function(v, E) {
                    for (var D = 0; D < 16; D++) {
                        var S = E + D
                          , w = v[S];
                        v[S] = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360
                    }
                    var M = this._hash.words
                      , F = v[E + 0]
                      , N = v[E + 1]
                      , P = v[E + 2]
                      , O = v[E + 3]
                      , z = v[E + 4]
                      , q = v[E + 5]
                      , J = v[E + 6]
                      , te = v[E + 7]
                      , V = v[E + 8]
                      , Q = v[E + 9]
                      , T = v[E + 10]
                      , f = v[E + 11]
                      , g = v[E + 12]
                      , x = v[E + 13]
                      , I = v[E + 14]
                      , A = v[E + 15]
                      , C = M[0]
                      , k = M[1]
                      , b = M[2]
                      , h = M[3];
                    C = u(C, k, b, h, F, 7, a[0]),
                    h = u(h, C, k, b, N, 12, a[1]),
                    b = u(b, h, C, k, P, 17, a[2]),
                    k = u(k, b, h, C, O, 22, a[3]),
                    C = u(C, k, b, h, z, 7, a[4]),
                    h = u(h, C, k, b, q, 12, a[5]),
                    b = u(b, h, C, k, J, 17, a[6]),
                    k = u(k, b, h, C, te, 22, a[7]),
                    C = u(C, k, b, h, V, 7, a[8]),
                    h = u(h, C, k, b, Q, 12, a[9]),
                    b = u(b, h, C, k, T, 17, a[10]),
                    k = u(k, b, h, C, f, 22, a[11]),
                    C = u(C, k, b, h, g, 7, a[12]),
                    h = u(h, C, k, b, x, 12, a[13]),
                    b = u(b, h, C, k, I, 17, a[14]),
                    k = u(k, b, h, C, A, 22, a[15]),
                    C = l(C, k, b, h, N, 5, a[16]),
                    h = l(h, C, k, b, J, 9, a[17]),
                    b = l(b, h, C, k, f, 14, a[18]),
                    k = l(k, b, h, C, F, 20, a[19]),
                    C = l(C, k, b, h, q, 5, a[20]),
                    h = l(h, C, k, b, T, 9, a[21]),
                    b = l(b, h, C, k, A, 14, a[22]),
                    k = l(k, b, h, C, z, 20, a[23]),
                    C = l(C, k, b, h, Q, 5, a[24]),
                    h = l(h, C, k, b, I, 9, a[25]),
                    b = l(b, h, C, k, O, 14, a[26]),
                    k = l(k, b, h, C, V, 20, a[27]),
                    C = l(C, k, b, h, x, 5, a[28]),
                    h = l(h, C, k, b, P, 9, a[29]),
                    b = l(b, h, C, k, te, 14, a[30]),
                    k = l(k, b, h, C, g, 20, a[31]),
                    C = d(C, k, b, h, q, 4, a[32]),
                    h = d(h, C, k, b, V, 11, a[33]),
                    b = d(b, h, C, k, f, 16, a[34]),
                    k = d(k, b, h, C, I, 23, a[35]),
                    C = d(C, k, b, h, N, 4, a[36]),
                    h = d(h, C, k, b, z, 11, a[37]),
                    b = d(b, h, C, k, te, 16, a[38]),
                    k = d(k, b, h, C, T, 23, a[39]),
                    C = d(C, k, b, h, x, 4, a[40]),
                    h = d(h, C, k, b, F, 11, a[41]),
                    b = d(b, h, C, k, O, 16, a[42]),
                    k = d(k, b, h, C, J, 23, a[43]),
                    C = d(C, k, b, h, Q, 4, a[44]),
                    h = d(h, C, k, b, g, 11, a[45]),
                    b = d(b, h, C, k, A, 16, a[46]),
                    k = d(k, b, h, C, P, 23, a[47]),
                    C = y(C, k, b, h, F, 6, a[48]),
                    h = y(h, C, k, b, te, 10, a[49]),
                    b = y(b, h, C, k, I, 15, a[50]),
                    k = y(k, b, h, C, q, 21, a[51]),
                    C = y(C, k, b, h, g, 6, a[52]),
                    h = y(h, C, k, b, O, 10, a[53]),
                    b = y(b, h, C, k, T, 15, a[54]),
                    k = y(k, b, h, C, N, 21, a[55]),
                    C = y(C, k, b, h, V, 6, a[56]),
                    h = y(h, C, k, b, A, 10, a[57]),
                    b = y(b, h, C, k, J, 15, a[58]),
                    k = y(k, b, h, C, x, 21, a[59]),
                    C = y(C, k, b, h, z, 6, a[60]),
                    h = y(h, C, k, b, f, 10, a[61]),
                    b = y(b, h, C, k, P, 15, a[62]),
                    k = y(k, b, h, C, Q, 21, a[63]),
                    M[0] = M[0] + C | 0,
                    M[1] = M[1] + k | 0,
                    M[2] = M[2] + b | 0,
                    M[3] = M[3] + h | 0
                },
                _doFinalize: function() {
                    var v = this._data
                      , E = v.words
                      , D = this._nDataBytes * 8
                      , S = v.sigBytes * 8;
                    E[S >>> 5] |= 128 << 24 - S % 32;
                    var w = e.floor(D / 4294967296)
                      , M = D;
                    E[(S + 64 >>> 9 << 4) + 15] = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360,
                    E[(S + 64 >>> 9 << 4) + 14] = (M << 8 | M >>> 24) & 16711935 | (M << 24 | M >>> 8) & 4278255360,
                    v.sigBytes = (E.length + 1) * 4,
                    this._process();
                    for (var F = this._hash, N = F.words, P = 0; P < 4; P++) {
                        var O = N[P];
                        N[P] = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360
                    }
                    return F
                },
                clone: function() {
                    var v = o.clone.call(this);
                    return v._hash = this._hash.clone(),
                    v
                }
            });
            function u(v, E, D, S, w, M, F) {
                var N = v + (E & D | ~E & S) + w + F;
                return (N << M | N >>> 32 - M) + E
            }
            function l(v, E, D, S, w, M, F) {
                var N = v + (E & S | D & ~S) + w + F;
                return (N << M | N >>> 32 - M) + E
            }
            function d(v, E, D, S, w, M, F) {
                var N = v + (E ^ D ^ S) + w + F;
                return (N << M | N >>> 32 - M) + E
            }
            function y(v, E, D, S, w, M, F) {
                var N = v + (D ^ (E | ~S)) + w + F;
                return (N << M | N >>> 32 - M) + E
            }
            n.MD5 = o._createHelper(c),
            n.HmacMD5 = o._createHmacHelper(c)
        }(Math),
        t.MD5
    })
}
);
var Sv = Ce((lh,EA)=>{
    "use strict";
    (function(t, e) {
        typeof lh == "object" ? EA.exports = lh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(lh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.WordArray
              , i = n.Hasher
              , o = e.algo
              , s = []
              , a = o.SHA1 = i.extend({
                _doReset: function() {
                    this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                },
                _doProcessBlock: function(c, u) {
                    for (var l = this._hash.words, d = l[0], y = l[1], v = l[2], E = l[3], D = l[4], S = 0; S < 80; S++) {
                        if (S < 16)
                            s[S] = c[u + S] | 0;
                        else {
                            var w = s[S - 3] ^ s[S - 8] ^ s[S - 14] ^ s[S - 16];
                            s[S] = w << 1 | w >>> 31
                        }
                        var M = (d << 5 | d >>> 27) + D + s[S];
                        S < 20 ? M += (y & v | ~y & E) + 1518500249 : S < 40 ? M += (y ^ v ^ E) + 1859775393 : S < 60 ? M += (y & v | y & E | v & E) - 1894007588 : M += (y ^ v ^ E) - 899497514,
                        D = E,
                        E = v,
                        v = y << 30 | y >>> 2,
                        y = d,
                        d = M
                    }
                    l[0] = l[0] + d | 0,
                    l[1] = l[1] + y | 0,
                    l[2] = l[2] + v | 0,
                    l[3] = l[3] + E | 0,
                    l[4] = l[4] + D | 0
                },
                _doFinalize: function() {
                    var c = this._data
                      , u = c.words
                      , l = this._nDataBytes * 8
                      , d = c.sigBytes * 8;
                    return u[d >>> 5] |= 128 << 24 - d % 32,
                    u[(d + 64 >>> 9 << 4) + 14] = Math.floor(l / 4294967296),
                    u[(d + 64 >>> 9 << 4) + 15] = l,
                    c.sigBytes = u.length * 4,
                    this._process(),
                    this._hash
                },
                clone: function() {
                    var c = i.clone.call(this);
                    return c._hash = this._hash.clone(),
                    c
                }
            });
            e.SHA1 = i._createHelper(a),
            e.HmacSHA1 = i._createHmacHelper(a)
        }(),
        t.SHA1
    })
}
);
var dh = Ce((fh,CA)=>{
    "use strict";
    (function(t, e) {
        typeof fh == "object" ? CA.exports = fh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(fh, function(t) {
        return function(e) {
            var n = t
              , r = n.lib
              , i = r.WordArray
              , o = r.Hasher
              , s = n.algo
              , a = []
              , c = [];
            (function() {
                function d(D) {
                    for (var S = e.sqrt(D), w = 2; w <= S; w++)
                        if (!(D % w))
                            return !1;
                    return !0
                }
                function y(D) {
                    return (D - (D | 0)) * 4294967296 | 0
                }
                for (var v = 2, E = 0; E < 64; )
                    d(v) && (E < 8 && (a[E] = y(e.pow(v, 1 / 2))),
                    c[E] = y(e.pow(v, 1 / 3)),
                    E++),
                    v++
            }
            )();
            var u = []
              , l = s.SHA256 = o.extend({
                _doReset: function() {
                    this._hash = new i.init(a.slice(0))
                },
                _doProcessBlock: function(d, y) {
                    for (var v = this._hash.words, E = v[0], D = v[1], S = v[2], w = v[3], M = v[4], F = v[5], N = v[6], P = v[7], O = 0; O < 64; O++) {
                        if (O < 16)
                            u[O] = d[y + O] | 0;
                        else {
                            var z = u[O - 15]
                              , q = (z << 25 | z >>> 7) ^ (z << 14 | z >>> 18) ^ z >>> 3
                              , J = u[O - 2]
                              , te = (J << 15 | J >>> 17) ^ (J << 13 | J >>> 19) ^ J >>> 10;
                            u[O] = q + u[O - 7] + te + u[O - 16]
                        }
                        var V = M & F ^ ~M & N
                          , Q = E & D ^ E & S ^ D & S
                          , T = (E << 30 | E >>> 2) ^ (E << 19 | E >>> 13) ^ (E << 10 | E >>> 22)
                          , f = (M << 26 | M >>> 6) ^ (M << 21 | M >>> 11) ^ (M << 7 | M >>> 25)
                          , g = P + f + V + c[O] + u[O]
                          , x = T + Q;
                        P = N,
                        N = F,
                        F = M,
                        M = w + g | 0,
                        w = S,
                        S = D,
                        D = E,
                        E = g + x | 0
                    }
                    v[0] = v[0] + E | 0,
                    v[1] = v[1] + D | 0,
                    v[2] = v[2] + S | 0,
                    v[3] = v[3] + w | 0,
                    v[4] = v[4] + M | 0,
                    v[5] = v[5] + F | 0,
                    v[6] = v[6] + N | 0,
                    v[7] = v[7] + P | 0
                },
                _doFinalize: function() {
                    var d = this._data
                      , y = d.words
                      , v = this._nDataBytes * 8
                      , E = d.sigBytes * 8;
                    return y[E >>> 5] |= 128 << 24 - E % 32,
                    y[(E + 64 >>> 9 << 4) + 14] = e.floor(v / 4294967296),
                    y[(E + 64 >>> 9 << 4) + 15] = v,
                    d.sigBytes = y.length * 4,
                    this._process(),
                    this._hash
                },
                clone: function() {
                    var d = o.clone.call(this);
                    return d._hash = this._hash.clone(),
                    d
                }
            });
            n.SHA256 = o._createHelper(l),
            n.HmacSHA256 = o._createHmacHelper(l)
        }(Math),
        t.SHA256
    })
}
);
var IA = Ce((hh,DA)=>{
    "use strict";
    (function(t, e, n) {
        typeof hh == "object" ? DA.exports = hh = e(Ge(), dh()) : typeof define == "function" && define.amd ? define(["./core", "./sha256"], e) : e(t.CryptoJS)
    }
    )(hh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.WordArray
              , i = e.algo
              , o = i.SHA256
              , s = i.SHA224 = o.extend({
                _doReset: function() {
                    this._hash = new r.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                },
                _doFinalize: function() {
                    var a = o._doFinalize.call(this);
                    return a.sigBytes -= 4,
                    a
                }
            });
            e.SHA224 = o._createHelper(s),
            e.HmacSHA224 = o._createHmacHelper(s)
        }(),
        t.SHA224
    })
}
);
var Mv = Ce((ph,AA)=>{
    "use strict";
    (function(t, e, n) {
        typeof ph == "object" ? AA.exports = ph = e(Ge(), fu()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core"], e) : e(t.CryptoJS)
    }
    )(ph, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.Hasher
              , i = e.x64
              , o = i.Word
              , s = i.WordArray
              , a = e.algo;
            function c() {
                return o.create.apply(o, arguments)
            }
            var u = [c(1116352408, 3609767458), c(1899447441, 602891725), c(3049323471, 3964484399), c(3921009573, 2173295548), c(961987163, 4081628472), c(1508970993, 3053834265), c(2453635748, 2937671579), c(2870763221, 3664609560), c(3624381080, 2734883394), c(310598401, 1164996542), c(607225278, 1323610764), c(1426881987, 3590304994), c(1925078388, 4068182383), c(2162078206, 991336113), c(2614888103, 633803317), c(3248222580, 3479774868), c(3835390401, 2666613458), c(4022224774, 944711139), c(264347078, 2341262773), c(604807628, 2007800933), c(770255983, 1495990901), c(1249150122, 1856431235), c(1555081692, 3175218132), c(1996064986, 2198950837), c(2554220882, 3999719339), c(2821834349, 766784016), c(2952996808, 2566594879), c(3210313671, 3203337956), c(3336571891, 1034457026), c(3584528711, 2466948901), c(113926993, 3758326383), c(338241895, 168717936), c(666307205, 1188179964), c(773529912, 1546045734), c(1294757372, 1522805485), c(1396182291, 2643833823), c(1695183700, 2343527390), c(1986661051, 1014477480), c(2177026350, 1206759142), c(2456956037, 344077627), c(2730485921, 1290863460), c(2820302411, 3158454273), c(3259730800, 3505952657), c(3345764771, 106217008), c(3516065817, 3606008344), c(3600352804, 1432725776), c(4094571909, 1467031594), c(275423344, 851169720), c(430227734, 3100823752), c(506948616, 1363258195), c(659060556, 3750685593), c(883997877, 3785050280), c(958139571, 3318307427), c(1322822218, 3812723403), c(1537002063, 2003034995), c(1747873779, 3602036899), c(1955562222, 1575990012), c(2024104815, 1125592928), c(2227730452, 2716904306), c(2361852424, 442776044), c(2428436474, 593698344), c(2756734187, 3733110249), c(3204031479, 2999351573), c(3329325298, 3815920427), c(3391569614, 3928383900), c(3515267271, 566280711), c(3940187606, 3454069534), c(4118630271, 4000239992), c(116418474, 1914138554), c(174292421, 2731055270), c(289380356, 3203993006), c(460393269, 320620315), c(685471733, 587496836), c(852142971, 1086792851), c(1017036298, 365543100), c(1126000580, 2618297676), c(1288033470, 3409855158), c(1501505948, 4234509866), c(1607167915, 987167468), c(1816402316, 1246189591)]
              , l = [];
            (function() {
                for (var y = 0; y < 80; y++)
                    l[y] = c()
            }
            )();
            var d = a.SHA512 = r.extend({
                _doReset: function() {
                    this._hash = new s.init([new o.init(1779033703,4089235720), new o.init(3144134277,2227873595), new o.init(1013904242,4271175723), new o.init(2773480762,1595750129), new o.init(1359893119,2917565137), new o.init(2600822924,725511199), new o.init(528734635,4215389547), new o.init(1541459225,327033209)])
                },
                _doProcessBlock: function(y, v) {
                    for (var E = this._hash.words, D = E[0], S = E[1], w = E[2], M = E[3], F = E[4], N = E[5], P = E[6], O = E[7], z = D.high, q = D.low, J = S.high, te = S.low, V = w.high, Q = w.low, T = M.high, f = M.low, g = F.high, x = F.low, I = N.high, A = N.low, C = P.high, k = P.low, b = O.high, h = O.low, B = z, Y = q, ne = J, K = te, se = V, de = Q, xe = T, Ke = f, ye = g, pe = x, ot = I, Fe = A, Ye = C, yn = k, st = b, ft = h, on = 0; on < 80; on++) {
                        var je, ze, jt = l[on];
                        if (on < 16)
                            ze = jt.high = y[v + on * 2] | 0,
                            je = jt.low = y[v + on * 2 + 1] | 0;
                        else {
                            var dt = l[on - 15]
                              , nt = dt.high
                              , $t = dt.low
                              , vt = (nt >>> 1 | $t << 31) ^ (nt >>> 8 | $t << 24) ^ nt >>> 7
                              , _ = ($t >>> 1 | nt << 31) ^ ($t >>> 8 | nt << 24) ^ ($t >>> 7 | nt << 25)
                              , p = l[on - 2]
                              , m = p.high
                              , R = p.low
                              , U = (m >>> 19 | R << 13) ^ (m << 3 | R >>> 29) ^ m >>> 6
                              , j = (R >>> 19 | m << 13) ^ (R << 3 | m >>> 29) ^ (R >>> 6 | m << 26)
                              , G = l[on - 7]
                              , Be = G.high
                              , ke = G.low
                              , Ae = l[on - 16]
                              , xt = Ae.high
                              , Ee = Ae.low;
                            je = _ + ke,
                            ze = vt + Be + (je >>> 0 < _ >>> 0 ? 1 : 0),
                            je = je + j,
                            ze = ze + U + (je >>> 0 < j >>> 0 ? 1 : 0),
                            je = je + Ee,
                            ze = ze + xt + (je >>> 0 < Ee >>> 0 ? 1 : 0),
                            jt.high = ze,
                            jt.low = je
                        }
                        var Bt = ye & ot ^ ~ye & Ye
                          , _a = pe & Fe ^ ~pe & yn
                          , Rt = B & ne ^ B & se ^ ne & se
                          , Ft = Y & K ^ Y & de ^ K & de
                          , du = (B >>> 28 | Y << 4) ^ (B << 30 | Y >>> 2) ^ (B << 25 | Y >>> 7)
                          , _t = (Y >>> 28 | B << 4) ^ (Y << 30 | B >>> 2) ^ (Y << 25 | B >>> 7)
                          , Nt = (ye >>> 14 | pe << 18) ^ (ye >>> 18 | pe << 14) ^ (ye << 23 | pe >>> 9)
                          , hu = (pe >>> 14 | ye << 18) ^ (pe >>> 18 | ye << 14) ^ (pe << 23 | ye >>> 9)
                          , St = u[on]
                          , Pt = St.high
                          , Sa = St.low
                          , Xe = ft + hu
                          , gt = st + Nt + (Xe >>> 0 < ft >>> 0 ? 1 : 0)
                          , Xe = Xe + _a
                          , gt = gt + Bt + (Xe >>> 0 < _a >>> 0 ? 1 : 0)
                          , Xe = Xe + Sa
                          , gt = gt + Pt + (Xe >>> 0 < Sa >>> 0 ? 1 : 0)
                          , Xe = Xe + je
                          , gt = gt + ze + (Xe >>> 0 < je >>> 0 ? 1 : 0)
                          , Ma = _t + Ft
                          , Ot = du + Rt + (Ma >>> 0 < _t >>> 0 ? 1 : 0);
                        st = Ye,
                        ft = yn,
                        Ye = ot,
                        yn = Fe,
                        ot = ye,
                        Fe = pe,
                        pe = Ke + Xe | 0,
                        ye = xe + gt + (pe >>> 0 < Ke >>> 0 ? 1 : 0) | 0,
                        xe = se,
                        Ke = de,
                        se = ne,
                        de = K,
                        ne = B,
                        K = Y,
                        Y = Xe + Ma | 0,
                        B = gt + Ot + (Y >>> 0 < Xe >>> 0 ? 1 : 0) | 0
                    }
                    q = D.low = q + Y,
                    D.high = z + B + (q >>> 0 < Y >>> 0 ? 1 : 0),
                    te = S.low = te + K,
                    S.high = J + ne + (te >>> 0 < K >>> 0 ? 1 : 0),
                    Q = w.low = Q + de,
                    w.high = V + se + (Q >>> 0 < de >>> 0 ? 1 : 0),
                    f = M.low = f + Ke,
                    M.high = T + xe + (f >>> 0 < Ke >>> 0 ? 1 : 0),
                    x = F.low = x + pe,
                    F.high = g + ye + (x >>> 0 < pe >>> 0 ? 1 : 0),
                    A = N.low = A + Fe,
                    N.high = I + ot + (A >>> 0 < Fe >>> 0 ? 1 : 0),
                    k = P.low = k + yn,
                    P.high = C + Ye + (k >>> 0 < yn >>> 0 ? 1 : 0),
                    h = O.low = h + ft,
                    O.high = b + st + (h >>> 0 < ft >>> 0 ? 1 : 0)
                },
                _doFinalize: function() {
                    var y = this._data
                      , v = y.words
                      , E = this._nDataBytes * 8
                      , D = y.sigBytes * 8;
                    v[D >>> 5] |= 128 << 24 - D % 32,
                    v[(D + 128 >>> 10 << 5) + 30] = Math.floor(E / 4294967296),
                    v[(D + 128 >>> 10 << 5) + 31] = E,
                    y.sigBytes = v.length * 4,
                    this._process();
                    var S = this._hash.toX32();
                    return S
                },
                clone: function() {
                    var y = r.clone.call(this);
                    return y._hash = this._hash.clone(),
                    y
                },
                blockSize: 1024 / 32
            });
            e.SHA512 = r._createHelper(d),
            e.HmacSHA512 = r._createHmacHelper(d)
        }(),
        t.SHA512
    })
}
);
var SA = Ce((gh,_A)=>{
    "use strict";
    (function(t, e, n) {
        typeof gh == "object" ? _A.exports = gh = e(Ge(), fu(), Mv()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core", "./sha512"], e) : e(t.CryptoJS)
    }
    )(gh, function(t) {
        return function() {
            var e = t
              , n = e.x64
              , r = n.Word
              , i = n.WordArray
              , o = e.algo
              , s = o.SHA512
              , a = o.SHA384 = s.extend({
                _doReset: function() {
                    this._hash = new i.init([new r.init(3418070365,3238371032), new r.init(1654270250,914150663), new r.init(2438529370,812702999), new r.init(355462360,4144912697), new r.init(1731405415,4290775857), new r.init(2394180231,1750603025), new r.init(3675008525,1694076839), new r.init(1203062813,3204075428)])
                },
                _doFinalize: function() {
                    var c = s._doFinalize.call(this);
                    return c.sigBytes -= 16,
                    c
                }
            });
            e.SHA384 = s._createHelper(a),
            e.HmacSHA384 = s._createHmacHelper(a)
        }(),
        t.SHA384
    })
}
);
var kA = Ce((mh,MA)=>{
    "use strict";
    (function(t, e, n) {
        typeof mh == "object" ? MA.exports = mh = e(Ge(), fu()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core"], e) : e(t.CryptoJS)
    }
    )(mh, function(t) {
        return function(e) {
            var n = t
              , r = n.lib
              , i = r.WordArray
              , o = r.Hasher
              , s = n.x64
              , a = s.Word
              , c = n.algo
              , u = []
              , l = []
              , d = [];
            (function() {
                for (var E = 1, D = 0, S = 0; S < 24; S++) {
                    u[E + 5 * D] = (S + 1) * (S + 2) / 2 % 64;
                    var w = D % 5
                      , M = (2 * E + 3 * D) % 5;
                    E = w,
                    D = M
                }
                for (var E = 0; E < 5; E++)
                    for (var D = 0; D < 5; D++)
                        l[E + 5 * D] = D + (2 * E + 3 * D) % 5 * 5;
                for (var F = 1, N = 0; N < 24; N++) {
                    for (var P = 0, O = 0, z = 0; z < 7; z++) {
                        if (F & 1) {
                            var q = (1 << z) - 1;
                            q < 32 ? O ^= 1 << q : P ^= 1 << q - 32
                        }
                        F & 128 ? F = F << 1 ^ 113 : F <<= 1
                    }
                    d[N] = a.create(P, O)
                }
            }
            )();
            var y = [];
            (function() {
                for (var E = 0; E < 25; E++)
                    y[E] = a.create()
            }
            )();
            var v = c.SHA3 = o.extend({
                cfg: o.cfg.extend({
                    outputLength: 512
                }),
                _doReset: function() {
                    for (var E = this._state = [], D = 0; D < 25; D++)
                        E[D] = new a.init;
                    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                },
                _doProcessBlock: function(E, D) {
                    for (var S = this._state, w = this.blockSize / 2, M = 0; M < w; M++) {
                        var F = E[D + 2 * M]
                          , N = E[D + 2 * M + 1];
                        F = (F << 8 | F >>> 24) & 16711935 | (F << 24 | F >>> 8) & 4278255360,
                        N = (N << 8 | N >>> 24) & 16711935 | (N << 24 | N >>> 8) & 4278255360;
                        var P = S[M];
                        P.high ^= N,
                        P.low ^= F
                    }
                    for (var O = 0; O < 24; O++) {
                        for (var z = 0; z < 5; z++) {
                            for (var q = 0, J = 0, te = 0; te < 5; te++) {
                                var P = S[z + 5 * te];
                                q ^= P.high,
                                J ^= P.low
                            }
                            var V = y[z];
                            V.high = q,
                            V.low = J
                        }
                        for (var z = 0; z < 5; z++)
                            for (var Q = y[(z + 4) % 5], T = y[(z + 1) % 5], f = T.high, g = T.low, q = Q.high ^ (f << 1 | g >>> 31), J = Q.low ^ (g << 1 | f >>> 31), te = 0; te < 5; te++) {
                                var P = S[z + 5 * te];
                                P.high ^= q,
                                P.low ^= J
                            }
                        for (var x = 1; x < 25; x++) {
                            var q, J, P = S[x], I = P.high, A = P.low, C = u[x];
                            C < 32 ? (q = I << C | A >>> 32 - C,
                            J = A << C | I >>> 32 - C) : (q = A << C - 32 | I >>> 64 - C,
                            J = I << C - 32 | A >>> 64 - C);
                            var k = y[l[x]];
                            k.high = q,
                            k.low = J
                        }
                        var b = y[0]
                          , h = S[0];
                        b.high = h.high,
                        b.low = h.low;
                        for (var z = 0; z < 5; z++)
                            for (var te = 0; te < 5; te++) {
                                var x = z + 5 * te
                                  , P = S[x]
                                  , B = y[x]
                                  , Y = y[(z + 1) % 5 + 5 * te]
                                  , ne = y[(z + 2) % 5 + 5 * te];
                                P.high = B.high ^ ~Y.high & ne.high,
                                P.low = B.low ^ ~Y.low & ne.low
                            }
                        var P = S[0]
                          , K = d[O];
                        P.high ^= K.high,
                        P.low ^= K.low
                    }
                },
                _doFinalize: function() {
                    var E = this._data
                      , D = E.words
                      , S = this._nDataBytes * 8
                      , w = E.sigBytes * 8
                      , M = this.blockSize * 32;
                    D[w >>> 5] |= 1 << 24 - w % 32,
                    D[(e.ceil((w + 1) / M) * M >>> 5) - 1] |= 128,
                    E.sigBytes = D.length * 4,
                    this._process();
                    for (var F = this._state, N = this.cfg.outputLength / 8, P = N / 8, O = [], z = 0; z < P; z++) {
                        var q = F[z]
                          , J = q.high
                          , te = q.low;
                        J = (J << 8 | J >>> 24) & 16711935 | (J << 24 | J >>> 8) & 4278255360,
                        te = (te << 8 | te >>> 24) & 16711935 | (te << 24 | te >>> 8) & 4278255360,
                        O.push(te),
                        O.push(J)
                    }
                    return new i.init(O,N)
                },
                clone: function() {
                    for (var E = o.clone.call(this), D = E._state = this._state.slice(0), S = 0; S < 25; S++)
                        D[S] = D[S].clone();
                    return E
                }
            });
            n.SHA3 = o._createHelper(v),
            n.HmacSHA3 = o._createHmacHelper(v)
        }(Math),
        t.SHA3
    })
}
);
var BA = Ce((yh,TA)=>{
    "use strict";
    (function(t, e) {
        typeof yh == "object" ? TA.exports = yh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(yh, function(t) {
        return function(e) {
            var n = t
              , r = n.lib
              , i = r.WordArray
              , o = r.Hasher
              , s = n.algo
              , a = i.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13])
              , c = i.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11])
              , u = i.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6])
              , l = i.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11])
              , d = i.create([0, 1518500249, 1859775393, 2400959708, 2840853838])
              , y = i.create([1352829926, 1548603684, 1836072691, 2053994217, 0])
              , v = s.RIPEMD160 = o.extend({
                _doReset: function() {
                    this._hash = i.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                },
                _doProcessBlock: function(N, P) {
                    for (var O = 0; O < 16; O++) {
                        var z = P + O
                          , q = N[z];
                        N[z] = (q << 8 | q >>> 24) & 16711935 | (q << 24 | q >>> 8) & 4278255360
                    }
                    var J = this._hash.words, te = d.words, V = y.words, Q = a.words, T = c.words, f = u.words, g = l.words, x, I, A, C, k, b, h, B, Y, ne;
                    b = x = J[0],
                    h = I = J[1],
                    B = A = J[2],
                    Y = C = J[3],
                    ne = k = J[4];
                    for (var K, O = 0; O < 80; O += 1)
                        K = x + N[P + Q[O]] | 0,
                        O < 16 ? K += E(I, A, C) + te[0] : O < 32 ? K += D(I, A, C) + te[1] : O < 48 ? K += S(I, A, C) + te[2] : O < 64 ? K += w(I, A, C) + te[3] : K += M(I, A, C) + te[4],
                        K = K | 0,
                        K = F(K, f[O]),
                        K = K + k | 0,
                        x = k,
                        k = C,
                        C = F(A, 10),
                        A = I,
                        I = K,
                        K = b + N[P + T[O]] | 0,
                        O < 16 ? K += M(h, B, Y) + V[0] : O < 32 ? K += w(h, B, Y) + V[1] : O < 48 ? K += S(h, B, Y) + V[2] : O < 64 ? K += D(h, B, Y) + V[3] : K += E(h, B, Y) + V[4],
                        K = K | 0,
                        K = F(K, g[O]),
                        K = K + ne | 0,
                        b = ne,
                        ne = Y,
                        Y = F(B, 10),
                        B = h,
                        h = K;
                    K = J[1] + A + Y | 0,
                    J[1] = J[2] + C + ne | 0,
                    J[2] = J[3] + k + b | 0,
                    J[3] = J[4] + x + h | 0,
                    J[4] = J[0] + I + B | 0,
                    J[0] = K
                },
                _doFinalize: function() {
                    var N = this._data
                      , P = N.words
                      , O = this._nDataBytes * 8
                      , z = N.sigBytes * 8;
                    P[z >>> 5] |= 128 << 24 - z % 32,
                    P[(z + 64 >>> 9 << 4) + 14] = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360,
                    N.sigBytes = (P.length + 1) * 4,
                    this._process();
                    for (var q = this._hash, J = q.words, te = 0; te < 5; te++) {
                        var V = J[te];
                        J[te] = (V << 8 | V >>> 24) & 16711935 | (V << 24 | V >>> 8) & 4278255360
                    }
                    return q
                },
                clone: function() {
                    var N = o.clone.call(this);
                    return N._hash = this._hash.clone(),
                    N
                }
            });
            function E(N, P, O) {
                return N ^ P ^ O
            }
            function D(N, P, O) {
                return N & P | ~N & O
            }
            function S(N, P, O) {
                return (N | ~P) ^ O
            }
            function w(N, P, O) {
                return N & O | P & ~O
            }
            function M(N, P, O) {
                return N ^ (P | ~O)
            }
            function F(N, P) {
                return N << P | N >>> 32 - P
            }
            n.RIPEMD160 = o._createHelper(v),
            n.HmacRIPEMD160 = o._createHmacHelper(v)
        }(Math),
        t.RIPEMD160
    })
}
);
var xh = Ce((vh,RA)=>{
    "use strict";
    (function(t, e) {
        typeof vh == "object" ? RA.exports = vh = e(Ge()) : typeof define == "function" && define.amd ? define(["./core"], e) : e(t.CryptoJS)
    }
    )(vh, function(t) {
        (function() {
            var e = t
              , n = e.lib
              , r = n.Base
              , i = e.enc
              , o = i.Utf8
              , s = e.algo
              , a = s.HMAC = r.extend({
                init: function(c, u) {
                    c = this._hasher = new c.init,
                    typeof u == "string" && (u = o.parse(u));
                    var l = c.blockSize
                      , d = l * 4;
                    u.sigBytes > d && (u = c.finalize(u)),
                    u.clamp();
                    for (var y = this._oKey = u.clone(), v = this._iKey = u.clone(), E = y.words, D = v.words, S = 0; S < l; S++)
                        E[S] ^= 1549556828,
                        D[S] ^= 909522486;
                    y.sigBytes = v.sigBytes = d,
                    this.reset()
                },
                reset: function() {
                    var c = this._hasher;
                    c.reset(),
                    c.update(this._iKey)
                },
                update: function(c) {
                    return this._hasher.update(c),
                    this
                },
                finalize: function(c) {
                    var u = this._hasher
                      , l = u.finalize(c);
                    u.reset();
                    var d = u.finalize(this._oKey.clone().concat(l));
                    return d
                }
            })
        }
        )()
    })
}
);
var NA = Ce((wh,FA)=>{
    "use strict";
    (function(t, e, n) {
        typeof wh == "object" ? FA.exports = wh = e(Ge(), dh(), xh()) : typeof define == "function" && define.amd ? define(["./core", "./sha256", "./hmac"], e) : e(t.CryptoJS)
    }
    )(wh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.Base
              , i = n.WordArray
              , o = e.algo
              , s = o.SHA256
              , a = o.HMAC
              , c = o.PBKDF2 = r.extend({
                cfg: r.extend({
                    keySize: 128 / 32,
                    hasher: s,
                    iterations: 25e4
                }),
                init: function(u) {
                    this.cfg = this.cfg.extend(u)
                },
                compute: function(u, l) {
                    for (var d = this.cfg, y = a.create(d.hasher, u), v = i.create(), E = i.create([1]), D = v.words, S = E.words, w = d.keySize, M = d.iterations; D.length < w; ) {
                        var F = y.update(l).finalize(E);
                        y.reset();
                        for (var N = F.words, P = N.length, O = F, z = 1; z < M; z++) {
                            O = y.finalize(O),
                            y.reset();
                            for (var q = O.words, J = 0; J < P; J++)
                                N[J] ^= q[J]
                        }
                        v.concat(F),
                        S[0]++
                    }
                    return v.sigBytes = w * 4,
                    v
                }
            });
            e.PBKDF2 = function(u, l, d) {
                return c.create(d).compute(u, l)
            }
        }(),
        t.PBKDF2
    })
}
);
var Ti = Ce((bh,PA)=>{
    "use strict";
    (function(t, e, n) {
        typeof bh == "object" ? PA.exports = bh = e(Ge(), Sv(), xh()) : typeof define == "function" && define.amd ? define(["./core", "./sha1", "./hmac"], e) : e(t.CryptoJS)
    }
    )(bh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.Base
              , i = n.WordArray
              , o = e.algo
              , s = o.MD5
              , a = o.EvpKDF = r.extend({
                cfg: r.extend({
                    keySize: 128 / 32,
                    hasher: s,
                    iterations: 1
                }),
                init: function(c) {
                    this.cfg = this.cfg.extend(c)
                },
                compute: function(c, u) {
                    for (var l, d = this.cfg, y = d.hasher.create(), v = i.create(), E = v.words, D = d.keySize, S = d.iterations; E.length < D; ) {
                        l && y.update(l),
                        l = y.update(c).finalize(u),
                        y.reset();
                        for (var w = 1; w < S; w++)
                            l = y.finalize(l),
                            y.reset();
                        v.concat(l)
                    }
                    return v.sigBytes = D * 4,
                    v
                }
            });
            e.EvpKDF = function(c, u, l) {
                return a.create(l).compute(c, u)
            }
        }(),
        t.EvpKDF
    })
}
);
var rn = Ce((Eh,OA)=>{
    "use strict";
    (function(t, e, n) {
        typeof Eh == "object" ? OA.exports = Eh = e(Ge(), Ti()) : typeof define == "function" && define.amd ? define(["./core", "./evpkdf"], e) : e(t.CryptoJS)
    }
    )(Eh, function(t) {
        t.lib.Cipher || function(e) {
            var n = t
              , r = n.lib
              , i = r.Base
              , o = r.WordArray
              , s = r.BufferedBlockAlgorithm
              , a = n.enc
              , c = a.Utf8
              , u = a.Base64
              , l = n.algo
              , d = l.EvpKDF
              , y = r.Cipher = s.extend({
                cfg: i.extend(),
                createEncryptor: function(V, Q) {
                    return this.create(this._ENC_XFORM_MODE, V, Q)
                },
                createDecryptor: function(V, Q) {
                    return this.create(this._DEC_XFORM_MODE, V, Q)
                },
                init: function(V, Q, T) {
                    this.cfg = this.cfg.extend(T),
                    this._xformMode = V,
                    this._key = Q,
                    this.reset()
                },
                reset: function() {
                    s.reset.call(this),
                    this._doReset()
                },
                process: function(V) {
                    return this._append(V),
                    this._process()
                },
                finalize: function(V) {
                    V && this._append(V);
                    var Q = this._doFinalize();
                    return Q
                },
                keySize: 128 / 32,
                ivSize: 128 / 32,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: function() {
                    function V(Q) {
                        return typeof Q == "string" ? te : z
                    }
                    return function(Q) {
                        return {
                            encrypt: function(T, f, g) {
                                return V(f).encrypt(Q, T, f, g)
                            },
                            decrypt: function(T, f, g) {
                                return V(f).decrypt(Q, T, f, g)
                            }
                        }
                    }
                }()
            })
              , v = r.StreamCipher = y.extend({
                _doFinalize: function() {
                    var V = this._process(!0);
                    return V
                },
                blockSize: 1
            })
              , E = n.mode = {}
              , D = r.BlockCipherMode = i.extend({
                createEncryptor: function(V, Q) {
                    return this.Encryptor.create(V, Q)
                },
                createDecryptor: function(V, Q) {
                    return this.Decryptor.create(V, Q)
                },
                init: function(V, Q) {
                    this._cipher = V,
                    this._iv = Q
                }
            })
              , S = E.CBC = function() {
                var V = D.extend();
                V.Encryptor = V.extend({
                    processBlock: function(T, f) {
                        var g = this._cipher
                          , x = g.blockSize;
                        Q.call(this, T, f, x),
                        g.encryptBlock(T, f),
                        this._prevBlock = T.slice(f, f + x)
                    }
                }),
                V.Decryptor = V.extend({
                    processBlock: function(T, f) {
                        var g = this._cipher
                          , x = g.blockSize
                          , I = T.slice(f, f + x);
                        g.decryptBlock(T, f),
                        Q.call(this, T, f, x),
                        this._prevBlock = I
                    }
                });
                function Q(T, f, g) {
                    var x, I = this._iv;
                    I ? (x = I,
                    this._iv = e) : x = this._prevBlock;
                    for (var A = 0; A < g; A++)
                        T[f + A] ^= x[A]
                }
                return V
            }()
              , w = n.pad = {}
              , M = w.Pkcs7 = {
                pad: function(V, Q) {
                    for (var T = Q * 4, f = T - V.sigBytes % T, g = f << 24 | f << 16 | f << 8 | f, x = [], I = 0; I < f; I += 4)
                        x.push(g);
                    var A = o.create(x, f);
                    V.concat(A)
                },
                unpad: function(V) {
                    var Q = V.words[V.sigBytes - 1 >>> 2] & 255;
                    V.sigBytes -= Q
                }
            }
              , F = r.BlockCipher = y.extend({
                cfg: y.cfg.extend({
                    mode: S,
                    padding: M
                }),
                reset: function() {
                    var V;
                    y.reset.call(this);
                    var Q = this.cfg
                      , T = Q.iv
                      , f = Q.mode;
                    this._xformMode == this._ENC_XFORM_MODE ? V = f.createEncryptor : (V = f.createDecryptor,
                    this._minBufferSize = 1),
                    this._mode && this._mode.__creator == V ? this._mode.init(this, T && T.words) : (this._mode = V.call(f, this, T && T.words),
                    this._mode.__creator = V)
                },
                _doProcessBlock: function(V, Q) {
                    this._mode.processBlock(V, Q)
                },
                _doFinalize: function() {
                    var V, Q = this.cfg.padding;
                    return this._xformMode == this._ENC_XFORM_MODE ? (Q.pad(this._data, this.blockSize),
                    V = this._process(!0)) : (V = this._process(!0),
                    Q.unpad(V)),
                    V
                },
                blockSize: 128 / 32
            })
              , N = r.CipherParams = i.extend({
                init: function(V) {
                    this.mixIn(V)
                },
                toString: function(V) {
                    return (V || this.formatter).stringify(this)
                }
            })
              , P = n.format = {}
              , O = P.OpenSSL = {
                stringify: function(V) {
                    var Q, T = V.ciphertext, f = V.salt;
                    return f ? Q = o.create([1398893684, 1701076831]).concat(f).concat(T) : Q = T,
                    Q.toString(u)
                },
                parse: function(V) {
                    var Q, T = u.parse(V), f = T.words;
                    return f[0] == 1398893684 && f[1] == 1701076831 && (Q = o.create(f.slice(2, 4)),
                    f.splice(0, 4),
                    T.sigBytes -= 16),
                    N.create({
                        ciphertext: T,
                        salt: Q
                    })
                }
            }
              , z = r.SerializableCipher = i.extend({
                cfg: i.extend({
                    format: O
                }),
                encrypt: function(V, Q, T, f) {
                    f = this.cfg.extend(f);
                    var g = V.createEncryptor(T, f)
                      , x = g.finalize(Q)
                      , I = g.cfg;
                    return N.create({
                        ciphertext: x,
                        key: T,
                        iv: I.iv,
                        algorithm: V,
                        mode: I.mode,
                        padding: I.padding,
                        blockSize: V.blockSize,
                        formatter: f.format
                    })
                },
                decrypt: function(V, Q, T, f) {
                    f = this.cfg.extend(f),
                    Q = this._parse(Q, f.format);
                    var g = V.createDecryptor(T, f).finalize(Q.ciphertext);
                    return g
                },
                _parse: function(V, Q) {
                    return typeof V == "string" ? Q.parse(V, this) : V
                }
            })
              , q = n.kdf = {}
              , J = q.OpenSSL = {
                execute: function(V, Q, T, f, g) {
                    if (f || (f = o.random(64 / 8)),
                    g)
                        var x = d.create({
                            keySize: Q + T,
                            hasher: g
                        }).compute(V, f);
                    else
                        var x = d.create({
                            keySize: Q + T
                        }).compute(V, f);
                    var I = o.create(x.words.slice(Q), T * 4);
                    return x.sigBytes = Q * 4,
                    N.create({
                        key: x,
                        iv: I,
                        salt: f
                    })
                }
            }
              , te = r.PasswordBasedCipher = z.extend({
                cfg: z.cfg.extend({
                    kdf: J
                }),
                encrypt: function(V, Q, T, f) {
                    f = this.cfg.extend(f);
                    var g = f.kdf.execute(T, V.keySize, V.ivSize, f.salt, f.hasher);
                    f.iv = g.iv;
                    var x = z.encrypt.call(this, V, Q, g.key, f);
                    return x.mixIn(g),
                    x
                },
                decrypt: function(V, Q, T, f) {
                    f = this.cfg.extend(f),
                    Q = this._parse(Q, f.format);
                    var g = f.kdf.execute(T, V.keySize, V.ivSize, Q.salt, f.hasher);
                    f.iv = g.iv;
                    var x = z.decrypt.call(this, V, Q, g.key, f);
                    return x
                }
            })
        }()
    })
}
);
var UA = Ce((Ch,LA)=>{
    "use strict";
    (function(t, e, n) {
        typeof Ch == "object" ? LA.exports = Ch = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Ch, function(t) {
        return t.mode.CFB = function() {
            var e = t.lib.BlockCipherMode.extend();
            e.Encryptor = e.extend({
                processBlock: function(r, i) {
                    var o = this._cipher
                      , s = o.blockSize;
                    n.call(this, r, i, s, o),
                    this._prevBlock = r.slice(i, i + s)
                }
            }),
            e.Decryptor = e.extend({
                processBlock: function(r, i) {
                    var o = this._cipher
                      , s = o.blockSize
                      , a = r.slice(i, i + s);
                    n.call(this, r, i, s, o),
                    this._prevBlock = a
                }
            });
            function n(r, i, o, s) {
                var a, c = this._iv;
                c ? (a = c.slice(0),
                this._iv = void 0) : a = this._prevBlock,
                s.encryptBlock(a, 0);
                for (var u = 0; u < o; u++)
                    r[i + u] ^= a[u]
            }
            return e
        }(),
        t.mode.CFB
    })
}
);
var jA = Ce((Dh,VA)=>{
    "use strict";
    (function(t, e, n) {
        typeof Dh == "object" ? VA.exports = Dh = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Dh, function(t) {
        return t.mode.CTR = function() {
            var e = t.lib.BlockCipherMode.extend()
              , n = e.Encryptor = e.extend({
                processBlock: function(r, i) {
                    var o = this._cipher
                      , s = o.blockSize
                      , a = this._iv
                      , c = this._counter;
                    a && (c = this._counter = a.slice(0),
                    this._iv = void 0);
                    var u = c.slice(0);
                    o.encryptBlock(u, 0),
                    c[s - 1] = c[s - 1] + 1 | 0;
                    for (var l = 0; l < s; l++)
                        r[i + l] ^= u[l]
                }
            });
            return e.Decryptor = n,
            e
        }(),
        t.mode.CTR
    })
}
);
var HA = Ce((Ih,$A)=>{
    "use strict";
    (function(t, e, n) {
        typeof Ih == "object" ? $A.exports = Ih = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Ih, function(t) {
        return t.mode.CTRGladman = function() {
            var e = t.lib.BlockCipherMode.extend();
            function n(o) {
                if ((o >> 24 & 255) === 255) {
                    var s = o >> 16 & 255
                      , a = o >> 8 & 255
                      , c = o & 255;
                    s === 255 ? (s = 0,
                    a === 255 ? (a = 0,
                    c === 255 ? c = 0 : ++c) : ++a) : ++s,
                    o = 0,
                    o += s << 16,
                    o += a << 8,
                    o += c
                } else
                    o += 1 << 24;
                return o
            }
            function r(o) {
                return (o[0] = n(o[0])) === 0 && (o[1] = n(o[1])),
                o
            }
            var i = e.Encryptor = e.extend({
                processBlock: function(o, s) {
                    var a = this._cipher
                      , c = a.blockSize
                      , u = this._iv
                      , l = this._counter;
                    u && (l = this._counter = u.slice(0),
                    this._iv = void 0),
                    r(l);
                    var d = l.slice(0);
                    a.encryptBlock(d, 0);
                    for (var y = 0; y < c; y++)
                        o[s + y] ^= d[y]
                }
            });
            return e.Decryptor = i,
            e
        }(),
        t.mode.CTRGladman
    })
}
);
var qA = Ce((Ah,zA)=>{
    "use strict";
    (function(t, e, n) {
        typeof Ah == "object" ? zA.exports = Ah = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Ah, function(t) {
        return t.mode.OFB = function() {
            var e = t.lib.BlockCipherMode.extend()
              , n = e.Encryptor = e.extend({
                processBlock: function(r, i) {
                    var o = this._cipher
                      , s = o.blockSize
                      , a = this._iv
                      , c = this._keystream;
                    a && (c = this._keystream = a.slice(0),
                    this._iv = void 0),
                    o.encryptBlock(c, 0);
                    for (var u = 0; u < s; u++)
                        r[i + u] ^= c[u]
                }
            });
            return e.Decryptor = n,
            e
        }(),
        t.mode.OFB
    })
}
);
var GA = Ce((_h,WA)=>{
    "use strict";
    (function(t, e, n) {
        typeof _h == "object" ? WA.exports = _h = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(_h, function(t) {
        return t.mode.ECB = function() {
            var e = t.lib.BlockCipherMode.extend();
            return e.Encryptor = e.extend({
                processBlock: function(n, r) {
                    this._cipher.encryptBlock(n, r)
                }
            }),
            e.Decryptor = e.extend({
                processBlock: function(n, r) {
                    this._cipher.decryptBlock(n, r)
                }
            }),
            e
        }(),
        t.mode.ECB
    })
}
);
var YA = Ce((Sh,KA)=>{
    "use strict";
    (function(t, e, n) {
        typeof Sh == "object" ? KA.exports = Sh = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Sh, function(t) {
        return t.pad.AnsiX923 = {
            pad: function(e, n) {
                var r = e.sigBytes
                  , i = n * 4
                  , o = i - r % i
                  , s = r + o - 1;
                e.clamp(),
                e.words[s >>> 2] |= o << 24 - s % 4 * 8,
                e.sigBytes += o
            },
            unpad: function(e) {
                var n = e.words[e.sigBytes - 1 >>> 2] & 255;
                e.sigBytes -= n
            }
        },
        t.pad.Ansix923
    })
}
);
var XA = Ce((Mh,ZA)=>{
    "use strict";
    (function(t, e, n) {
        typeof Mh == "object" ? ZA.exports = Mh = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Mh, function(t) {
        return t.pad.Iso10126 = {
            pad: function(e, n) {
                var r = n * 4
                  , i = r - e.sigBytes % r;
                e.concat(t.lib.WordArray.random(i - 1)).concat(t.lib.WordArray.create([i << 24], 1))
            },
            unpad: function(e) {
                var n = e.words[e.sigBytes - 1 >>> 2] & 255;
                e.sigBytes -= n
            }
        },
        t.pad.Iso10126
    })
}
);
var JA = Ce((kh,QA)=>{
    "use strict";
    (function(t, e, n) {
        typeof kh == "object" ? QA.exports = kh = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(kh, function(t) {
        return t.pad.Iso97971 = {
            pad: function(e, n) {
                e.concat(t.lib.WordArray.create([2147483648], 1)),
                t.pad.ZeroPadding.pad(e, n)
            },
            unpad: function(e) {
                t.pad.ZeroPadding.unpad(e),
                e.sigBytes--
            }
        },
        t.pad.Iso97971
    })
}
);
var t_ = Ce((Th,e_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Th == "object" ? e_.exports = Th = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Th, function(t) {
        return t.pad.ZeroPadding = {
            pad: function(e, n) {
                var r = n * 4;
                e.clamp(),
                e.sigBytes += r - (e.sigBytes % r || r)
            },
            unpad: function(e) {
                for (var n = e.words, r = e.sigBytes - 1, r = e.sigBytes - 1; r >= 0; r--)
                    if (n[r >>> 2] >>> 24 - r % 4 * 8 & 255) {
                        e.sigBytes = r + 1;
                        break
                    }
            }
        },
        t.pad.ZeroPadding
    })
}
);
var r_ = Ce((Bh,n_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Bh == "object" ? n_.exports = Bh = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Bh, function(t) {
        return t.pad.NoPadding = {
            pad: function() {},
            unpad: function() {}
        },
        t.pad.NoPadding
    })
}
);
var o_ = Ce((Rh,i_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Rh == "object" ? i_.exports = Rh = e(Ge(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Rh, function(t) {
        return function(e) {
            var n = t
              , r = n.lib
              , i = r.CipherParams
              , o = n.enc
              , s = o.Hex
              , a = n.format
              , c = a.Hex = {
                stringify: function(u) {
                    return u.ciphertext.toString(s)
                },
                parse: function(u) {
                    var l = s.parse(u);
                    return i.create({
                        ciphertext: l
                    })
                }
            }
        }(),
        t.format.Hex
    })
}
);
var a_ = Ce((Fh,s_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Fh == "object" ? s_.exports = Fh = e(Ge(), wo(), bo(), Ti(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Fh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.BlockCipher
              , i = e.algo
              , o = []
              , s = []
              , a = []
              , c = []
              , u = []
              , l = []
              , d = []
              , y = []
              , v = []
              , E = [];
            (function() {
                for (var w = [], M = 0; M < 256; M++)
                    M < 128 ? w[M] = M << 1 : w[M] = M << 1 ^ 283;
                for (var F = 0, N = 0, M = 0; M < 256; M++) {
                    var P = N ^ N << 1 ^ N << 2 ^ N << 3 ^ N << 4;
                    P = P >>> 8 ^ P & 255 ^ 99,
                    o[F] = P,
                    s[P] = F;
                    var O = w[F]
                      , z = w[O]
                      , q = w[z]
                      , J = w[P] * 257 ^ P * 16843008;
                    a[F] = J << 24 | J >>> 8,
                    c[F] = J << 16 | J >>> 16,
                    u[F] = J << 8 | J >>> 24,
                    l[F] = J;
                    var J = q * 16843009 ^ z * 65537 ^ O * 257 ^ F * 16843008;
                    d[P] = J << 24 | J >>> 8,
                    y[P] = J << 16 | J >>> 16,
                    v[P] = J << 8 | J >>> 24,
                    E[P] = J,
                    F ? (F = O ^ w[w[w[q ^ O]]],
                    N ^= w[w[N]]) : F = N = 1
                }
            }
            )();
            var D = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
              , S = i.AES = r.extend({
                _doReset: function() {
                    var w;
                    if (!(this._nRounds && this._keyPriorReset === this._key)) {
                        for (var M = this._keyPriorReset = this._key, F = M.words, N = M.sigBytes / 4, P = this._nRounds = N + 6, O = (P + 1) * 4, z = this._keySchedule = [], q = 0; q < O; q++)
                            q < N ? z[q] = F[q] : (w = z[q - 1],
                            q % N ? N > 6 && q % N == 4 && (w = o[w >>> 24] << 24 | o[w >>> 16 & 255] << 16 | o[w >>> 8 & 255] << 8 | o[w & 255]) : (w = w << 8 | w >>> 24,
                            w = o[w >>> 24] << 24 | o[w >>> 16 & 255] << 16 | o[w >>> 8 & 255] << 8 | o[w & 255],
                            w ^= D[q / N | 0] << 24),
                            z[q] = z[q - N] ^ w);
                        for (var J = this._invKeySchedule = [], te = 0; te < O; te++) {
                            var q = O - te;
                            if (te % 4)
                                var w = z[q];
                            else
                                var w = z[q - 4];
                            te < 4 || q <= 4 ? J[te] = w : J[te] = d[o[w >>> 24]] ^ y[o[w >>> 16 & 255]] ^ v[o[w >>> 8 & 255]] ^ E[o[w & 255]]
                        }
                    }
                },
                encryptBlock: function(w, M) {
                    this._doCryptBlock(w, M, this._keySchedule, a, c, u, l, o)
                },
                decryptBlock: function(w, M) {
                    var F = w[M + 1];
                    w[M + 1] = w[M + 3],
                    w[M + 3] = F,
                    this._doCryptBlock(w, M, this._invKeySchedule, d, y, v, E, s);
                    var F = w[M + 1];
                    w[M + 1] = w[M + 3],
                    w[M + 3] = F
                },
                _doCryptBlock: function(w, M, F, N, P, O, z, q) {
                    for (var J = this._nRounds, te = w[M] ^ F[0], V = w[M + 1] ^ F[1], Q = w[M + 2] ^ F[2], T = w[M + 3] ^ F[3], f = 4, g = 1; g < J; g++) {
                        var x = N[te >>> 24] ^ P[V >>> 16 & 255] ^ O[Q >>> 8 & 255] ^ z[T & 255] ^ F[f++]
                          , I = N[V >>> 24] ^ P[Q >>> 16 & 255] ^ O[T >>> 8 & 255] ^ z[te & 255] ^ F[f++]
                          , A = N[Q >>> 24] ^ P[T >>> 16 & 255] ^ O[te >>> 8 & 255] ^ z[V & 255] ^ F[f++]
                          , C = N[T >>> 24] ^ P[te >>> 16 & 255] ^ O[V >>> 8 & 255] ^ z[Q & 255] ^ F[f++];
                        te = x,
                        V = I,
                        Q = A,
                        T = C
                    }
                    var x = (q[te >>> 24] << 24 | q[V >>> 16 & 255] << 16 | q[Q >>> 8 & 255] << 8 | q[T & 255]) ^ F[f++]
                      , I = (q[V >>> 24] << 24 | q[Q >>> 16 & 255] << 16 | q[T >>> 8 & 255] << 8 | q[te & 255]) ^ F[f++]
                      , A = (q[Q >>> 24] << 24 | q[T >>> 16 & 255] << 16 | q[te >>> 8 & 255] << 8 | q[V & 255]) ^ F[f++]
                      , C = (q[T >>> 24] << 24 | q[te >>> 16 & 255] << 16 | q[V >>> 8 & 255] << 8 | q[Q & 255]) ^ F[f++];
                    w[M] = x,
                    w[M + 1] = I,
                    w[M + 2] = A,
                    w[M + 3] = C
                },
                keySize: 256 / 32
            });
            e.AES = r._createHelper(S)
        }(),
        t.AES
    })
}
);
var u_ = Ce((Nh,c_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Nh == "object" ? c_.exports = Nh = e(Ge(), wo(), bo(), Ti(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Nh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.WordArray
              , i = n.BlockCipher
              , o = e.algo
              , s = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
              , a = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
              , c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]
              , u = [{
                0: 8421888,
                268435456: 32768,
                536870912: 8421378,
                805306368: 2,
                1073741824: 512,
                1342177280: 8421890,
                1610612736: 8389122,
                1879048192: 8388608,
                2147483648: 514,
                2415919104: 8389120,
                2684354560: 33280,
                2952790016: 8421376,
                3221225472: 32770,
                3489660928: 8388610,
                3758096384: 0,
                4026531840: 33282,
                134217728: 0,
                402653184: 8421890,
                671088640: 33282,
                939524096: 32768,
                1207959552: 8421888,
                1476395008: 512,
                1744830464: 8421378,
                2013265920: 2,
                2281701376: 8389120,
                2550136832: 33280,
                2818572288: 8421376,
                3087007744: 8389122,
                3355443200: 8388610,
                3623878656: 32770,
                3892314112: 514,
                4160749568: 8388608,
                1: 32768,
                268435457: 2,
                536870913: 8421888,
                805306369: 8388608,
                1073741825: 8421378,
                1342177281: 33280,
                1610612737: 512,
                1879048193: 8389122,
                2147483649: 8421890,
                2415919105: 8421376,
                2684354561: 8388610,
                2952790017: 33282,
                3221225473: 514,
                3489660929: 8389120,
                3758096385: 32770,
                4026531841: 0,
                134217729: 8421890,
                402653185: 8421376,
                671088641: 8388608,
                939524097: 512,
                1207959553: 32768,
                1476395009: 8388610,
                1744830465: 2,
                2013265921: 33282,
                2281701377: 32770,
                2550136833: 8389122,
                2818572289: 514,
                3087007745: 8421888,
                3355443201: 8389120,
                3623878657: 0,
                3892314113: 33280,
                4160749569: 8421378
            }, {
                0: 1074282512,
                16777216: 16384,
                33554432: 524288,
                50331648: 1074266128,
                67108864: 1073741840,
                83886080: 1074282496,
                100663296: 1073758208,
                117440512: 16,
                134217728: 540672,
                150994944: 1073758224,
                167772160: 1073741824,
                184549376: 540688,
                201326592: 524304,
                218103808: 0,
                234881024: 16400,
                251658240: 1074266112,
                8388608: 1073758208,
                25165824: 540688,
                41943040: 16,
                58720256: 1073758224,
                75497472: 1074282512,
                92274688: 1073741824,
                109051904: 524288,
                125829120: 1074266128,
                142606336: 524304,
                159383552: 0,
                176160768: 16384,
                192937984: 1074266112,
                209715200: 1073741840,
                226492416: 540672,
                243269632: 1074282496,
                260046848: 16400,
                268435456: 0,
                285212672: 1074266128,
                301989888: 1073758224,
                318767104: 1074282496,
                335544320: 1074266112,
                352321536: 16,
                369098752: 540688,
                385875968: 16384,
                402653184: 16400,
                419430400: 524288,
                436207616: 524304,
                452984832: 1073741840,
                469762048: 540672,
                486539264: 1073758208,
                503316480: 1073741824,
                520093696: 1074282512,
                276824064: 540688,
                293601280: 524288,
                310378496: 1074266112,
                327155712: 16384,
                343932928: 1073758208,
                360710144: 1074282512,
                377487360: 16,
                394264576: 1073741824,
                411041792: 1074282496,
                427819008: 1073741840,
                444596224: 1073758224,
                461373440: 524304,
                478150656: 0,
                494927872: 16400,
                511705088: 1074266128,
                528482304: 540672
            }, {
                0: 260,
                1048576: 0,
                2097152: 67109120,
                3145728: 65796,
                4194304: 65540,
                5242880: 67108868,
                6291456: 67174660,
                7340032: 67174400,
                8388608: 67108864,
                9437184: 67174656,
                10485760: 65792,
                11534336: 67174404,
                12582912: 67109124,
                13631488: 65536,
                14680064: 4,
                15728640: 256,
                524288: 67174656,
                1572864: 67174404,
                2621440: 0,
                3670016: 67109120,
                4718592: 67108868,
                5767168: 65536,
                6815744: 65540,
                7864320: 260,
                8912896: 4,
                9961472: 256,
                11010048: 67174400,
                12058624: 65796,
                13107200: 65792,
                14155776: 67109124,
                15204352: 67174660,
                16252928: 67108864,
                16777216: 67174656,
                17825792: 65540,
                18874368: 65536,
                19922944: 67109120,
                20971520: 256,
                22020096: 67174660,
                23068672: 67108868,
                24117248: 0,
                25165824: 67109124,
                26214400: 67108864,
                27262976: 4,
                28311552: 65792,
                29360128: 67174400,
                30408704: 260,
                31457280: 65796,
                32505856: 67174404,
                17301504: 67108864,
                18350080: 260,
                19398656: 67174656,
                20447232: 0,
                21495808: 65540,
                22544384: 67109120,
                23592960: 256,
                24641536: 67174404,
                25690112: 65536,
                26738688: 67174660,
                27787264: 65796,
                28835840: 67108868,
                29884416: 67109124,
                30932992: 67174400,
                31981568: 4,
                33030144: 65792
            }, {
                0: 2151682048,
                65536: 2147487808,
                131072: 4198464,
                196608: 2151677952,
                262144: 0,
                327680: 4198400,
                393216: 2147483712,
                458752: 4194368,
                524288: 2147483648,
                589824: 4194304,
                655360: 64,
                720896: 2147487744,
                786432: 2151678016,
                851968: 4160,
                917504: 4096,
                983040: 2151682112,
                32768: 2147487808,
                98304: 64,
                163840: 2151678016,
                229376: 2147487744,
                294912: 4198400,
                360448: 2151682112,
                425984: 0,
                491520: 2151677952,
                557056: 4096,
                622592: 2151682048,
                688128: 4194304,
                753664: 4160,
                819200: 2147483648,
                884736: 4194368,
                950272: 4198464,
                1015808: 2147483712,
                1048576: 4194368,
                1114112: 4198400,
                1179648: 2147483712,
                1245184: 0,
                1310720: 4160,
                1376256: 2151678016,
                1441792: 2151682048,
                1507328: 2147487808,
                1572864: 2151682112,
                1638400: 2147483648,
                1703936: 2151677952,
                1769472: 4198464,
                1835008: 2147487744,
                1900544: 4194304,
                1966080: 64,
                2031616: 4096,
                1081344: 2151677952,
                1146880: 2151682112,
                1212416: 0,
                1277952: 4198400,
                1343488: 4194368,
                1409024: 2147483648,
                1474560: 2147487808,
                1540096: 64,
                1605632: 2147483712,
                1671168: 4096,
                1736704: 2147487744,
                1802240: 2151678016,
                1867776: 4160,
                1933312: 2151682048,
                1998848: 4194304,
                2064384: 4198464
            }, {
                0: 128,
                4096: 17039360,
                8192: 262144,
                12288: 536870912,
                16384: 537133184,
                20480: 16777344,
                24576: 553648256,
                28672: 262272,
                32768: 16777216,
                36864: 537133056,
                40960: 536871040,
                45056: 553910400,
                49152: 553910272,
                53248: 0,
                57344: 17039488,
                61440: 553648128,
                2048: 17039488,
                6144: 553648256,
                10240: 128,
                14336: 17039360,
                18432: 262144,
                22528: 537133184,
                26624: 553910272,
                30720: 536870912,
                34816: 537133056,
                38912: 0,
                43008: 553910400,
                47104: 16777344,
                51200: 536871040,
                55296: 553648128,
                59392: 16777216,
                63488: 262272,
                65536: 262144,
                69632: 128,
                73728: 536870912,
                77824: 553648256,
                81920: 16777344,
                86016: 553910272,
                90112: 537133184,
                94208: 16777216,
                98304: 553910400,
                102400: 553648128,
                106496: 17039360,
                110592: 537133056,
                114688: 262272,
                118784: 536871040,
                122880: 0,
                126976: 17039488,
                67584: 553648256,
                71680: 16777216,
                75776: 17039360,
                79872: 537133184,
                83968: 536870912,
                88064: 17039488,
                92160: 128,
                96256: 553910272,
                100352: 262272,
                104448: 553910400,
                108544: 0,
                112640: 553648128,
                116736: 16777344,
                120832: 262144,
                124928: 537133056,
                129024: 536871040
            }, {
                0: 268435464,
                256: 8192,
                512: 270532608,
                768: 270540808,
                1024: 268443648,
                1280: 2097152,
                1536: 2097160,
                1792: 268435456,
                2048: 0,
                2304: 268443656,
                2560: 2105344,
                2816: 8,
                3072: 270532616,
                3328: 2105352,
                3584: 8200,
                3840: 270540800,
                128: 270532608,
                384: 270540808,
                640: 8,
                896: 2097152,
                1152: 2105352,
                1408: 268435464,
                1664: 268443648,
                1920: 8200,
                2176: 2097160,
                2432: 8192,
                2688: 268443656,
                2944: 270532616,
                3200: 0,
                3456: 270540800,
                3712: 2105344,
                3968: 268435456,
                4096: 268443648,
                4352: 270532616,
                4608: 270540808,
                4864: 8200,
                5120: 2097152,
                5376: 268435456,
                5632: 268435464,
                5888: 2105344,
                6144: 2105352,
                6400: 0,
                6656: 8,
                6912: 270532608,
                7168: 8192,
                7424: 268443656,
                7680: 270540800,
                7936: 2097160,
                4224: 8,
                4480: 2105344,
                4736: 2097152,
                4992: 268435464,
                5248: 268443648,
                5504: 8200,
                5760: 270540808,
                6016: 270532608,
                6272: 270540800,
                6528: 270532616,
                6784: 8192,
                7040: 2105352,
                7296: 2097160,
                7552: 0,
                7808: 268435456,
                8064: 268443656
            }, {
                0: 1048576,
                16: 33555457,
                32: 1024,
                48: 1049601,
                64: 34604033,
                80: 0,
                96: 1,
                112: 34603009,
                128: 33555456,
                144: 1048577,
                160: 33554433,
                176: 34604032,
                192: 34603008,
                208: 1025,
                224: 1049600,
                240: 33554432,
                8: 34603009,
                24: 0,
                40: 33555457,
                56: 34604032,
                72: 1048576,
                88: 33554433,
                104: 33554432,
                120: 1025,
                136: 1049601,
                152: 33555456,
                168: 34603008,
                184: 1048577,
                200: 1024,
                216: 34604033,
                232: 1,
                248: 1049600,
                256: 33554432,
                272: 1048576,
                288: 33555457,
                304: 34603009,
                320: 1048577,
                336: 33555456,
                352: 34604032,
                368: 1049601,
                384: 1025,
                400: 34604033,
                416: 1049600,
                432: 1,
                448: 0,
                464: 34603008,
                480: 33554433,
                496: 1024,
                264: 1049600,
                280: 33555457,
                296: 34603009,
                312: 1,
                328: 33554432,
                344: 1048576,
                360: 1025,
                376: 34604032,
                392: 33554433,
                408: 34603008,
                424: 0,
                440: 34604033,
                456: 1049601,
                472: 1024,
                488: 33555456,
                504: 1048577
            }, {
                0: 134219808,
                1: 131072,
                2: 134217728,
                3: 32,
                4: 131104,
                5: 134350880,
                6: 134350848,
                7: 2048,
                8: 134348800,
                9: 134219776,
                10: 133120,
                11: 134348832,
                12: 2080,
                13: 0,
                14: 134217760,
                15: 133152,
                2147483648: 2048,
                2147483649: 134350880,
                2147483650: 134219808,
                2147483651: 134217728,
                2147483652: 134348800,
                2147483653: 133120,
                2147483654: 133152,
                2147483655: 32,
                2147483656: 134217760,
                2147483657: 2080,
                2147483658: 131104,
                2147483659: 134350848,
                2147483660: 0,
                2147483661: 134348832,
                2147483662: 134219776,
                2147483663: 131072,
                16: 133152,
                17: 134350848,
                18: 32,
                19: 2048,
                20: 134219776,
                21: 134217760,
                22: 134348832,
                23: 131072,
                24: 0,
                25: 131104,
                26: 134348800,
                27: 134219808,
                28: 134350880,
                29: 133120,
                30: 2080,
                31: 134217728,
                2147483664: 131072,
                2147483665: 2048,
                2147483666: 134348832,
                2147483667: 133152,
                2147483668: 32,
                2147483669: 134348800,
                2147483670: 134217728,
                2147483671: 134219808,
                2147483672: 134350880,
                2147483673: 134217760,
                2147483674: 134219776,
                2147483675: 0,
                2147483676: 133120,
                2147483677: 2080,
                2147483678: 131104,
                2147483679: 134350848
            }]
              , l = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]
              , d = o.DES = i.extend({
                _doReset: function() {
                    for (var D = this._key, S = D.words, w = [], M = 0; M < 56; M++) {
                        var F = s[M] - 1;
                        w[M] = S[F >>> 5] >>> 31 - F % 32 & 1
                    }
                    for (var N = this._subKeys = [], P = 0; P < 16; P++) {
                        for (var O = N[P] = [], z = c[P], M = 0; M < 24; M++)
                            O[M / 6 | 0] |= w[(a[M] - 1 + z) % 28] << 31 - M % 6,
                            O[4 + (M / 6 | 0)] |= w[28 + (a[M + 24] - 1 + z) % 28] << 31 - M % 6;
                        O[0] = O[0] << 1 | O[0] >>> 31;
                        for (var M = 1; M < 7; M++)
                            O[M] = O[M] >>> (M - 1) * 4 + 3;
                        O[7] = O[7] << 5 | O[7] >>> 27
                    }
                    for (var q = this._invSubKeys = [], M = 0; M < 16; M++)
                        q[M] = N[15 - M]
                },
                encryptBlock: function(D, S) {
                    this._doCryptBlock(D, S, this._subKeys)
                },
                decryptBlock: function(D, S) {
                    this._doCryptBlock(D, S, this._invSubKeys)
                },
                _doCryptBlock: function(D, S, w) {
                    this._lBlock = D[S],
                    this._rBlock = D[S + 1],
                    y.call(this, 4, 252645135),
                    y.call(this, 16, 65535),
                    v.call(this, 2, 858993459),
                    v.call(this, 8, 16711935),
                    y.call(this, 1, 1431655765);
                    for (var M = 0; M < 16; M++) {
                        for (var F = w[M], N = this._lBlock, P = this._rBlock, O = 0, z = 0; z < 8; z++)
                            O |= u[z][((P ^ F[z]) & l[z]) >>> 0];
                        this._lBlock = P,
                        this._rBlock = N ^ O
                    }
                    var q = this._lBlock;
                    this._lBlock = this._rBlock,
                    this._rBlock = q,
                    y.call(this, 1, 1431655765),
                    v.call(this, 8, 16711935),
                    v.call(this, 2, 858993459),
                    y.call(this, 16, 65535),
                    y.call(this, 4, 252645135),
                    D[S] = this._lBlock,
                    D[S + 1] = this._rBlock
                },
                keySize: 64 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
            });
            function y(D, S) {
                var w = (this._lBlock >>> D ^ this._rBlock) & S;
                this._rBlock ^= w,
                this._lBlock ^= w << D
            }
            function v(D, S) {
                var w = (this._rBlock >>> D ^ this._lBlock) & S;
                this._lBlock ^= w,
                this._rBlock ^= w << D
            }
            e.DES = i._createHelper(d);
            var E = o.TripleDES = i.extend({
                _doReset: function() {
                    var D = this._key
                      , S = D.words;
                    if (S.length !== 2 && S.length !== 4 && S.length < 6)
                        throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                    var w = S.slice(0, 2)
                      , M = S.length < 4 ? S.slice(0, 2) : S.slice(2, 4)
                      , F = S.length < 6 ? S.slice(0, 2) : S.slice(4, 6);
                    this._des1 = d.createEncryptor(r.create(w)),
                    this._des2 = d.createEncryptor(r.create(M)),
                    this._des3 = d.createEncryptor(r.create(F))
                },
                encryptBlock: function(D, S) {
                    this._des1.encryptBlock(D, S),
                    this._des2.decryptBlock(D, S),
                    this._des3.encryptBlock(D, S)
                },
                decryptBlock: function(D, S) {
                    this._des3.decryptBlock(D, S),
                    this._des2.encryptBlock(D, S),
                    this._des1.decryptBlock(D, S)
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
            });
            e.TripleDES = i._createHelper(E)
        }(),
        t.TripleDES
    })
}
);
var f_ = Ce((Ph,l_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Ph == "object" ? l_.exports = Ph = e(Ge(), wo(), bo(), Ti(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Ph, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.StreamCipher
              , i = e.algo
              , o = i.RC4 = r.extend({
                _doReset: function() {
                    for (var c = this._key, u = c.words, l = c.sigBytes, d = this._S = [], y = 0; y < 256; y++)
                        d[y] = y;
                    for (var y = 0, v = 0; y < 256; y++) {
                        var E = y % l
                          , D = u[E >>> 2] >>> 24 - E % 4 * 8 & 255;
                        v = (v + d[y] + D) % 256;
                        var S = d[y];
                        d[y] = d[v],
                        d[v] = S
                    }
                    this._i = this._j = 0
                },
                _doProcessBlock: function(c, u) {
                    c[u] ^= s.call(this)
                },
                keySize: 256 / 32,
                ivSize: 0
            });
            function s() {
                for (var c = this._S, u = this._i, l = this._j, d = 0, y = 0; y < 4; y++) {
                    u = (u + 1) % 256,
                    l = (l + c[u]) % 256;
                    var v = c[u];
                    c[u] = c[l],
                    c[l] = v,
                    d |= c[(c[u] + c[l]) % 256] << 24 - y * 8
                }
                return this._i = u,
                this._j = l,
                d
            }
            e.RC4 = r._createHelper(o);
            var a = i.RC4Drop = o.extend({
                cfg: o.cfg.extend({
                    drop: 192
                }),
                _doReset: function() {
                    o._doReset.call(this);
                    for (var c = this.cfg.drop; c > 0; c--)
                        s.call(this)
                }
            });
            e.RC4Drop = r._createHelper(a)
        }(),
        t.RC4
    })
}
);
var h_ = Ce((Oh,d_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Oh == "object" ? d_.exports = Oh = e(Ge(), wo(), bo(), Ti(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Oh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.StreamCipher
              , i = e.algo
              , o = []
              , s = []
              , a = []
              , c = i.Rabbit = r.extend({
                _doReset: function() {
                    for (var l = this._key.words, d = this.cfg.iv, y = 0; y < 4; y++)
                        l[y] = (l[y] << 8 | l[y] >>> 24) & 16711935 | (l[y] << 24 | l[y] >>> 8) & 4278255360;
                    var v = this._X = [l[0], l[3] << 16 | l[2] >>> 16, l[1], l[0] << 16 | l[3] >>> 16, l[2], l[1] << 16 | l[0] >>> 16, l[3], l[2] << 16 | l[1] >>> 16]
                      , E = this._C = [l[2] << 16 | l[2] >>> 16, l[0] & 4294901760 | l[1] & 65535, l[3] << 16 | l[3] >>> 16, l[1] & 4294901760 | l[2] & 65535, l[0] << 16 | l[0] >>> 16, l[2] & 4294901760 | l[3] & 65535, l[1] << 16 | l[1] >>> 16, l[3] & 4294901760 | l[0] & 65535];
                    this._b = 0;
                    for (var y = 0; y < 4; y++)
                        u.call(this);
                    for (var y = 0; y < 8; y++)
                        E[y] ^= v[y + 4 & 7];
                    if (d) {
                        var D = d.words
                          , S = D[0]
                          , w = D[1]
                          , M = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360
                          , F = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360
                          , N = M >>> 16 | F & 4294901760
                          , P = F << 16 | M & 65535;
                        E[0] ^= M,
                        E[1] ^= N,
                        E[2] ^= F,
                        E[3] ^= P,
                        E[4] ^= M,
                        E[5] ^= N,
                        E[6] ^= F,
                        E[7] ^= P;
                        for (var y = 0; y < 4; y++)
                            u.call(this)
                    }
                },
                _doProcessBlock: function(l, d) {
                    var y = this._X;
                    u.call(this),
                    o[0] = y[0] ^ y[5] >>> 16 ^ y[3] << 16,
                    o[1] = y[2] ^ y[7] >>> 16 ^ y[5] << 16,
                    o[2] = y[4] ^ y[1] >>> 16 ^ y[7] << 16,
                    o[3] = y[6] ^ y[3] >>> 16 ^ y[1] << 16;
                    for (var v = 0; v < 4; v++)
                        o[v] = (o[v] << 8 | o[v] >>> 24) & 16711935 | (o[v] << 24 | o[v] >>> 8) & 4278255360,
                        l[d + v] ^= o[v]
                },
                blockSize: 128 / 32,
                ivSize: 64 / 32
            });
            function u() {
                for (var l = this._X, d = this._C, y = 0; y < 8; y++)
                    s[y] = d[y];
                d[0] = d[0] + 1295307597 + this._b | 0,
                d[1] = d[1] + 3545052371 + (d[0] >>> 0 < s[0] >>> 0 ? 1 : 0) | 0,
                d[2] = d[2] + 886263092 + (d[1] >>> 0 < s[1] >>> 0 ? 1 : 0) | 0,
                d[3] = d[3] + 1295307597 + (d[2] >>> 0 < s[2] >>> 0 ? 1 : 0) | 0,
                d[4] = d[4] + 3545052371 + (d[3] >>> 0 < s[3] >>> 0 ? 1 : 0) | 0,
                d[5] = d[5] + 886263092 + (d[4] >>> 0 < s[4] >>> 0 ? 1 : 0) | 0,
                d[6] = d[6] + 1295307597 + (d[5] >>> 0 < s[5] >>> 0 ? 1 : 0) | 0,
                d[7] = d[7] + 3545052371 + (d[6] >>> 0 < s[6] >>> 0 ? 1 : 0) | 0,
                this._b = d[7] >>> 0 < s[7] >>> 0 ? 1 : 0;
                for (var y = 0; y < 8; y++) {
                    var v = l[y] + d[y]
                      , E = v & 65535
                      , D = v >>> 16
                      , S = ((E * E >>> 17) + E * D >>> 15) + D * D
                      , w = ((v & 4294901760) * v | 0) + ((v & 65535) * v | 0);
                    a[y] = S ^ w
                }
                l[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0,
                l[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0,
                l[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0,
                l[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0,
                l[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0,
                l[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0,
                l[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0,
                l[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0
            }
            e.Rabbit = r._createHelper(c)
        }(),
        t.Rabbit
    })
}
);
var g_ = Ce((Lh,p_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Lh == "object" ? p_.exports = Lh = e(Ge(), wo(), bo(), Ti(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Lh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.StreamCipher
              , i = e.algo
              , o = []
              , s = []
              , a = []
              , c = i.RabbitLegacy = r.extend({
                _doReset: function() {
                    var l = this._key.words
                      , d = this.cfg.iv
                      , y = this._X = [l[0], l[3] << 16 | l[2] >>> 16, l[1], l[0] << 16 | l[3] >>> 16, l[2], l[1] << 16 | l[0] >>> 16, l[3], l[2] << 16 | l[1] >>> 16]
                      , v = this._C = [l[2] << 16 | l[2] >>> 16, l[0] & 4294901760 | l[1] & 65535, l[3] << 16 | l[3] >>> 16, l[1] & 4294901760 | l[2] & 65535, l[0] << 16 | l[0] >>> 16, l[2] & 4294901760 | l[3] & 65535, l[1] << 16 | l[1] >>> 16, l[3] & 4294901760 | l[0] & 65535];
                    this._b = 0;
                    for (var E = 0; E < 4; E++)
                        u.call(this);
                    for (var E = 0; E < 8; E++)
                        v[E] ^= y[E + 4 & 7];
                    if (d) {
                        var D = d.words
                          , S = D[0]
                          , w = D[1]
                          , M = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360
                          , F = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360
                          , N = M >>> 16 | F & 4294901760
                          , P = F << 16 | M & 65535;
                        v[0] ^= M,
                        v[1] ^= N,
                        v[2] ^= F,
                        v[3] ^= P,
                        v[4] ^= M,
                        v[5] ^= N,
                        v[6] ^= F,
                        v[7] ^= P;
                        for (var E = 0; E < 4; E++)
                            u.call(this)
                    }
                },
                _doProcessBlock: function(l, d) {
                    var y = this._X;
                    u.call(this),
                    o[0] = y[0] ^ y[5] >>> 16 ^ y[3] << 16,
                    o[1] = y[2] ^ y[7] >>> 16 ^ y[5] << 16,
                    o[2] = y[4] ^ y[1] >>> 16 ^ y[7] << 16,
                    o[3] = y[6] ^ y[3] >>> 16 ^ y[1] << 16;
                    for (var v = 0; v < 4; v++)
                        o[v] = (o[v] << 8 | o[v] >>> 24) & 16711935 | (o[v] << 24 | o[v] >>> 8) & 4278255360,
                        l[d + v] ^= o[v]
                },
                blockSize: 128 / 32,
                ivSize: 64 / 32
            });
            function u() {
                for (var l = this._X, d = this._C, y = 0; y < 8; y++)
                    s[y] = d[y];
                d[0] = d[0] + 1295307597 + this._b | 0,
                d[1] = d[1] + 3545052371 + (d[0] >>> 0 < s[0] >>> 0 ? 1 : 0) | 0,
                d[2] = d[2] + 886263092 + (d[1] >>> 0 < s[1] >>> 0 ? 1 : 0) | 0,
                d[3] = d[3] + 1295307597 + (d[2] >>> 0 < s[2] >>> 0 ? 1 : 0) | 0,
                d[4] = d[4] + 3545052371 + (d[3] >>> 0 < s[3] >>> 0 ? 1 : 0) | 0,
                d[5] = d[5] + 886263092 + (d[4] >>> 0 < s[4] >>> 0 ? 1 : 0) | 0,
                d[6] = d[6] + 1295307597 + (d[5] >>> 0 < s[5] >>> 0 ? 1 : 0) | 0,
                d[7] = d[7] + 3545052371 + (d[6] >>> 0 < s[6] >>> 0 ? 1 : 0) | 0,
                this._b = d[7] >>> 0 < s[7] >>> 0 ? 1 : 0;
                for (var y = 0; y < 8; y++) {
                    var v = l[y] + d[y]
                      , E = v & 65535
                      , D = v >>> 16
                      , S = ((E * E >>> 17) + E * D >>> 15) + D * D
                      , w = ((v & 4294901760) * v | 0) + ((v & 65535) * v | 0);
                    a[y] = S ^ w
                }
                l[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0,
                l[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0,
                l[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0,
                l[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0,
                l[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0,
                l[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0,
                l[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0,
                l[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0
            }
            e.RabbitLegacy = r._createHelper(c)
        }(),
        t.RabbitLegacy
    })
}
);
var y_ = Ce((Uh,m_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Uh == "object" ? m_.exports = Uh = e(Ge(), wo(), bo(), Ti(), rn()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], e) : e(t.CryptoJS)
    }
    )(Uh, function(t) {
        return function() {
            var e = t
              , n = e.lib
              , r = n.BlockCipher
              , i = e.algo;
            let o = 16
              , s = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731]
              , a = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]];
            var c = {
                pbox: [],
                sbox: []
            };
            function u(E, D) {
                let S = D >> 24 & 255
                  , w = D >> 16 & 255
                  , M = D >> 8 & 255
                  , F = D & 255
                  , N = E.sbox[0][S] + E.sbox[1][w];
                return N = N ^ E.sbox[2][M],
                N = N + E.sbox[3][F],
                N
            }
            function l(E, D, S) {
                let w = D, M = S, F;
                for (let N = 0; N < o; ++N)
                    w = w ^ E.pbox[N],
                    M = u(E, w) ^ M,
                    F = w,
                    w = M,
                    M = F;
                return F = w,
                w = M,
                M = F,
                M = M ^ E.pbox[o],
                w = w ^ E.pbox[o + 1],
                {
                    left: w,
                    right: M
                }
            }
            function d(E, D, S) {
                let w = D, M = S, F;
                for (let N = o + 1; N > 1; --N)
                    w = w ^ E.pbox[N],
                    M = u(E, w) ^ M,
                    F = w,
                    w = M,
                    M = F;
                return F = w,
                w = M,
                M = F,
                M = M ^ E.pbox[1],
                w = w ^ E.pbox[0],
                {
                    left: w,
                    right: M
                }
            }
            function y(E, D, S) {
                for (let P = 0; P < 4; P++) {
                    E.sbox[P] = [];
                    for (let O = 0; O < 256; O++)
                        E.sbox[P][O] = a[P][O]
                }
                let w = 0;
                for (let P = 0; P < o + 2; P++)
                    E.pbox[P] = s[P] ^ D[w],
                    w++,
                    w >= S && (w = 0);
                let M = 0
                  , F = 0
                  , N = 0;
                for (let P = 0; P < o + 2; P += 2)
                    N = l(E, M, F),
                    M = N.left,
                    F = N.right,
                    E.pbox[P] = M,
                    E.pbox[P + 1] = F;
                for (let P = 0; P < 4; P++)
                    for (let O = 0; O < 256; O += 2)
                        N = l(E, M, F),
                        M = N.left,
                        F = N.right,
                        E.sbox[P][O] = M,
                        E.sbox[P][O + 1] = F;
                return !0
            }
            var v = i.Blowfish = r.extend({
                _doReset: function() {
                    if (this._keyPriorReset !== this._key) {
                        var E = this._keyPriorReset = this._key
                          , D = E.words
                          , S = E.sigBytes / 4;
                        y(c, D, S)
                    }
                },
                encryptBlock: function(E, D) {
                    var S = l(c, E[D], E[D + 1]);
                    E[D] = S.left,
                    E[D + 1] = S.right
                },
                decryptBlock: function(E, D) {
                    var S = d(c, E[D], E[D + 1]);
                    E[D] = S.left,
                    E[D + 1] = S.right
                },
                blockSize: 64 / 32,
                keySize: 128 / 32,
                ivSize: 64 / 32
            });
            e.Blowfish = r._createHelper(v)
        }(),
        t.Blowfish
    })
}
);
var x_ = Ce((Vh,v_)=>{
    "use strict";
    (function(t, e, n) {
        typeof Vh == "object" ? v_.exports = Vh = e(Ge(), fu(), gA(), yA(), wo(), wA(), bo(), Sv(), dh(), IA(), Mv(), SA(), kA(), BA(), xh(), NA(), Ti(), rn(), UA(), jA(), HA(), qA(), GA(), YA(), XA(), JA(), t_(), r_(), o_(), a_(), u_(), f_(), h_(), g_(), y_()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], e) : t.CryptoJS = e(t.CryptoJS)
    }
    )(Vh, function(t) {
        return t
    })
}
);
var Ov = null;
var u0 = 1
  , Lv = Symbol("SIGNAL");
function at(t) {
    let e = Ov;
    return Ov = t,
    e
}
var Uv = {
    version: 0,
    lastCleanEpoch: 0,
    dirty: !1,
    producerNode: void 0,
    producerLastReadVersion: void 0,
    producerIndexOfThis: void 0,
    nextProducerIndex: 0,
    liveConsumerNode: void 0,
    liveConsumerIndexOfThis: void 0,
    consumerAllowSignalWrites: !1,
    consumerIsAlwaysLive: !1,
    producerMustRecompute: ()=>!1,
    producerRecomputeValue: ()=>{}
    ,
    consumerMarkedDirty: ()=>{}
    ,
    consumerOnSignalRead: ()=>{}
};
function k_(t) {
    if (!(d0(t) && !t.dirty) && !(!t.dirty && t.lastCleanEpoch === u0)) {
        if (!t.producerMustRecompute(t) && !l0(t)) {
            t.dirty = !1,
            t.lastCleanEpoch = u0;
            return
        }
        t.producerRecomputeValue(t),
        t.dirty = !1,
        t.lastCleanEpoch = u0
    }
}
function Vv(t) {
    return t && (t.nextProducerIndex = 0),
    at(t)
}
function jv(t, e) {
    if (at(e),
    !(!t || t.producerNode === void 0 || t.producerIndexOfThis === void 0 || t.producerLastReadVersion === void 0)) {
        if (d0(t))
            for (let n = t.nextProducerIndex; n < t.producerNode.length; n++)
                f0(t.producerNode[n], t.producerIndexOfThis[n]);
        for (; t.producerNode.length > t.nextProducerIndex; )
            t.producerNode.pop(),
            t.producerLastReadVersion.pop(),
            t.producerIndexOfThis.pop()
    }
}
function l0(t) {
    gu(t);
    for (let e = 0; e < t.producerNode.length; e++) {
        let n = t.producerNode[e]
          , r = t.producerLastReadVersion[e];
        if (r !== n.version || (k_(n),
        r !== n.version))
            return !0
    }
    return !1
}
function $v(t) {
    if (gu(t),
    d0(t))
        for (let e = 0; e < t.producerNode.length; e++)
            f0(t.producerNode[e], t.producerIndexOfThis[e]);
    t.producerNode.length = t.producerLastReadVersion.length = t.producerIndexOfThis.length = 0,
    t.liveConsumerNode && (t.liveConsumerNode.length = t.liveConsumerIndexOfThis.length = 0)
}
function f0(t, e) {
    if (T_(t),
    gu(t),
    t.liveConsumerNode.length === 1)
        for (let r = 0; r < t.producerNode.length; r++)
            f0(t.producerNode[r], t.producerIndexOfThis[r]);
    let n = t.liveConsumerNode.length - 1;
    if (t.liveConsumerNode[e] = t.liveConsumerNode[n],
    t.liveConsumerIndexOfThis[e] = t.liveConsumerIndexOfThis[n],
    t.liveConsumerNode.length--,
    t.liveConsumerIndexOfThis.length--,
    e < t.liveConsumerNode.length) {
        let r = t.liveConsumerIndexOfThis[e]
          , i = t.liveConsumerNode[e];
        gu(i),
        i.producerIndexOfThis[r] = e
    }
}
function d0(t) {
    return t.consumerIsAlwaysLive || (t?.liveConsumerNode?.length ?? 0) > 0
}
function gu(t) {
    t.producerNode ??= [],
    t.producerIndexOfThis ??= [],
    t.producerLastReadVersion ??= []
}
function T_(t) {
    t.liveConsumerNode ??= [],
    t.liveConsumerIndexOfThis ??= []
}
function B_() {
    throw new Error
}
var R_ = B_;
function Hv(t) {
    R_ = t
}
function Re(t) {
    return typeof t == "function"
}
function us(t) {
    let n = t(r=>{
        Error.call(r),
        r.stack = new Error().stack
    }
    );
    return n.prototype = Object.create(Error.prototype),
    n.prototype.constructor = n,
    n
}
var mu = us(t=>function(n) {
    t(this),
    this.message = n ? `${n.length} errors occurred during unsubscription:
${n.map((r,i)=>`${i + 1}) ${r.toString()}`).join(`
  `)}` : "",
    this.name = "UnsubscriptionError",
    this.errors = n
}
);
function Ta(t, e) {
    if (t) {
        let n = t.indexOf(e);
        0 <= n && t.splice(n, 1)
    }
}
var en = class t {
    constructor(e) {
        this.initialTeardown = e,
        this.closed = !1,
        this._parentage = null,
        this._finalizers = null
    }
    unsubscribe() {
        let e;
        if (!this.closed) {
            this.closed = !0;
            let {_parentage: n} = this;
            if (n)
                if (this._parentage = null,
                Array.isArray(n))
                    for (let o of n)
                        o.remove(this);
                else
                    n.remove(this);
            let {initialTeardown: r} = this;
            if (Re(r))
                try {
                    r()
                } catch (o) {
                    e = o instanceof mu ? o.errors : [o]
                }
            let {_finalizers: i} = this;
            if (i) {
                this._finalizers = null;
                for (let o of i)
                    try {
                        zv(o)
                    } catch (s) {
                        e = e ?? [],
                        s instanceof mu ? e = [...e, ...s.errors] : e.push(s)
                    }
            }
            if (e)
                throw new mu(e)
        }
    }
    add(e) {
        var n;
        if (e && e !== this)
            if (this.closed)
                zv(e);
            else {
                if (e instanceof t) {
                    if (e.closed || e._hasParent(this))
                        return;
                    e._addParent(this)
                }
                (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e)
            }
    }
    _hasParent(e) {
        let {_parentage: n} = this;
        return n === e || Array.isArray(n) && n.includes(e)
    }
    _addParent(e) {
        let {_parentage: n} = this;
        this._parentage = Array.isArray(n) ? (n.push(e),
        n) : n ? [n, e] : e
    }
    _removeParent(e) {
        let {_parentage: n} = this;
        n === e ? this._parentage = null : Array.isArray(n) && Ta(n, e)
    }
    remove(e) {
        let {_finalizers: n} = this;
        n && Ta(n, e),
        e instanceof t && e._removeParent(this)
    }
}
;
en.EMPTY = (()=>{
    let t = new en;
    return t.closed = !0,
    t
}
)();
var h0 = en.EMPTY;
function yu(t) {
    return t instanceof en || t && "closed"in t && Re(t.remove) && Re(t.add) && Re(t.unsubscribe)
}
function zv(t) {
    Re(t) ? t() : t.unsubscribe()
}
var wr = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1
};
var ls = {
    setTimeout(t, e, ...n) {
        let {delegate: r} = ls;
        return r?.setTimeout ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n)
    },
    clearTimeout(t) {
        let {delegate: e} = ls;
        return (e?.clearTimeout || clearTimeout)(t)
    },
    delegate: void 0
};
function vu(t) {
    ls.setTimeout(()=>{
        let {onUnhandledError: e} = wr;
        if (e)
            e(t);
        else
            throw t
    }
    )
}
function Ba() {}
var qv = p0("C", void 0, void 0);
function Wv(t) {
    return p0("E", void 0, t)
}
function Gv(t) {
    return p0("N", t, void 0)
}
function p0(t, e, n) {
    return {
        kind: t,
        value: e,
        error: n
    }
}
var Eo = null;
function fs(t) {
    if (wr.useDeprecatedSynchronousErrorHandling) {
        let e = !Eo;
        if (e && (Eo = {
            errorThrown: !1,
            error: null
        }),
        t(),
        e) {
            let {errorThrown: n, error: r} = Eo;
            if (Eo = null,
            n)
                throw r
        }
    } else
        t()
}
function Kv(t) {
    wr.useDeprecatedSynchronousErrorHandling && Eo && (Eo.errorThrown = !0,
    Eo.error = t)
}
var Co = class extends en {
    constructor(e) {
        super(),
        this.isStopped = !1,
        e ? (this.destination = e,
        yu(e) && e.add(this)) : this.destination = P_
    }
    static create(e, n, r) {
        return new ds(e,n,r)
    }
    next(e) {
        this.isStopped ? m0(Gv(e), this) : this._next(e)
    }
    error(e) {
        this.isStopped ? m0(Wv(e), this) : (this.isStopped = !0,
        this._error(e))
    }
    complete() {
        this.isStopped ? m0(qv, this) : (this.isStopped = !0,
        this._complete())
    }
    unsubscribe() {
        this.closed || (this.isStopped = !0,
        super.unsubscribe(),
        this.destination = null)
    }
    _next(e) {
        this.destination.next(e)
    }
    _error(e) {
        try {
            this.destination.error(e)
        } finally {
            this.unsubscribe()
        }
    }
    _complete() {
        try {
            this.destination.complete()
        } finally {
            this.unsubscribe()
        }
    }
}
  , F_ = Function.prototype.bind;
function g0(t, e) {
    return F_.call(t, e)
}
var y0 = class {
    constructor(e) {
        this.partialObserver = e
    }
    next(e) {
        let {partialObserver: n} = this;
        if (n.next)
            try {
                n.next(e)
            } catch (r) {
                xu(r)
            }
    }
    error(e) {
        let {partialObserver: n} = this;
        if (n.error)
            try {
                n.error(e)
            } catch (r) {
                xu(r)
            }
        else
            xu(e)
    }
    complete() {
        let {partialObserver: e} = this;
        if (e.complete)
            try {
                e.complete()
            } catch (n) {
                xu(n)
            }
    }
}
  , ds = class extends Co {
    constructor(e, n, r) {
        super();
        let i;
        if (Re(e) || !e)
            i = {
                next: e ?? void 0,
                error: n ?? void 0,
                complete: r ?? void 0
            };
        else {
            let o;
            this && wr.useDeprecatedNextContext ? (o = Object.create(e),
            o.unsubscribe = ()=>this.unsubscribe(),
            i = {
                next: e.next && g0(e.next, o),
                error: e.error && g0(e.error, o),
                complete: e.complete && g0(e.complete, o)
            }) : i = e
        }
        this.destination = new y0(i)
    }
}
;
function xu(t) {
    wr.useDeprecatedSynchronousErrorHandling ? Kv(t) : vu(t)
}
function N_(t) {
    throw t
}
function m0(t, e) {
    let {onStoppedNotification: n} = wr;
    n && ls.setTimeout(()=>n(t, e))
}
var P_ = {
    closed: !0,
    next: Ba,
    error: N_,
    complete: Ba
};
var hs = typeof Symbol == "function" && Symbol.observable || "@@observable";
function Kn(t) {
    return t
}
function v0(...t) {
    return x0(t)
}
function x0(t) {
    return t.length === 0 ? Kn : t.length === 1 ? t[0] : function(n) {
        return t.reduce((r,i)=>i(r), n)
    }
}
var ct = (()=>{
    class t {
        constructor(n) {
            n && (this._subscribe = n)
        }
        lift(n) {
            let r = new t;
            return r.source = this,
            r.operator = n,
            r
        }
        subscribe(n, r, i) {
            let o = L_(n) ? n : new ds(n,r,i);
            return fs(()=>{
                let {operator: s, source: a} = this;
                o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o))
            }
            ),
            o
        }
        _trySubscribe(n) {
            try {
                return this._subscribe(n)
            } catch (r) {
                n.error(r)
            }
        }
        forEach(n, r) {
            return r = Yv(r),
            new r((i,o)=>{
                let s = new ds({
                    next: a=>{
                        try {
                            n(a)
                        } catch (c) {
                            o(c),
                            s.unsubscribe()
                        }
                    }
                    ,
                    error: o,
                    complete: i
                });
                this.subscribe(s)
            }
            )
        }
        _subscribe(n) {
            var r;
            return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)
        }
        [hs]() {
            return this
        }
        pipe(...n) {
            return x0(n)(this)
        }
        toPromise(n) {
            return n = Yv(n),
            new n((r,i)=>{
                let o;
                this.subscribe(s=>o = s, s=>i(s), ()=>r(o))
            }
            )
        }
    }
    return t.create = e=>new t(e),
    t
}
)();
function Yv(t) {
    var e;
    return (e = t ?? wr.Promise) !== null && e !== void 0 ? e : Promise
}
function O_(t) {
    return t && Re(t.next) && Re(t.error) && Re(t.complete)
}
function L_(t) {
    return t && t instanceof Co || O_(t) && yu(t)
}
function w0(t) {
    return Re(t?.lift)
}
function Qe(t) {
    return e=>{
        if (w0(e))
            return e.lift(function(n) {
                try {
                    return t(n, this)
                } catch (r) {
                    this.error(r)
                }
            });
        throw new TypeError("Unable to lift unknown Observable type")
    }
}
function Je(t, e, n, r, i) {
    return new b0(t,e,n,r,i)
}
var b0 = class extends Co {
    constructor(e, n, r, i, o, s) {
        super(e),
        this.onFinalize = o,
        this.shouldUnsubscribe = s,
        this._next = n ? function(a) {
            try {
                n(a)
            } catch (c) {
                e.error(c)
            }
        }
        : super._next,
        this._error = i ? function(a) {
            try {
                i(a)
            } catch (c) {
                e.error(c)
            } finally {
                this.unsubscribe()
            }
        }
        : super._error,
        this._complete = r ? function() {
            try {
                r()
            } catch (a) {
                e.error(a)
            } finally {
                this.unsubscribe()
            }
        }
        : super._complete
    }
    unsubscribe() {
        var e;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            let {closed: n} = this;
            super.unsubscribe(),
            !n && ((e = this.onFinalize) === null || e === void 0 || e.call(this))
        }
    }
}
;
function ps() {
    return Qe((t,e)=>{
        let n = null;
        t._refCount++;
        let r = Je(e, void 0, void 0, void 0, ()=>{
            if (!t || t._refCount <= 0 || 0 < --t._refCount) {
                n = null;
                return
            }
            let i = t._connection
              , o = n;
            n = null,
            i && (!o || i === o) && i.unsubscribe(),
            e.unsubscribe()
        }
        );
        t.subscribe(r),
        r.closed || (n = t.connect())
    }
    )
}
var gs = class extends ct {
    constructor(e, n) {
        super(),
        this.source = e,
        this.subjectFactory = n,
        this._subject = null,
        this._refCount = 0,
        this._connection = null,
        w0(e) && (this.lift = e.lift)
    }
    _subscribe(e) {
        return this.getSubject().subscribe(e)
    }
    getSubject() {
        let e = this._subject;
        return (!e || e.isStopped) && (this._subject = this.subjectFactory()),
        this._subject
    }
    _teardown() {
        this._refCount = 0;
        let {_connection: e} = this;
        this._subject = this._connection = null,
        e?.unsubscribe()
    }
    connect() {
        let e = this._connection;
        if (!e) {
            e = this._connection = new en;
            let n = this.getSubject();
            e.add(this.source.subscribe(Je(n, void 0, ()=>{
                this._teardown(),
                n.complete()
            }
            , r=>{
                this._teardown(),
                n.error(r)
            }
            , ()=>this._teardown()))),
            e.closed && (this._connection = null,
            e = en.EMPTY)
        }
        return e
    }
    refCount() {
        return ps()(this)
    }
}
;
var Zv = us(t=>function() {
    t(this),
    this.name = "ObjectUnsubscribedError",
    this.message = "object unsubscribed"
}
);
var Fn = (()=>{
    class t extends ct {
        constructor() {
            super(),
            this.closed = !1,
            this.currentObservers = null,
            this.observers = [],
            this.isStopped = !1,
            this.hasError = !1,
            this.thrownError = null
        }
        lift(n) {
            let r = new wu(this,this);
            return r.operator = n,
            r
        }
        _throwIfClosed() {
            if (this.closed)
                throw new Zv
        }
        next(n) {
            fs(()=>{
                if (this._throwIfClosed(),
                !this.isStopped) {
                    this.currentObservers || (this.currentObservers = Array.from(this.observers));
                    for (let r of this.currentObservers)
                        r.next(n)
                }
            }
            )
        }
        error(n) {
            fs(()=>{
                if (this._throwIfClosed(),
                !this.isStopped) {
                    this.hasError = this.isStopped = !0,
                    this.thrownError = n;
                    let {observers: r} = this;
                    for (; r.length; )
                        r.shift().error(n)
                }
            }
            )
        }
        complete() {
            fs(()=>{
                if (this._throwIfClosed(),
                !this.isStopped) {
                    this.isStopped = !0;
                    let {observers: n} = this;
                    for (; n.length; )
                        n.shift().complete()
                }
            }
            )
        }
        unsubscribe() {
            this.isStopped = this.closed = !0,
            this.observers = this.currentObservers = null
        }
        get observed() {
            var n;
            return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0
        }
        _trySubscribe(n) {
            return this._throwIfClosed(),
            super._trySubscribe(n)
        }
        _subscribe(n) {
            return this._throwIfClosed(),
            this._checkFinalizedStatuses(n),
            this._innerSubscribe(n)
        }
        _innerSubscribe(n) {
            let {hasError: r, isStopped: i, observers: o} = this;
            return r || i ? h0 : (this.currentObservers = null,
            o.push(n),
            new en(()=>{
                this.currentObservers = null,
                Ta(o, n)
            }
            ))
        }
        _checkFinalizedStatuses(n) {
            let {hasError: r, thrownError: i, isStopped: o} = this;
            r ? n.error(i) : o && n.complete()
        }
        asObservable() {
            let n = new ct;
            return n.source = this,
            n
        }
    }
    return t.create = (e,n)=>new wu(e,n),
    t
}
)()
  , wu = class extends Fn {
    constructor(e, n) {
        super(),
        this.destination = e,
        this.source = n
    }
    next(e) {
        var n, r;
        (r = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || r === void 0 || r.call(n, e)
    }
    error(e) {
        var n, r;
        (r = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || r === void 0 || r.call(n, e)
    }
    complete() {
        var e, n;
        (n = (e = this.destination) === null || e === void 0 ? void 0 : e.complete) === null || n === void 0 || n.call(e)
    }
    _subscribe(e) {
        var n, r;
        return (r = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e)) !== null && r !== void 0 ? r : h0
    }
}
;
var dn = class extends Fn {
    constructor(e) {
        super(),
        this._value = e
    }
    get value() {
        return this.getValue()
    }
    _subscribe(e) {
        let n = super._subscribe(e);
        return !n.closed && e.next(this._value),
        n
    }
    getValue() {
        let {hasError: e, thrownError: n, _value: r} = this;
        if (e)
            throw n;
        return this._throwIfClosed(),
        r
    }
    next(e) {
        super.next(this._value = e)
    }
}
;
var Yn = new ct(t=>t.complete());
function Xv(t) {
    return t && Re(t.schedule)
}
function Qv(t) {
    return t[t.length - 1]
}
function Jv(t) {
    return Re(Qv(t)) ? t.pop() : void 0
}
function Ri(t) {
    return Xv(Qv(t)) ? t.pop() : void 0
}
function tx(t, e, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(s) {
            s(o)
        }
        )
    }
    return new (n || (n = Promise))(function(o, s) {
        function a(l) {
            try {
                u(r.next(l))
            } catch (d) {
                s(d)
            }
        }
        function c(l) {
            try {
                u(r.throw(l))
            } catch (d) {
                s(d)
            }
        }
        function u(l) {
            l.done ? o(l.value) : i(l.value).then(a, c)
        }
        u((r = r.apply(t, e || [])).next())
    }
    )
}
function ex(t) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , n = e && t[e]
      , r = 0;
    if (n)
        return n.call(t);
    if (t && typeof t.length == "number")
        return {
            next: function() {
                return t && r >= t.length && (t = void 0),
                {
                    value: t && t[r++],
                    done: !t
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function Do(t) {
    return this instanceof Do ? (this.v = t,
    this) : new Do(t)
}
function nx(t, e, n) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = n.apply(t, e || []), i, o = [];
    return i = {},
    a("next"),
    a("throw"),
    a("return", s),
    i[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    i;
    function s(v) {
        return function(E) {
            return Promise.resolve(E).then(v, d)
        }
    }
    function a(v, E) {
        r[v] && (i[v] = function(D) {
            return new Promise(function(S, w) {
                o.push([v, D, S, w]) > 1 || c(v, D)
            }
            )
        }
        ,
        E && (i[v] = E(i[v])))
    }
    function c(v, E) {
        try {
            u(r[v](E))
        } catch (D) {
            y(o[0][3], D)
        }
    }
    function u(v) {
        v.value instanceof Do ? Promise.resolve(v.value.v).then(l, d) : y(o[0][2], v)
    }
    function l(v) {
        c("next", v)
    }
    function d(v) {
        c("throw", v)
    }
    function y(v, E) {
        v(E),
        o.shift(),
        o.length && c(o[0][0], o[0][1])
    }
}
function rx(t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator], n;
    return e ? e.call(t) : (t = typeof ex == "function" ? ex(t) : t[Symbol.iterator](),
    n = {},
    r("next"),
    r("throw"),
    r("return"),
    n[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    n);
    function r(o) {
        n[o] = t[o] && function(s) {
            return new Promise(function(a, c) {
                s = t[o](s),
                i(a, c, s.done, s.value)
            }
            )
        }
    }
    function i(o, s, a, c) {
        Promise.resolve(c).then(function(u) {
            o({
                value: u,
                done: a
            })
        }, s)
    }
}
var bu = t=>t && typeof t.length == "number" && typeof t != "function";
function Eu(t) {
    return Re(t?.then)
}
function Cu(t) {
    return Re(t[hs])
}
function Du(t) {
    return Symbol.asyncIterator && Re(t?.[Symbol.asyncIterator])
}
function Iu(t) {
    return new TypeError(`You provided ${t !== null && typeof t == "object" ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)
}
function U_() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator
}
var Au = U_();
function _u(t) {
    return Re(t?.[Au])
}
function Su(t) {
    return nx(this, arguments, function*() {
        let n = t.getReader();
        try {
            for (; ; ) {
                let {value: r, done: i} = yield Do(n.read());
                if (i)
                    return yield Do(void 0);
                yield yield Do(r)
            }
        } finally {
            n.releaseLock()
        }
    })
}
function Mu(t) {
    return Re(t?.getReader)
}
function sn(t) {
    if (t instanceof ct)
        return t;
    if (t != null) {
        if (Cu(t))
            return V_(t);
        if (bu(t))
            return j_(t);
        if (Eu(t))
            return $_(t);
        if (Du(t))
            return ix(t);
        if (_u(t))
            return H_(t);
        if (Mu(t))
            return z_(t)
    }
    throw Iu(t)
}
function V_(t) {
    return new ct(e=>{
        let n = t[hs]();
        if (Re(n.subscribe))
            return n.subscribe(e);
        throw new TypeError("Provided object does not correctly implement Symbol.observable")
    }
    )
}
function j_(t) {
    return new ct(e=>{
        for (let n = 0; n < t.length && !e.closed; n++)
            e.next(t[n]);
        e.complete()
    }
    )
}
function $_(t) {
    return new ct(e=>{
        t.then(n=>{
            e.closed || (e.next(n),
            e.complete())
        }
        , n=>e.error(n)).then(null, vu)
    }
    )
}
function H_(t) {
    return new ct(e=>{
        for (let n of t)
            if (e.next(n),
            e.closed)
                return;
        e.complete()
    }
    )
}
function ix(t) {
    return new ct(e=>{
        q_(t, e).catch(n=>e.error(n))
    }
    )
}
function z_(t) {
    return ix(Su(t))
}
function q_(t, e) {
    var n, r, i, o;
    return tx(this, void 0, void 0, function*() {
        try {
            for (n = rx(t); r = yield n.next(),
            !r.done; ) {
                let s = r.value;
                if (e.next(s),
                e.closed)
                    return
            }
        } catch (s) {
            i = {
                error: s
            }
        } finally {
            try {
                r && !r.done && (o = n.return) && (yield o.call(n))
            } finally {
                if (i)
                    throw i.error
            }
        }
        e.complete()
    })
}
function Un(t, e, n, r=0, i=!1) {
    let o = e.schedule(function() {
        n(),
        i ? t.add(this.schedule(null, r)) : this.unsubscribe()
    }, r);
    if (t.add(o),
    !i)
        return o
}
function ku(t, e=0) {
    return Qe((n,r)=>{
        n.subscribe(Je(r, i=>Un(r, t, ()=>r.next(i), e), ()=>Un(r, t, ()=>r.complete(), e), i=>Un(r, t, ()=>r.error(i), e)))
    }
    )
}
function Tu(t, e=0) {
    return Qe((n,r)=>{
        r.add(t.schedule(()=>n.subscribe(r), e))
    }
    )
}
function ox(t, e) {
    return sn(t).pipe(Tu(e), ku(e))
}
function sx(t, e) {
    return sn(t).pipe(Tu(e), ku(e))
}
function ax(t, e) {
    return new ct(n=>{
        let r = 0;
        return e.schedule(function() {
            r === t.length ? n.complete() : (n.next(t[r++]),
            n.closed || this.schedule())
        })
    }
    )
}
function cx(t, e) {
    return new ct(n=>{
        let r;
        return Un(n, e, ()=>{
            r = t[Au](),
            Un(n, e, ()=>{
                let i, o;
                try {
                    ({value: i, done: o} = r.next())
                } catch (s) {
                    n.error(s);
                    return
                }
                o ? n.complete() : n.next(i)
            }
            , 0, !0)
        }
        ),
        ()=>Re(r?.return) && r.return()
    }
    )
}
function Bu(t, e) {
    if (!t)
        throw new Error("Iterable cannot be null");
    return new ct(n=>{
        Un(n, e, ()=>{
            let r = t[Symbol.asyncIterator]();
            Un(n, e, ()=>{
                r.next().then(i=>{
                    i.done ? n.complete() : n.next(i.value)
                }
                )
            }
            , 0, !0)
        }
        )
    }
    )
}
function ux(t, e) {
    return Bu(Su(t), e)
}
function lx(t, e) {
    if (t != null) {
        if (Cu(t))
            return ox(t, e);
        if (bu(t))
            return ax(t, e);
        if (Eu(t))
            return sx(t, e);
        if (Du(t))
            return Bu(t, e);
        if (_u(t))
            return cx(t, e);
        if (Mu(t))
            return ux(t, e)
    }
    throw Iu(t)
}
function Mt(t, e) {
    return e ? lx(t, e) : sn(t)
}
function Ie(...t) {
    let e = Ri(t);
    return Mt(t, e)
}
function ms(t, e) {
    let n = Re(t) ? t : ()=>t
      , r = i=>i.error(n());
    return new ct(e ? i=>e.schedule(r, 0, i) : r)
}
function E0(t) {
    return !!t && (t instanceof ct || Re(t.lift) && Re(t.subscribe))
}
var ii = us(t=>function() {
    t(this),
    this.name = "EmptyError",
    this.message = "no elements in sequence"
}
);
function Ue(t, e) {
    return Qe((n,r)=>{
        let i = 0;
        n.subscribe(Je(r, o=>{
            r.next(t.call(e, o, i++))
        }
        ))
    }
    )
}
var {isArray: W_} = Array;
function G_(t, e) {
    return W_(e) ? t(...e) : t(e)
}
function fx(t) {
    return Ue(e=>G_(t, e))
}
var {isArray: K_} = Array
  , {getPrototypeOf: Y_, prototype: Z_, keys: X_} = Object;
function dx(t) {
    if (t.length === 1) {
        let e = t[0];
        if (K_(e))
            return {
                args: e,
                keys: null
            };
        if (Q_(e)) {
            let n = X_(e);
            return {
                args: n.map(r=>e[r]),
                keys: n
            }
        }
    }
    return {
        args: t,
        keys: null
    }
}
function Q_(t) {
    return t && typeof t == "object" && Y_(t) === Z_
}
function hx(t, e) {
    return t.reduce((n,r,i)=>(n[r] = e[i],
    n), {})
}
function Ra(...t) {
    let e = Ri(t)
      , n = Jv(t)
      , {args: r, keys: i} = dx(t);
    if (r.length === 0)
        return Mt([], e);
    let o = new ct(J_(r, e, i ? s=>hx(i, s) : Kn));
    return n ? o.pipe(fx(n)) : o
}
function J_(t, e, n=Kn) {
    return r=>{
        px(e, ()=>{
            let {length: i} = t
              , o = new Array(i)
              , s = i
              , a = i;
            for (let c = 0; c < i; c++)
                px(e, ()=>{
                    let u = Mt(t[c], e)
                      , l = !1;
                    u.subscribe(Je(r, d=>{
                        o[c] = d,
                        l || (l = !0,
                        a--),
                        a || r.next(n(o.slice()))
                    }
                    , ()=>{
                        --s || r.complete()
                    }
                    ))
                }
                , r)
        }
        , r)
    }
}
function px(t, e, n) {
    t ? Un(n, t, e) : e()
}
function gx(t, e, n, r, i, o, s, a) {
    let c = []
      , u = 0
      , l = 0
      , d = !1
      , y = ()=>{
        d && !c.length && !u && e.complete()
    }
      , v = D=>u < r ? E(D) : c.push(D)
      , E = D=>{
        o && e.next(D),
        u++;
        let S = !1;
        sn(n(D, l++)).subscribe(Je(e, w=>{
            i?.(w),
            o ? v(w) : e.next(w)
        }
        , ()=>{
            S = !0
        }
        , void 0, ()=>{
            if (S)
                try {
                    for (u--; c.length && u < r; ) {
                        let w = c.shift();
                        s ? Un(e, s, ()=>E(w)) : E(w)
                    }
                    y()
                } catch (w) {
                    e.error(w)
                }
        }
        ))
    }
    ;
    return t.subscribe(Je(e, v, ()=>{
        d = !0,
        y()
    }
    )),
    ()=>{
        a?.()
    }
}
function Zt(t, e, n=1 / 0) {
    return Re(e) ? Zt((r,i)=>Ue((o,s)=>e(r, o, i, s))(sn(t(r, i))), n) : (typeof e == "number" && (n = e),
    Qe((r,i)=>gx(r, i, t, n)))
}
function ys(t=1 / 0) {
    return Zt(Kn, t)
}
function mx() {
    return ys(1)
}
function vs(...t) {
    return mx()(Mt(t, Ri(t)))
}
function Ru(t) {
    return new ct(e=>{
        sn(t()).subscribe(e)
    }
    )
}
function Vn(t, e) {
    return Qe((n,r)=>{
        let i = 0;
        n.subscribe(Je(r, o=>t.call(e, o, i++) && r.next(o)))
    }
    )
}
function Fi(t) {
    return Qe((e,n)=>{
        let r = null, i = !1, o;
        r = e.subscribe(Je(n, void 0, void 0, s=>{
            o = sn(t(s, Fi(t)(e))),
            r ? (r.unsubscribe(),
            r = null,
            o.subscribe(n)) : i = !0
        }
        )),
        i && (r.unsubscribe(),
        r = null,
        o.subscribe(n))
    }
    )
}
function yx(t, e, n, r, i) {
    return (o,s)=>{
        let a = n
          , c = e
          , u = 0;
        o.subscribe(Je(s, l=>{
            let d = u++;
            c = a ? t(c, l, d) : (a = !0,
            l),
            r && s.next(c)
        }
        , i && (()=>{
            a && s.next(c),
            s.complete()
        }
        )))
    }
}
function oi(t, e) {
    return Re(e) ? Zt(t, e, 1) : Zt(t, 1)
}
function Ni(t) {
    return Qe((e,n)=>{
        let r = !1;
        e.subscribe(Je(n, i=>{
            r = !0,
            n.next(i)
        }
        , ()=>{
            r || n.next(t),
            n.complete()
        }
        ))
    }
    )
}
function si(t) {
    return t <= 0 ? ()=>Yn : Qe((e,n)=>{
        let r = 0;
        e.subscribe(Je(n, i=>{
            ++r <= t && (n.next(i),
            t <= r && n.complete())
        }
        ))
    }
    )
}
function C0(t) {
    return Ue(()=>t)
}
function Fu(t=eS) {
    return Qe((e,n)=>{
        let r = !1;
        e.subscribe(Je(n, i=>{
            r = !0,
            n.next(i)
        }
        , ()=>r ? n.complete() : n.error(t())))
    }
    )
}
function eS() {
    return new ii
}
function Pi(t) {
    return Qe((e,n)=>{
        try {
            e.subscribe(n)
        } finally {
            n.add(t)
        }
    }
    )
}
function Pr(t, e) {
    let n = arguments.length >= 2;
    return r=>r.pipe(t ? Vn((i,o)=>t(i, o, r)) : Kn, si(1), n ? Ni(e) : Fu(()=>new ii))
}
function xs(t) {
    return t <= 0 ? ()=>Yn : Qe((e,n)=>{
        let r = [];
        e.subscribe(Je(n, i=>{
            r.push(i),
            t < r.length && r.shift()
        }
        , ()=>{
            for (let i of r)
                n.next(i);
            n.complete()
        }
        , void 0, ()=>{
            r = null
        }
        ))
    }
    )
}
function D0(t, e) {
    let n = arguments.length >= 2;
    return r=>r.pipe(t ? Vn((i,o)=>t(i, o, r)) : Kn, xs(1), n ? Ni(e) : Fu(()=>new ii))
}
function I0(t, e) {
    return Qe(yx(t, e, arguments.length >= 2, !0))
}
function A0(...t) {
    let e = Ri(t);
    return Qe((n,r)=>{
        (e ? vs(t, n, e) : vs(t, n)).subscribe(r)
    }
    )
}
function jn(t, e) {
    return Qe((n,r)=>{
        let i = null
          , o = 0
          , s = !1
          , a = ()=>s && !i && r.complete();
        n.subscribe(Je(r, c=>{
            i?.unsubscribe();
            let u = 0
              , l = o++;
            sn(t(c, l)).subscribe(i = Je(r, d=>r.next(e ? e(c, d, l, u++) : d), ()=>{
                i = null,
                a()
            }
            ))
        }
        , ()=>{
            s = !0,
            a()
        }
        ))
    }
    )
}
function _0(t) {
    return Qe((e,n)=>{
        sn(t).subscribe(Je(n, ()=>n.complete(), Ba)),
        !n.closed && e.subscribe(n)
    }
    )
}
function an(t, e, n) {
    let r = Re(t) || e || n ? {
        next: t,
        error: e,
        complete: n
    } : t;
    return r ? Qe((i,o)=>{
        var s;
        (s = r.subscribe) === null || s === void 0 || s.call(r);
        let a = !0;
        i.subscribe(Je(o, c=>{
            var u;
            (u = r.next) === null || u === void 0 || u.call(r, c),
            o.next(c)
        }
        , ()=>{
            var c;
            a = !1,
            (c = r.complete) === null || c === void 0 || c.call(r),
            o.complete()
        }
        , c=>{
            var u;
            a = !1,
            (u = r.error) === null || u === void 0 || u.call(r, c),
            o.error(c)
        }
        , ()=>{
            var c, u;
            a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)),
            (u = r.finalize) === null || u === void 0 || u.call(r)
        }
        ))
    }
    ) : Kn
}
var ew = "https://g.co/ng/security#xss"
  , we = class extends Error {
    constructor(e, n) {
        super(fl(e, n)),
        this.code = e
    }
}
;
function fl(t, e) {
    return `${`NG0${Math.abs(t)}`}${e ? ": " + e : ""}`
}
function Ka(t) {
    return {
        toString: t
    }.toString()
}
var Nu = "__parameters__";
function tS(t) {
    return function(...n) {
        if (t) {
            let r = t(...n);
            for (let i in r)
                this[i] = r[i]
        }
    }
}
function tw(t, e, n) {
    return Ka(()=>{
        let r = tS(e);
        function i(...o) {
            if (this instanceof i)
                return r.apply(this, o),
                this;
            let s = new i(...o);
            return a.annotation = s,
            a;
            function a(c, u, l) {
                let d = c.hasOwnProperty(Nu) ? c[Nu] : Object.defineProperty(c, Nu, {
                    value: []
                })[Nu];
                for (; d.length <= l; )
                    d.push(null);
                return (d[l] = d[l] || []).push(s),
                c
            }
        }
        return n && (i.prototype = Object.create(n.prototype)),
        i.prototype.ngMetadataName = t,
        i.annotationCls = i,
        i
    }
    )
}
var Xn = globalThis;
function bt(t) {
    for (let e in t)
        if (t[e] === bt)
            return e;
    throw Error("Could not find renamed property on target object.")
}
function $n(t) {
    if (typeof t == "string")
        return t;
    if (Array.isArray(t))
        return "[" + t.map($n).join(", ") + "]";
    if (t == null)
        return "" + t;
    if (t.overriddenName)
        return `${t.overriddenName}`;
    if (t.name)
        return `${t.name}`;
    let e = t.toString();
    if (e == null)
        return "" + e;
    let n = e.indexOf(`
`);
    return n === -1 ? e : e.substring(0, n)
}
function V0(t, e) {
    return t == null || t === "" ? e === null ? "" : e : e == null || e === "" ? t : t + " " + e
}
var nS = bt({
    __forward_ref__: bt
});
function _p(t) {
    return t.__forward_ref__ = _p,
    t.toString = function() {
        return $n(this())
    }
    ,
    t
}
function or(t) {
    return nw(t) ? t() : t
}
function nw(t) {
    return typeof t == "function" && t.hasOwnProperty(nS) && t.__forward_ref__ === _p
}
function he(t) {
    return {
        token: t.token,
        providedIn: t.providedIn || null,
        factory: t.factory,
        value: void 0
    }
}
function hn(t) {
    return {
        providers: t.providers || [],
        imports: t.imports || []
    }
}
function dl(t) {
    return vx(t, iw) || vx(t, ow)
}
function rw(t) {
    return dl(t) !== null
}
function vx(t, e) {
    return t.hasOwnProperty(e) ? t[e] : null
}
function rS(t) {
    let e = t && (t[iw] || t[ow]);
    return e || null
}
function xx(t) {
    return t && (t.hasOwnProperty(wx) || t.hasOwnProperty(iS)) ? t[wx] : null
}
var iw = bt({
    \u0275prov: bt
})
  , wx = bt({
    \u0275inj: bt
})
  , ow = bt({
    ngInjectableDef: bt
})
  , iS = bt({
    ngInjectorDef: bt
})
  , be = class {
    constructor(e, n) {
        this._desc = e,
        this.ngMetadataName = "InjectionToken",
        this.\u0275prov = void 0,
        typeof n == "number" ? this.__NG_ELEMENT_ID__ = n : n !== void 0 && (this.\u0275prov = he({
            token: this,
            providedIn: n.providedIn || "root",
            factory: n.factory
        }))
    }
    get multi() {
        return this
    }
    toString() {
        return `InjectionToken ${this._desc}`
    }
}
;
function sw(t) {
    return t && !!t.\u0275providers
}
var oS = bt({
    \u0275cmp: bt
})
  , sS = bt({
    \u0275dir: bt
})
  , aS = bt({
    \u0275pipe: bt
})
  , cS = bt({
    \u0275mod: bt
})
  , Hu = bt({
    \u0275fac: bt
})
  , Fa = bt({
    __NG_ELEMENT_ID__: bt
})
  , bx = bt({
    __NG_ENV_ID__: bt
});
function Sp(t) {
    return typeof t == "string" ? t : t == null ? "" : String(t)
}
function uS(t) {
    return typeof t == "function" ? t.name || t.toString() : typeof t == "object" && t != null && typeof t.type == "function" ? t.type.name || t.type.toString() : Sp(t)
}
function lS(t, e) {
    let n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : "";
    throw new we(-200,t)
}
function Mp(t, e) {
    throw new we(-201,!1)
}
var $e = function(t) {
    return t[t.Default = 0] = "Default",
    t[t.Host = 1] = "Host",
    t[t.Self = 2] = "Self",
    t[t.SkipSelf = 4] = "SkipSelf",
    t[t.Optional = 8] = "Optional",
    t
}($e || {}), j0;
function aw() {
    return j0
}
function ir(t) {
    let e = j0;
    return j0 = t,
    e
}
function cw(t, e, n) {
    let r = dl(t);
    if (r && r.providedIn == "root")
        return r.value === void 0 ? r.value = r.factory() : r.value;
    if (n & $e.Optional)
        return null;
    if (e !== void 0)
        return e;
    Mp(t, "Injector")
}
var fS = {}, Pa = fS, $0 = "__NG_DI_FLAG__", zu = "ngTempTokenPath", dS = "ngTokenPath", hS = /\n/gm, pS = "\u0275", Ex = "__source", Ds;
function gS() {
    return Ds
}
function Oi(t) {
    let e = Ds;
    return Ds = t,
    e
}
function mS(t, e=$e.Default) {
    if (Ds === void 0)
        throw new we(-203,!1);
    return Ds === null ? cw(t, void 0, e) : Ds.get(t, e & $e.Optional ? null : void 0, e)
}
function ve(t, e=$e.Default) {
    return (aw() || mS)(or(t), e)
}
function ie(t, e=$e.Default) {
    return ve(t, hl(e))
}
function hl(t) {
    return typeof t > "u" || typeof t == "number" ? t : 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)
}
function H0(t) {
    let e = [];
    for (let n = 0; n < t.length; n++) {
        let r = or(t[n]);
        if (Array.isArray(r)) {
            if (r.length === 0)
                throw new we(900,!1);
            let i, o = $e.Default;
            for (let s = 0; s < r.length; s++) {
                let a = r[s]
                  , c = yS(a);
                typeof c == "number" ? c === -1 ? i = a.token : o |= c : i = a
            }
            e.push(ve(i, o))
        } else
            e.push(ve(r))
    }
    return e
}
function uw(t, e) {
    return t[$0] = e,
    t.prototype[$0] = e,
    t
}
function yS(t) {
    return t[$0]
}
function vS(t, e, n, r) {
    let i = t[zu];
    throw e[Ex] && i.unshift(e[Ex]),
    t.message = xS(`
` + t.message, i, n, r),
    t[dS] = i,
    t[zu] = null,
    t
}
function xS(t, e, n, r=null) {
    t = t && t.charAt(0) === `
` && t.charAt(1) == pS ? t.slice(2) : t;
    let i = $n(e);
    if (Array.isArray(e))
        i = e.map($n).join(" -> ");
    else if (typeof e == "object") {
        let o = [];
        for (let s in e)
            if (e.hasOwnProperty(s)) {
                let a = e[s];
                o.push(s + ":" + (typeof a == "string" ? JSON.stringify(a) : $n(a)))
            }
        i = `{${o.join(", ")}}`
    }
    return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${t.replace(hS, `
  `)}`
}
var pl = uw(tw("Optional"), 8);
var kp = uw(tw("SkipSelf"), 4);
function _s(t, e) {
    let n = t.hasOwnProperty(Hu);
    return n ? t[Hu] : null
}
function Tp(t, e) {
    t.forEach(n=>Array.isArray(n) ? Tp(n, e) : e(n))
}
function lw(t, e, n) {
    e >= t.length ? t.push(n) : t.splice(e, 0, n)
}
function qu(t, e) {
    return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0]
}
function wS(t, e, n, r) {
    let i = t.length;
    if (i == e)
        t.push(n, r);
    else if (i === 1)
        t.push(r, t[0]),
        t[0] = n;
    else {
        for (i--,
        t.push(t[i - 1], t[i]); i > e; ) {
            let o = i - 2;
            t[i] = t[o],
            i--
        }
        t[e] = n,
        t[e + 1] = r
    }
}
function Bp(t, e, n) {
    let r = Ya(t, e);
    return r >= 0 ? t[r | 1] = n : (r = ~r,
    wS(t, r, e, n)),
    r
}
function S0(t, e) {
    let n = Ya(t, e);
    if (n >= 0)
        return t[n | 1]
}
function Ya(t, e) {
    return bS(t, e, 1)
}
function bS(t, e, n) {
    let r = 0
      , i = t.length >> n;
    for (; i !== r; ) {
        let o = r + (i - r >> 1)
          , s = t[o << n];
        if (e === s)
            return o << n;
        s > e ? i = o : r = o + 1
    }
    return ~(i << n)
}
var Oa = {}
  , Zn = []
  , Ss = new be("")
  , fw = new be("",-1)
  , dw = new be("")
  , Wu = class {
    get(e, n=Pa) {
        if (n === Pa) {
            let r = new Error(`NullInjectorError: No provider for ${$n(e)}!`);
            throw r.name = "NullInjectorError",
            r
        }
        return n
    }
}
  , hw = function(t) {
    return t[t.OnPush = 0] = "OnPush",
    t[t.Default = 1] = "Default",
    t
}(hw || {})
  , Ur = function(t) {
    return t[t.Emulated = 0] = "Emulated",
    t[t.None = 2] = "None",
    t[t.ShadowDom = 3] = "ShadowDom",
    t
}(Ur || {})
  , ai = function(t) {
    return t[t.None = 0] = "None",
    t[t.SignalBased = 1] = "SignalBased",
    t[t.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform",
    t
}(ai || {});
function ES(t, e, n) {
    let r = t.length;
    for (; ; ) {
        let i = t.indexOf(e, n);
        if (i === -1)
            return i;
        if (i === 0 || t.charCodeAt(i - 1) <= 32) {
            let o = e.length;
            if (i + o === r || t.charCodeAt(i + o) <= 32)
                return i
        }
        n = i + 1
    }
}
function z0(t, e, n) {
    let r = 0;
    for (; r < n.length; ) {
        let i = n[r];
        if (typeof i == "number") {
            if (i !== 0)
                break;
            r++;
            let o = n[r++]
              , s = n[r++]
              , a = n[r++];
            t.setAttribute(e, s, a, o)
        } else {
            let o = i
              , s = n[++r];
            DS(o) ? t.setProperty(e, o, s) : t.setAttribute(e, o, s),
            r++
        }
    }
    return r
}
function CS(t) {
    return t === 3 || t === 4 || t === 6
}
function DS(t) {
    return t.charCodeAt(0) === 64
}
function Rp(t, e) {
    if (!(e === null || e.length === 0))
        if (t === null || t.length === 0)
            t = e.slice();
        else {
            let n = -1;
            for (let r = 0; r < e.length; r++) {
                let i = e[r];
                typeof i == "number" ? n = i : n === 0 || (n === -1 || n === 2 ? Cx(t, n, i, null, e[++r]) : Cx(t, n, i, null, null))
            }
        }
    return t
}
function Cx(t, e, n, r, i) {
    let o = 0
      , s = t.length;
    if (e === -1)
        s = -1;
    else
        for (; o < t.length; ) {
            let a = t[o++];
            if (typeof a == "number") {
                if (a === e) {
                    s = -1;
                    break
                } else if (a > e) {
                    s = o - 1;
                    break
                }
            }
        }
    for (; o < t.length; ) {
        let a = t[o];
        if (typeof a == "number")
            break;
        if (a === n) {
            if (r === null) {
                i !== null && (t[o + 1] = i);
                return
            } else if (r === t[o + 1]) {
                t[o + 2] = i;
                return
            }
        }
        o++,
        r !== null && o++,
        i !== null && o++
    }
    s !== -1 && (t.splice(s, 0, e),
    o = s + 1),
    t.splice(o++, 0, n),
    r !== null && t.splice(o++, 0, r),
    i !== null && t.splice(o++, 0, i)
}
var pw = "ng-template";
function IS(t, e, n, r) {
    let i = 0;
    if (r) {
        for (; i < e.length && typeof e[i] == "string"; i += 2)
            if (e[i] === "class" && ES(e[i + 1].toLowerCase(), n, 0) !== -1)
                return !0
    } else if (Fp(t))
        return !1;
    if (i = e.indexOf(1, i),
    i > -1) {
        let o;
        for (; ++i < e.length && typeof (o = e[i]) == "string"; )
            if (o.toLowerCase() === n)
                return !0
    }
    return !1
}
function Fp(t) {
    return t.type === 4 && t.value !== pw
}
function AS(t, e, n) {
    let r = t.type === 4 && !n ? pw : t.value;
    return e === r
}
function _S(t, e, n) {
    let r = 4
      , i = t.attrs
      , o = i !== null ? kS(i) : 0
      , s = !1;
    for (let a = 0; a < e.length; a++) {
        let c = e[a];
        if (typeof c == "number") {
            if (!s && !br(r) && !br(c))
                return !1;
            if (s && br(c))
                continue;
            s = !1,
            r = c | r & 1;
            continue
        }
        if (!s)
            if (r & 4) {
                if (r = 2 | r & 1,
                c !== "" && !AS(t, c, n) || c === "" && e.length === 1) {
                    if (br(r))
                        return !1;
                    s = !0
                }
            } else if (r & 8) {
                if (i === null || !IS(t, i, c, n)) {
                    if (br(r))
                        return !1;
                    s = !0
                }
            } else {
                let u = e[++a]
                  , l = SS(c, i, Fp(t), n);
                if (l === -1) {
                    if (br(r))
                        return !1;
                    s = !0;
                    continue
                }
                if (u !== "") {
                    let d;
                    if (l > o ? d = "" : d = i[l + 1].toLowerCase(),
                    r & 2 && u !== d) {
                        if (br(r))
                            return !1;
                        s = !0
                    }
                }
            }
    }
    return br(r) || s
}
function br(t) {
    return (t & 1) === 0
}
function SS(t, e, n, r) {
    if (e === null)
        return -1;
    let i = 0;
    if (r || !n) {
        let o = !1;
        for (; i < e.length; ) {
            let s = e[i];
            if (s === t)
                return i;
            if (s === 3 || s === 6)
                o = !0;
            else if (s === 1 || s === 2) {
                let a = e[++i];
                for (; typeof a == "string"; )
                    a = e[++i];
                continue
            } else {
                if (s === 4)
                    break;
                if (s === 0) {
                    i += 4;
                    continue
                }
            }
            i += o ? 1 : 2
        }
        return -1
    } else
        return TS(e, t)
}
function MS(t, e, n=!1) {
    for (let r = 0; r < e.length; r++)
        if (_S(t, e[r], n))
            return !0;
    return !1
}
function kS(t) {
    for (let e = 0; e < t.length; e++) {
        let n = t[e];
        if (CS(n))
            return e
    }
    return t.length
}
function TS(t, e) {
    let n = t.indexOf(4);
    if (n > -1)
        for (n++; n < t.length; ) {
            let r = t[n];
            if (typeof r == "number")
                return -1;
            if (r === e)
                return n;
            n++
        }
    return -1
}
function Dx(t, e) {
    return t ? ":not(" + e.trim() + ")" : e
}
function BS(t) {
    let e = t[0]
      , n = 1
      , r = 2
      , i = ""
      , o = !1;
    for (; n < t.length; ) {
        let s = t[n];
        if (typeof s == "string")
            if (r & 2) {
                let a = t[++n];
                i += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]"
            } else
                r & 8 ? i += "." + s : r & 4 && (i += " " + s);
        else
            i !== "" && !br(s) && (e += Dx(o, i),
            i = ""),
            r = s,
            o = o || !br(r);
        n++
    }
    return i !== "" && (e += Dx(o, i)),
    e
}
function RS(t) {
    return t.map(BS).join(",")
}
function FS(t) {
    let e = []
      , n = []
      , r = 1
      , i = 2;
    for (; r < t.length; ) {
        let o = t[r];
        if (typeof o == "string")
            i === 2 ? o !== "" && e.push(o, t[++r]) : i === 8 && n.push(o);
        else {
            if (!br(i))
                break;
            i = o
        }
        r++
    }
    return {
        attrs: e,
        classes: n
    }
}
function Rs(t) {
    return Ka(()=>{
        let e = xw(t)
          , n = me(ee({}, e), {
            decls: t.decls,
            vars: t.vars,
            template: t.template,
            consts: t.consts || null,
            ngContentSelectors: t.ngContentSelectors,
            onPush: t.changeDetection === hw.OnPush,
            directiveDefs: null,
            pipeDefs: null,
            dependencies: e.standalone && t.dependencies || null,
            getStandaloneInjector: null,
            signals: t.signals ?? !1,
            data: t.data || {},
            encapsulation: t.encapsulation || Ur.Emulated,
            styles: t.styles || Zn,
            _: null,
            schemas: t.schemas || null,
            tView: null,
            id: ""
        });
        ww(n);
        let r = t.dependencies;
        return n.directiveDefs = Ax(r, !1),
        n.pipeDefs = Ax(r, !0),
        n.id = OS(n),
        n
    }
    )
}
function NS(t) {
    return Ui(t) || gw(t)
}
function PS(t) {
    return t !== null
}
function pn(t) {
    return Ka(()=>({
        type: t.type,
        bootstrap: t.bootstrap || Zn,
        declarations: t.declarations || Zn,
        imports: t.imports || Zn,
        exports: t.exports || Zn,
        transitiveCompileScopes: null,
        schemas: t.schemas || null,
        id: t.id || null
    }))
}
function Ix(t, e) {
    if (t == null)
        return Oa;
    let n = {};
    for (let r in t)
        if (t.hasOwnProperty(r)) {
            let i = t[r], o, s, a = ai.None;
            Array.isArray(i) ? (a = i[0],
            o = i[1],
            s = i[2] ?? o) : (o = i,
            s = i),
            e ? (n[o] = a !== ai.None ? [r, a] : r,
            e[o] = s) : n[o] = r
        }
    return n
}
function Fs(t) {
    return Ka(()=>{
        let e = xw(t);
        return ww(e),
        e
    }
    )
}
function Ui(t) {
    return t[oS] || null
}
function gw(t) {
    return t[sS] || null
}
function mw(t) {
    return t[aS] || null
}
function yw(t) {
    let e = Ui(t) || gw(t) || mw(t);
    return e !== null ? e.standalone : !1
}
function vw(t, e) {
    let n = t[cS] || null;
    if (!n && e === !0)
        throw new Error(`Type ${$n(t)} does not have '\u0275mod' property.`);
    return n
}
function xw(t) {
    let e = {};
    return {
        type: t.type,
        providersResolver: null,
        factory: null,
        hostBindings: t.hostBindings || null,
        hostVars: t.hostVars || 0,
        hostAttrs: t.hostAttrs || null,
        contentQueries: t.contentQueries || null,
        declaredInputs: e,
        inputTransforms: null,
        inputConfig: t.inputs || Oa,
        exportAs: t.exportAs || null,
        standalone: t.standalone === !0,
        signals: t.signals === !0,
        selectors: t.selectors || Zn,
        viewQuery: t.viewQuery || null,
        features: t.features || null,
        setInput: null,
        findHostDirectiveDefs: null,
        hostDirectives: null,
        inputs: Ix(t.inputs, e),
        outputs: Ix(t.outputs),
        debugInfo: null
    }
}
function ww(t) {
    t.features?.forEach(e=>e(t))
}
function Ax(t, e) {
    if (!t)
        return null;
    let n = e ? mw : NS;
    return ()=>(typeof t == "function" ? t() : t).map(r=>n(r)).filter(PS)
}
function OS(t) {
    let e = 0
      , n = [t.selectors, t.ngContentSelectors, t.hostVars, t.hostAttrs, t.consts, t.vars, t.decls, t.encapsulation, t.standalone, t.signals, t.exportAs, JSON.stringify(t.inputs), JSON.stringify(t.outputs), Object.getOwnPropertyNames(t.type.prototype), !!t.contentQueries, !!t.viewQuery].join("|");
    for (let i of n)
        e = Math.imul(31, e) + i.charCodeAt(0) << 0;
    return e += 2147483648,
    "c" + e
}
function gl(t) {
    return {
        \u0275providers: t
    }
}
function LS(...t) {
    return {
        \u0275providers: bw(!0, t),
        \u0275fromNgModule: !0
    }
}
function bw(t, ...e) {
    let n = [], r = new Set, i, o = s=>{
        n.push(s)
    }
    ;
    return Tp(e, s=>{
        let a = s;
        q0(a, o, [], r) && (i ||= [],
        i.push(a))
    }
    ),
    i !== void 0 && Ew(i, o),
    n
}
function Ew(t, e) {
    for (let n = 0; n < t.length; n++) {
        let {ngModule: r, providers: i} = t[n];
        Np(i, o=>{
            e(o, r)
        }
        )
    }
}
function q0(t, e, n, r) {
    if (t = or(t),
    !t)
        return !1;
    let i = null
      , o = xx(t)
      , s = !o && Ui(t);
    if (!o && !s) {
        let c = t.ngModule;
        if (o = xx(c),
        o)
            i = c;
        else
            return !1
    } else {
        if (s && !s.standalone)
            return !1;
        i = t
    }
    let a = r.has(i);
    if (s) {
        if (a)
            return !1;
        if (r.add(i),
        s.dependencies) {
            let c = typeof s.dependencies == "function" ? s.dependencies() : s.dependencies;
            for (let u of c)
                q0(u, e, n, r)
        }
    } else if (o) {
        if (o.imports != null && !a) {
            r.add(i);
            let u;
            try {
                Tp(o.imports, l=>{
                    q0(l, e, n, r) && (u ||= [],
                    u.push(l))
                }
                )
            } finally {}
            u !== void 0 && Ew(u, e)
        }
        if (!a) {
            let u = _s(i) || (()=>new i);
            e({
                provide: i,
                useFactory: u,
                deps: Zn
            }, i),
            e({
                provide: dw,
                useValue: i,
                multi: !0
            }, i),
            e({
                provide: Ss,
                useValue: ()=>ve(i),
                multi: !0
            }, i)
        }
        let c = o.providers;
        if (c != null && !a) {
            let u = t;
            Np(c, l=>{
                e(l, u)
            }
            )
        }
    } else
        return !1;
    return i !== t && t.providers !== void 0
}
function Np(t, e) {
    for (let n of t)
        sw(n) && (n = n.\u0275providers),
        Array.isArray(n) ? Np(n, e) : e(n)
}
var US = bt({
    provide: String,
    useValue: bt
});
function Cw(t) {
    return t !== null && typeof t == "object" && US in t
}
function VS(t) {
    return !!(t && t.useExisting)
}
function jS(t) {
    return !!(t && t.useFactory)
}
function W0(t) {
    return typeof t == "function"
}
var ml = new be(""), Lu = {}, $S = {}, M0;
function Pp() {
    return M0 === void 0 && (M0 = new Wu),
    M0
}
var wn = class {
}
  , La = class extends wn {
    get destroyed() {
        return this._destroyed
    }
    constructor(e, n, r, i) {
        super(),
        this.parent = n,
        this.source = r,
        this.scopes = i,
        this.records = new Map,
        this._ngOnDestroyHooks = new Set,
        this._onDestroyHooks = [],
        this._destroyed = !1,
        K0(e, s=>this.processProvider(s)),
        this.records.set(fw, ws(void 0, this)),
        i.has("environment") && this.records.set(wn, ws(void 0, this));
        let o = this.records.get(ml);
        o != null && typeof o.value == "string" && this.scopes.add(o.value),
        this.injectorDefTypes = new Set(this.get(dw, Zn, $e.Self))
    }
    destroy() {
        this.assertNotDestroyed(),
        this._destroyed = !0;
        let e = at(null);
        try {
            for (let r of this._ngOnDestroyHooks)
                r.ngOnDestroy();
            let n = this._onDestroyHooks;
            this._onDestroyHooks = [];
            for (let r of n)
                r()
        } finally {
            this.records.clear(),
            this._ngOnDestroyHooks.clear(),
            this.injectorDefTypes.clear(),
            at(e)
        }
    }
    onDestroy(e) {
        return this.assertNotDestroyed(),
        this._onDestroyHooks.push(e),
        ()=>this.removeOnDestroy(e)
    }
    runInContext(e) {
        this.assertNotDestroyed();
        let n = Oi(this), r = ir(void 0), i;
        try {
            return e()
        } finally {
            Oi(n),
            ir(r)
        }
    }
    get(e, n=Pa, r=$e.Default) {
        if (this.assertNotDestroyed(),
        e.hasOwnProperty(bx))
            return e[bx](this);
        r = hl(r);
        let i, o = Oi(this), s = ir(void 0);
        try {
            if (!(r & $e.SkipSelf)) {
                let c = this.records.get(e);
                if (c === void 0) {
                    let u = KS(e) && dl(e);
                    u && this.injectableDefInScope(u) ? c = ws(G0(e), Lu) : c = null,
                    this.records.set(e, c)
                }
                if (c != null)
                    return this.hydrate(e, c)
            }
            let a = r & $e.Self ? Pp() : this.parent;
            return n = r & $e.Optional && n === Pa ? null : n,
            a.get(e, n)
        } catch (a) {
            if (a.name === "NullInjectorError") {
                if ((a[zu] = a[zu] || []).unshift($n(e)),
                o)
                    throw a;
                return vS(a, e, "R3InjectorError", this.source)
            } else
                throw a
        } finally {
            ir(s),
            Oi(o)
        }
    }
    resolveInjectorInitializers() {
        let e = at(null), n = Oi(this), r = ir(void 0), i;
        try {
            let o = this.get(Ss, Zn, $e.Self);
            for (let s of o)
                s()
        } finally {
            Oi(n),
            ir(r),
            at(e)
        }
    }
    toString() {
        let e = []
          , n = this.records;
        for (let r of n.keys())
            e.push($n(r));
        return `R3Injector[${e.join(", ")}]`
    }
    assertNotDestroyed() {
        if (this._destroyed)
            throw new we(205,!1)
    }
    processProvider(e) {
        e = or(e);
        let n = W0(e) ? e : or(e && e.provide)
          , r = zS(e);
        if (!W0(e) && e.multi === !0) {
            let i = this.records.get(n);
            i || (i = ws(void 0, Lu, !0),
            i.factory = ()=>H0(i.multi),
            this.records.set(n, i)),
            n = e,
            i.multi.push(e)
        }
        this.records.set(n, r)
    }
    hydrate(e, n) {
        let r = at(null);
        try {
            return n.value === Lu && (n.value = $S,
            n.value = n.factory()),
            typeof n.value == "object" && n.value && GS(n.value) && this._ngOnDestroyHooks.add(n.value),
            n.value
        } finally {
            at(r)
        }
    }
    injectableDefInScope(e) {
        if (!e.providedIn)
            return !1;
        let n = or(e.providedIn);
        return typeof n == "string" ? n === "any" || this.scopes.has(n) : this.injectorDefTypes.has(n)
    }
    removeOnDestroy(e) {
        let n = this._onDestroyHooks.indexOf(e);
        n !== -1 && this._onDestroyHooks.splice(n, 1)
    }
}
;
function G0(t) {
    let e = dl(t)
      , n = e !== null ? e.factory : _s(t);
    if (n !== null)
        return n;
    if (t instanceof be)
        throw new we(204,!1);
    if (t instanceof Function)
        return HS(t);
    throw new we(204,!1)
}
function HS(t) {
    if (t.length > 0)
        throw new we(204,!1);
    let n = rS(t);
    return n !== null ? ()=>n.factory(t) : ()=>new t
}
function zS(t) {
    if (Cw(t))
        return ws(void 0, t.useValue);
    {
        let e = qS(t);
        return ws(e, Lu)
    }
}
function qS(t, e, n) {
    let r;
    if (W0(t)) {
        let i = or(t);
        return _s(i) || G0(i)
    } else if (Cw(t))
        r = ()=>or(t.useValue);
    else if (jS(t))
        r = ()=>t.useFactory(...H0(t.deps || []));
    else if (VS(t))
        r = ()=>ve(or(t.useExisting));
    else {
        let i = or(t && (t.useClass || t.provide));
        if (WS(t))
            r = ()=>new i(...H0(t.deps));
        else
            return _s(i) || G0(i)
    }
    return r
}
function ws(t, e, n=!1) {
    return {
        factory: t,
        value: e,
        multi: n ? [] : void 0
    }
}
function WS(t) {
    return !!t.deps
}
function GS(t) {
    return t !== null && typeof t == "object" && typeof t.ngOnDestroy == "function"
}
function KS(t) {
    return typeof t == "function" || typeof t == "object" && t instanceof be
}
function K0(t, e) {
    for (let n of t)
        Array.isArray(n) ? K0(n, e) : n && sw(n) ? K0(n.\u0275providers, e) : e(n)
}
function Ar(t, e) {
    t instanceof La && t.assertNotDestroyed();
    let n, r = Oi(t), i = ir(void 0);
    try {
        return e()
    } finally {
        Oi(r),
        ir(i)
    }
}
function Dw() {
    return aw() !== void 0 || gS() != null
}
function YS(t) {
    if (!Dw())
        throw new we(-203,!1)
}
function ZS(t) {
    let e = Xn.ng;
    if (e && e.\u0275compilerFacade)
        return e.\u0275compilerFacade;
    throw new Error("JIT compiler unavailable")
}
function XS(t) {
    return typeof t == "function"
}
var ui = 0
  , et = 1
  , Me = 2
  , bn = 3
  , Cr = 4
  , _r = 5
  , Gu = 6
  , Ua = 7
  , Dr = 8
  , Ms = 9
  , Ir = 10
  , En = 11
  , Va = 12
  , _x = 13
  , Ns = 14
  , Vr = 15
  , yl = 16
  , bs = 17
  , ks = 18
  , vl = 19
  , Iw = 20
  , Li = 21
  , k0 = 22
  , Ao = 23
  , Vi = 25
  , Aw = 1;
var _o = 7
  , Ku = 8
  , Yu = 9
  , sr = 10
  , Op = function(t) {
    return t[t.None = 0] = "None",
    t[t.HasTransplantedViews = 2] = "HasTransplantedViews",
    t
}(Op || {});
function Is(t) {
    return Array.isArray(t) && typeof t[Aw] == "object"
}
function li(t) {
    return Array.isArray(t) && t[Aw] === !0
}
function _w(t) {
    return (t.flags & 4) !== 0
}
function xl(t) {
    return t.componentOffset > -1
}
function Lp(t) {
    return (t.flags & 1) === 1
}
function Za(t) {
    return !!t.template
}
function QS(t) {
    return (t[Me] & 512) !== 0
}
var Y0 = class {
    constructor(e, n, r) {
        this.previousValue = e,
        this.currentValue = n,
        this.firstChange = r
    }
    isFirstChange() {
        return this.firstChange
    }
}
;
function Sw(t, e, n, r) {
    e !== null ? e.applyValueToInputSignal(e, r) : t[n] = r
}
function Xa() {
    return Mw
}
function Mw(t) {
    return t.type.prototype.ngOnChanges && (t.setInput = e2),
    JS
}
Xa.ngInherit = !0;
function JS() {
    let t = Tw(this)
      , e = t?.current;
    if (e) {
        let n = t.previous;
        if (n === Oa)
            t.previous = e;
        else
            for (let r in e)
                n[r] = e[r];
        t.current = null,
        this.ngOnChanges(e)
    }
}
function e2(t, e, n, r, i) {
    let o = this.declaredInputs[r]
      , s = Tw(t) || t2(t, {
        previous: Oa,
        current: null
    })
      , a = s.current || (s.current = {})
      , c = s.previous
      , u = c[o];
    a[o] = new Y0(u && u.currentValue,n,c === Oa),
    Sw(t, e, i, n)
}
var kw = "__ngSimpleChanges__";
function Tw(t) {
    return t[kw] || null
}
function t2(t, e) {
    return t[kw] = e
}
var Sx = null;
var Or = function(t, e, n) {
    Sx?.(t, e, n)
}
  , n2 = "svg"
  , r2 = "math"
  , i2 = !1;
function o2() {
    return i2
}
function jr(t) {
    for (; Array.isArray(t); )
        t = t[ui];
    return t
}
function Bw(t, e) {
    return jr(e[t])
}
function Sr(t, e) {
    return jr(e[t.index])
}
function Rw(t, e) {
    return t.data[e]
}
function Bo(t, e) {
    let n = e[t];
    return Is(n) ? n : n[ui]
}
function Up(t) {
    return (t[Me] & 128) === 128
}
function s2(t) {
    return li(t[bn])
}
function Zu(t, e) {
    return e == null ? null : t[e]
}
function Fw(t) {
    t[bs] = 0
}
function a2(t) {
    t[Me] & 1024 || (t[Me] |= 1024,
    Up(t) && ja(t))
}
function c2(t, e) {
    for (; t > 0; )
        e = e[Ns],
        t--;
    return e
}
function Vp(t) {
    return !!(t[Me] & 9216 || t[Ao]?.dirty)
}
function Z0(t) {
    t[Ir].changeDetectionScheduler?.notify(1),
    Vp(t) ? ja(t) : t[Me] & 64 && (o2() ? (t[Me] |= 1024,
    ja(t)) : t[Ir].changeDetectionScheduler?.notify())
}
function ja(t) {
    t[Ir].changeDetectionScheduler?.notify();
    let e = $a(t);
    for (; e !== null && !(e[Me] & 8192 || (e[Me] |= 8192,
    !Up(e))); )
        e = $a(e)
}
function Nw(t, e) {
    if ((t[Me] & 256) === 256)
        throw new we(911,!1);
    t[Li] === null && (t[Li] = []),
    t[Li].push(e)
}
function u2(t, e) {
    if (t[Li] === null)
        return;
    let n = t[Li].indexOf(e);
    n !== -1 && t[Li].splice(n, 1)
}
function $a(t) {
    let e = t[bn];
    return li(e) ? e[bn] : e
}
var qe = {
    lFrame: Hw(null),
    bindingsEnabled: !0,
    skipHydrationRootTNode: null
};
function l2() {
    return qe.lFrame.elementDepthCount
}
function f2() {
    qe.lFrame.elementDepthCount++
}
function d2() {
    qe.lFrame.elementDepthCount--
}
function Pw() {
    return qe.bindingsEnabled
}
function h2() {
    return qe.skipHydrationRootTNode !== null
}
function p2(t) {
    return qe.skipHydrationRootTNode === t
}
function g2() {
    qe.skipHydrationRootTNode = null
}
function Lt() {
    return qe.lFrame.lView
}
function fi() {
    return qe.lFrame.tView
}
function di(t) {
    return qe.lFrame.contextLView = t,
    t[Dr]
}
function hi(t) {
    return qe.lFrame.contextLView = null,
    t
}
function Hr() {
    let t = Ow();
    for (; t !== null && t.type === 64; )
        t = t.parent;
    return t
}
function Ow() {
    return qe.lFrame.currentTNode
}
function m2() {
    let t = qe.lFrame
      , e = t.currentTNode;
    return t.isParent ? e : e.parent
}
function Qa(t, e) {
    let n = qe.lFrame;
    n.currentTNode = t,
    n.isParent = e
}
function Lw() {
    return qe.lFrame.isParent
}
function y2() {
    qe.lFrame.isParent = !1
}
function v2(t) {
    return qe.lFrame.bindingIndex = t
}
function Uw() {
    return qe.lFrame.bindingIndex++
}
function x2(t) {
    let e = qe.lFrame
      , n = e.bindingIndex;
    return e.bindingIndex = e.bindingIndex + t,
    n
}
function w2() {
    return qe.lFrame.inI18n
}
function b2(t, e) {
    let n = qe.lFrame;
    n.bindingIndex = n.bindingRootIndex = t,
    X0(e)
}
function E2() {
    return qe.lFrame.currentDirectiveIndex
}
function X0(t) {
    qe.lFrame.currentDirectiveIndex = t
}
function C2(t) {
    let e = qe.lFrame.currentDirectiveIndex;
    return e === -1 ? null : t[e]
}
function Vw(t) {
    qe.lFrame.currentQueryIndex = t
}
function D2(t) {
    let e = t[et];
    return e.type === 2 ? e.declTNode : e.type === 1 ? t[_r] : null
}
function jw(t, e, n) {
    if (n & $e.SkipSelf) {
        let i = e
          , o = t;
        for (; i = i.parent,
        i === null && !(n & $e.Host); )
            if (i = D2(o),
            i === null || (o = o[Ns],
            i.type & 10))
                break;
        if (i === null)
            return !1;
        e = i,
        t = o
    }
    let r = qe.lFrame = $w();
    return r.currentTNode = e,
    r.lView = t,
    !0
}
function jp(t) {
    let e = $w()
      , n = t[et];
    qe.lFrame = e,
    e.currentTNode = n.firstChild,
    e.lView = t,
    e.tView = n,
    e.contextLView = t,
    e.bindingIndex = n.bindingStartIndex,
    e.inI18n = !1
}
function $w() {
    let t = qe.lFrame
      , e = t === null ? null : t.child;
    return e === null ? Hw(t) : e
}
function Hw(t) {
    let e = {
        currentTNode: null,
        isParent: !0,
        lView: null,
        tView: null,
        selectedIndex: -1,
        contextLView: null,
        elementDepthCount: 0,
        currentNamespace: null,
        currentDirectiveIndex: -1,
        bindingRootIndex: -1,
        bindingIndex: -1,
        currentQueryIndex: 0,
        parent: t,
        child: null,
        inI18n: !1
    };
    return t !== null && (t.child = e),
    e
}
function zw() {
    let t = qe.lFrame;
    return qe.lFrame = t.parent,
    t.currentTNode = null,
    t.lView = null,
    t
}
var qw = zw;
function $p() {
    let t = zw();
    t.isParent = !0,
    t.tView = null,
    t.selectedIndex = -1,
    t.contextLView = null,
    t.elementDepthCount = 0,
    t.currentDirectiveIndex = -1,
    t.currentNamespace = null,
    t.bindingRootIndex = -1,
    t.bindingIndex = -1,
    t.currentQueryIndex = 0
}
function I2(t) {
    return (qe.lFrame.contextLView = c2(t, qe.lFrame.contextLView))[Dr]
}
function Ps() {
    return qe.lFrame.selectedIndex
}
function So(t) {
    qe.lFrame.selectedIndex = t
}
function Ww() {
    let t = qe.lFrame;
    return Rw(t.tView, t.selectedIndex)
}
function A2() {
    return qe.lFrame.currentNamespace
}
var Gw = !0;
function Hp() {
    return Gw
}
function zp(t) {
    Gw = t
}
function _2(t, e, n) {
    let {ngOnChanges: r, ngOnInit: i, ngDoCheck: o} = e.type.prototype;
    if (r) {
        let s = Mw(e);
        (n.preOrderHooks ??= []).push(t, s),
        (n.preOrderCheckHooks ??= []).push(t, s)
    }
    i && (n.preOrderHooks ??= []).push(0 - t, i),
    o && ((n.preOrderHooks ??= []).push(t, o),
    (n.preOrderCheckHooks ??= []).push(t, o))
}
function qp(t, e) {
    for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) {
        let o = t.data[n].type.prototype
          , {ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: c, ngAfterViewChecked: u, ngOnDestroy: l} = o;
        s && (t.contentHooks ??= []).push(-n, s),
        a && ((t.contentHooks ??= []).push(n, a),
        (t.contentCheckHooks ??= []).push(n, a)),
        c && (t.viewHooks ??= []).push(-n, c),
        u && ((t.viewHooks ??= []).push(n, u),
        (t.viewCheckHooks ??= []).push(n, u)),
        l != null && (t.destroyHooks ??= []).push(n, l)
    }
}
function Uu(t, e, n) {
    Kw(t, e, 3, n)
}
function Vu(t, e, n, r) {
    (t[Me] & 3) === n && Kw(t, e, n, r)
}
function T0(t, e) {
    let n = t[Me];
    (n & 3) === e && (n &= 16383,
    n += 1,
    t[Me] = n)
}
function Kw(t, e, n, r) {
    let i = r !== void 0 ? t[bs] & 65535 : 0
      , o = r ?? -1
      , s = e.length - 1
      , a = 0;
    for (let c = i; c < s; c++)
        if (typeof e[c + 1] == "number") {
            if (a = e[c],
            r != null && a >= r)
                break
        } else
            e[c] < 0 && (t[bs] += 65536),
            (a < o || o == -1) && (S2(t, n, e, c),
            t[bs] = (t[bs] & 4294901760) + c + 2),
            c++
}
function Mx(t, e) {
    Or(4, t, e);
    let n = at(null);
    try {
        e.call(t)
    } finally {
        at(n),
        Or(5, t, e)
    }
}
function S2(t, e, n, r) {
    let i = n[r] < 0
      , o = n[r + 1]
      , s = i ? -n[r] : n[r]
      , a = t[s];
    i ? t[Me] >> 14 < t[bs] >> 16 && (t[Me] & 3) === e && (t[Me] += 16384,
    Mx(a, o)) : Mx(a, o)
}
var As = -1
  , Ha = class {
    constructor(e, n, r) {
        this.factory = e,
        this.resolving = !1,
        this.canSeeViewProviders = n,
        this.injectImpl = r
    }
}
;
function M2(t) {
    return t instanceof Ha
}
function k2(t) {
    return (t.flags & 8) !== 0
}
function T2(t) {
    return (t.flags & 16) !== 0
}
function Yw(t) {
    return t !== As
}
function Xu(t) {
    return t & 32767
}
function B2(t) {
    return t >> 16
}
function Qu(t, e) {
    let n = B2(t)
      , r = e;
    for (; n > 0; )
        r = r[Ns],
        n--;
    return r
}
var Q0 = !0;
function kx(t) {
    let e = Q0;
    return Q0 = t,
    e
}
var R2 = 256
  , Zw = R2 - 1
  , Xw = 5
  , F2 = 0
  , Lr = {};
function N2(t, e, n) {
    let r;
    typeof n == "string" ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Fa) && (r = n[Fa]),
    r == null && (r = n[Fa] = F2++);
    let i = r & Zw
      , o = 1 << i;
    e.data[t + (i >> Xw)] |= o
}
function Qw(t, e) {
    let n = Jw(t, e);
    if (n !== -1)
        return n;
    let r = e[et];
    r.firstCreatePass && (t.injectorIndex = e.length,
    B0(r.data, t),
    B0(e, null),
    B0(r.blueprint, null));
    let i = Wp(t, e)
      , o = t.injectorIndex;
    if (Yw(i)) {
        let s = Xu(i)
          , a = Qu(i, e)
          , c = a[et].data;
        for (let u = 0; u < 8; u++)
            e[o + u] = a[s + u] | c[s + u]
    }
    return e[o + 8] = i,
    o
}
function B0(t, e) {
    t.push(0, 0, 0, 0, 0, 0, 0, 0, e)
}
function Jw(t, e) {
    return t.injectorIndex === -1 || t.parent && t.parent.injectorIndex === t.injectorIndex || e[t.injectorIndex + 8] === null ? -1 : t.injectorIndex
}
function Wp(t, e) {
    if (t.parent && t.parent.injectorIndex !== -1)
        return t.parent.injectorIndex;
    let n = 0
      , r = null
      , i = e;
    for (; i !== null; ) {
        if (r = i1(i),
        r === null)
            return As;
        if (n++,
        i = i[Ns],
        r.injectorIndex !== -1)
            return r.injectorIndex | n << 16
    }
    return As
}
function P2(t, e, n) {
    N2(t, e, n)
}
function e1(t, e, n) {
    if (n & $e.Optional || t !== void 0)
        return t;
    Mp(e, "NodeInjector")
}
function t1(t, e, n, r) {
    if (n & $e.Optional && r === void 0 && (r = null),
    !(n & ($e.Self | $e.Host))) {
        let i = t[Ms]
          , o = ir(void 0);
        try {
            return i ? i.get(e, r, n & $e.Optional) : cw(e, r, n & $e.Optional)
        } finally {
            ir(o)
        }
    }
    return e1(r, e, n)
}
function n1(t, e, n, r=$e.Default, i) {
    if (t !== null) {
        if (e[Me] & 2048 && !(r & $e.Self)) {
            let s = j2(t, e, n, r, Lr);
            if (s !== Lr)
                return s
        }
        let o = r1(t, e, n, r, Lr);
        if (o !== Lr)
            return o
    }
    return t1(e, n, r, i)
}
function r1(t, e, n, r, i) {
    let o = U2(n);
    if (typeof o == "function") {
        if (!jw(e, t, r))
            return r & $e.Host ? e1(i, n, r) : t1(e, n, r, i);
        try {
            let s;
            if (s = o(r),
            s == null && !(r & $e.Optional))
                Mp(n);
            else
                return s
        } finally {
            qw()
        }
    } else if (typeof o == "number") {
        let s = null
          , a = Jw(t, e)
          , c = As
          , u = r & $e.Host ? e[Vr][_r] : null;
        for ((a === -1 || r & $e.SkipSelf) && (c = a === -1 ? Wp(t, e) : e[a + 8],
        c === As || !Bx(r, !1) ? a = -1 : (s = e[et],
        a = Xu(c),
        e = Qu(c, e))); a !== -1; ) {
            let l = e[et];
            if (Tx(o, a, l.data)) {
                let d = O2(a, e, n, s, r, u);
                if (d !== Lr)
                    return d
            }
            c = e[a + 8],
            c !== As && Bx(r, e[et].data[a + 8] === u) && Tx(o, a, e) ? (s = l,
            a = Xu(c),
            e = Qu(c, e)) : a = -1
        }
    }
    return i
}
function O2(t, e, n, r, i, o) {
    let s = e[et]
      , a = s.data[t + 8]
      , c = r == null ? xl(a) && Q0 : r != s && (a.type & 3) !== 0
      , u = i & $e.Host && o === a
      , l = L2(a, s, n, c, u);
    return l !== null ? za(e, s, l, a) : Lr
}
function L2(t, e, n, r, i) {
    let o = t.providerIndexes
      , s = e.data
      , a = o & 1048575
      , c = t.directiveStart
      , u = t.directiveEnd
      , l = o >> 20
      , d = r ? a : a + l
      , y = i ? a + l : u;
    for (let v = d; v < y; v++) {
        let E = s[v];
        if (v < c && n === E || v >= c && E.type === n)
            return v
    }
    if (i) {
        let v = s[c];
        if (v && Za(v) && v.type === n)
            return c
    }
    return null
}
function za(t, e, n, r) {
    let i = t[n]
      , o = e.data;
    if (M2(i)) {
        let s = i;
        s.resolving && lS(uS(o[n]));
        let a = kx(s.canSeeViewProviders);
        s.resolving = !0;
        let c, u = s.injectImpl ? ir(s.injectImpl) : null, l = jw(t, r, $e.Default);
        try {
            i = t[n] = s.factory(void 0, o, t, r),
            e.firstCreatePass && n >= r.directiveStart && _2(n, o[n], e)
        } finally {
            u !== null && ir(u),
            kx(a),
            s.resolving = !1,
            qw()
        }
    }
    return i
}
function U2(t) {
    if (typeof t == "string")
        return t.charCodeAt(0) || 0;
    let e = t.hasOwnProperty(Fa) ? t[Fa] : void 0;
    return typeof e == "number" ? e >= 0 ? e & Zw : V2 : e
}
function Tx(t, e, n) {
    let r = 1 << t;
    return !!(n[e + (t >> Xw)] & r)
}
function Bx(t, e) {
    return !(t & $e.Self) && !(t & $e.Host && e)
}
var Io = class {
    constructor(e, n) {
        this._tNode = e,
        this._lView = n
    }
    get(e, n, r) {
        return n1(this._tNode, this._lView, e, hl(r), n)
    }
}
;
function V2() {
    return new Io(Hr(),Lt())
}
function wl(t) {
    return Ka(()=>{
        let e = t.prototype.constructor
          , n = e[Hu] || J0(e)
          , r = Object.prototype
          , i = Object.getPrototypeOf(t.prototype).constructor;
        for (; i && i !== r; ) {
            let o = i[Hu] || J0(i);
            if (o && o !== n)
                return o;
            i = Object.getPrototypeOf(i)
        }
        return o=>new o
    }
    )
}
function J0(t) {
    return nw(t) ? ()=>{
        let e = J0(or(t));
        return e && e()
    }
    : _s(t)
}
function j2(t, e, n, r, i) {
    let o = t
      , s = e;
    for (; o !== null && s !== null && s[Me] & 2048 && !(s[Me] & 512); ) {
        let a = r1(o, s, n, r | $e.Self, Lr);
        if (a !== Lr)
            return a;
        let c = o.parent;
        if (!c) {
            let u = s[Iw];
            if (u) {
                let l = u.get(n, Lr, r);
                if (l !== Lr)
                    return l
            }
            c = i1(s),
            s = s[Ns]
        }
        o = c
    }
    return i
}
function i1(t) {
    let e = t[et]
      , n = e.type;
    return n === 2 ? e.declTNode : n === 1 ? t[_r] : null
}
function Rx(t, e=null, n=null, r) {
    let i = o1(t, e, n, r);
    return i.resolveInjectorInitializers(),
    i
}
function o1(t, e=null, n=null, r, i=new Set) {
    let o = [n || Zn, LS(t)];
    return r = r || (typeof t == "object" ? void 0 : $n(t)),
    new La(o,e || Pp(),r || null,i)
}
var Mr = (()=>{
    let e = class e {
        static create(r, i) {
            if (Array.isArray(r))
                return Rx({
                    name: ""
                }, i, r, "");
            {
                let o = r.name ?? "";
                return Rx({
                    name: o
                }, r.parent, r.providers, o)
            }
        }
    }
    ;
    e.THROW_IF_NOT_FOUND = Pa,
    e.NULL = new Wu,
    e.\u0275prov = he({
        token: e,
        providedIn: "any",
        factory: ()=>ve(fw)
    }),
    e.__NG_ELEMENT_ID__ = -1;
    let t = e;
    return t
}
)();
var $2 = "ngOriginalError";
function R0(t) {
    return t[$2]
}
var $r = class {
    constructor() {
        this._console = console
    }
    handleError(e) {
        let n = this._findOriginalError(e);
        this._console.error("ERROR", e),
        n && this._console.error("ORIGINAL ERROR", n)
    }
    _findOriginalError(e) {
        let n = e && R0(e);
        for (; n && R0(n); )
            n = R0(n);
        return n || null
    }
}
  , s1 = new be("",{
    providedIn: "root",
    factory: ()=>ie($r).handleError.bind(void 0)
})
  , Gp = (()=>{
    let e = class e {
    }
    ;
    e.__NG_ELEMENT_ID__ = H2,
    e.__NG_ENV_ID__ = r=>r;
    let t = e;
    return t
}
)()
  , ep = class extends Gp {
    constructor(e) {
        super(),
        this._lView = e
    }
    onDestroy(e) {
        return Nw(this._lView, e),
        ()=>u2(this._lView, e)
    }
}
;
function H2() {
    return new ep(Lt())
}
function z2() {
    return bl(Hr(), Lt())
}
function bl(t, e) {
    return new Ja(Sr(t, e))
}
var Ja = (()=>{
    let e = class e {
        constructor(r) {
            this.nativeElement = r
        }
    }
    ;
    e.__NG_ELEMENT_ID__ = z2;
    let t = e;
    return t
}
)();
var tp = class extends Fn {
    constructor(e=!1) {
        super(),
        this.destroyRef = void 0,
        this.__isAsync = e,
        Dw() && (this.destroyRef = ie(Gp, {
            optional: !0
        }) ?? void 0)
    }
    emit(e) {
        let n = at(null);
        try {
            super.next(e)
        } finally {
            at(n)
        }
    }
    subscribe(e, n, r) {
        let i = e
          , o = n || (()=>null)
          , s = r;
        if (e && typeof e == "object") {
            let c = e;
            i = c.next?.bind(c),
            o = c.error?.bind(c),
            s = c.complete?.bind(c)
        }
        this.__isAsync && (o = F0(o),
        i && (i = F0(i)),
        s && (s = F0(s)));
        let a = super.subscribe({
            next: i,
            error: o,
            complete: s
        });
        return e instanceof en && e.add(a),
        a
    }
}
;
function F0(t) {
    return e=>{
        setTimeout(t, void 0, e)
    }
}
var xn = tp;
function a1(t) {
    return (t.flags & 128) === 128
}
var c1 = new Map
  , q2 = 0;
function W2() {
    return q2++
}
function G2(t) {
    c1.set(t[vl], t)
}
function K2(t) {
    c1.delete(t[vl])
}
var Fx = "__ngContext__";
function Mo(t, e) {
    Is(e) ? (t[Fx] = e[vl],
    G2(e)) : t[Fx] = e
}
function u1(t) {
    return f1(t[Va])
}
function l1(t) {
    return f1(t[Cr])
}
function f1(t) {
    for (; t !== null && !li(t); )
        t = t[Cr];
    return t
}
var np;
function d1(t) {
    np = t
}
function Y2() {
    if (np !== void 0)
        return np;
    if (typeof document < "u")
        return document;
    throw new we(210,!1)
}
var El = new be("",{
    providedIn: "root",
    factory: ()=>Z2
})
  , Z2 = "ng"
  , Kp = new be("")
  , zr = new be("",{
    providedIn: "platform",
    factory: ()=>"unknown"
});
var Yp = new be("",{
    providedIn: "root",
    factory: ()=>Y2().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null
});
var X2 = "h"
  , Q2 = "b";
var J2 = ()=>null;
function Zp(t, e, n=!1) {
    return J2(t, e, n)
}
var h1 = !1
  , eM = new be("",{
    providedIn: "root",
    factory: ()=>h1
});
var Ju = class {
    constructor(e) {
        this.changingThisBreaksApplicationSecurity = e
    }
    toString() {
        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${ew})`
    }
}
;
function Cl(t) {
    return t instanceof Ju ? t.changingThisBreaksApplicationSecurity : t
}
function p1(t, e) {
    let n = tM(t);
    if (n != null && n !== e) {
        if (n === "ResourceURL" && e === "URL")
            return !0;
        throw new Error(`Required a safe ${e}, got a ${n} (see ${ew})`)
    }
    return n === e
}
function tM(t) {
    return t instanceof Ju && t.getTypeName() || null
}
var nM = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function g1(t) {
    return t = String(t),
    t.match(nM) ? t : "unsafe:" + t
}
var Xp = function(t) {
    return t[t.NONE = 0] = "NONE",
    t[t.HTML = 1] = "HTML",
    t[t.STYLE = 2] = "STYLE",
    t[t.SCRIPT = 3] = "SCRIPT",
    t[t.URL = 4] = "URL",
    t[t.RESOURCE_URL = 5] = "RESOURCE_URL",
    t
}(Xp || {});
function Qp(t) {
    let e = rM();
    return e ? e.sanitize(Xp.URL, t) || "" : p1(t, "URL") ? Cl(t) : g1(Sp(t))
}
function rM() {
    let t = Lt();
    return t && t[Ir].sanitizer
}
function m1(t) {
    return t instanceof Function ? t() : t
}
function iM(t) {
    return (t ?? ie(Mr)).get(zr) === "browser"
}
var ci = function(t) {
    return t[t.Important = 1] = "Important",
    t[t.DashCase = 2] = "DashCase",
    t
}(ci || {}), oM;
function Jp(t, e) {
    return oM(t, e)
}
function Es(t, e, n, r, i) {
    if (r != null) {
        let o, s = !1;
        li(r) ? o = r : Is(r) && (s = !0,
        r = r[ui]);
        let a = jr(r);
        t === 0 && n !== null ? i == null ? b1(e, n, a) : el(e, n, a, i || null, !0) : t === 1 && n !== null ? el(e, n, a, i || null, !0) : t === 2 ? EM(e, a, s) : t === 3 && e.destroyNode(a),
        o != null && DM(e, t, o, n, i)
    }
}
function sM(t, e) {
    return t.createText(e)
}
function aM(t, e, n) {
    t.setValue(e, n)
}
function y1(t, e, n) {
    return t.createElement(e, n)
}
function cM(t, e) {
    v1(t, e),
    e[ui] = null,
    e[_r] = null
}
function uM(t, e, n, r, i, o) {
    r[ui] = i,
    r[_r] = e,
    Dl(t, r, n, 1, i, o)
}
function v1(t, e) {
    e[Ir].changeDetectionScheduler?.notify(1),
    Dl(t, e, e[En], 2, null, null)
}
function lM(t) {
    let e = t[Va];
    if (!e)
        return N0(t[et], t);
    for (; e; ) {
        let n = null;
        if (Is(e))
            n = e[Va];
        else {
            let r = e[sr];
            r && (n = r)
        }
        if (!n) {
            for (; e && !e[Cr] && e !== t; )
                Is(e) && N0(e[et], e),
                e = e[bn];
            e === null && (e = t),
            Is(e) && N0(e[et], e),
            n = e && e[Cr]
        }
        e = n
    }
}
function fM(t, e, n, r) {
    let i = sr + r
      , o = n.length;
    r > 0 && (n[i - 1][Cr] = e),
    r < o - sr ? (e[Cr] = n[i],
    lw(n, sr + r, e)) : (n.push(e),
    e[Cr] = null),
    e[bn] = n;
    let s = e[yl];
    s !== null && n !== s && dM(s, e);
    let a = e[ks];
    a !== null && a.insertView(t),
    Z0(e),
    e[Me] |= 128
}
function dM(t, e) {
    let n = t[Yu]
      , i = e[bn][bn][Vr];
    e[Vr] !== i && (t[Me] |= Op.HasTransplantedViews),
    n === null ? t[Yu] = [e] : n.push(e)
}
function x1(t, e) {
    let n = t[Yu]
      , r = n.indexOf(e);
    n.splice(r, 1)
}
function rp(t, e) {
    if (t.length <= sr)
        return;
    let n = sr + e
      , r = t[n];
    if (r) {
        let i = r[yl];
        i !== null && i !== t && x1(i, r),
        e > 0 && (t[n - 1][Cr] = r[Cr]);
        let o = qu(t, sr + e);
        cM(r[et], r);
        let s = o[ks];
        s !== null && s.detachView(o[et]),
        r[bn] = null,
        r[Cr] = null,
        r[Me] &= -129
    }
    return r
}
function w1(t, e) {
    if (!(e[Me] & 256)) {
        let n = e[En];
        n.destroyNode && Dl(t, e, n, 3, null, null),
        lM(e)
    }
}
function N0(t, e) {
    if (e[Me] & 256)
        return;
    let n = at(null);
    try {
        e[Me] &= -129,
        e[Me] |= 256,
        e[Ao] && $v(e[Ao]),
        pM(t, e),
        hM(t, e),
        e[et].type === 1 && e[En].destroy();
        let r = e[yl];
        if (r !== null && li(e[bn])) {
            r !== e[bn] && x1(r, e);
            let i = e[ks];
            i !== null && i.detachView(t)
        }
        K2(e)
    } finally {
        at(n)
    }
}
function hM(t, e) {
    let n = t.cleanup
      , r = e[Ua];
    if (n !== null)
        for (let o = 0; o < n.length - 1; o += 2)
            if (typeof n[o] == "string") {
                let s = n[o + 3];
                s >= 0 ? r[s]() : r[-s].unsubscribe(),
                o += 2
            } else {
                let s = r[n[o + 1]];
                n[o].call(s)
            }
    r !== null && (e[Ua] = null);
    let i = e[Li];
    if (i !== null) {
        e[Li] = null;
        for (let o = 0; o < i.length; o++) {
            let s = i[o];
            s()
        }
    }
}
function pM(t, e) {
    let n;
    if (t != null && (n = t.destroyHooks) != null)
        for (let r = 0; r < n.length; r += 2) {
            let i = e[n[r]];
            if (!(i instanceof Ha)) {
                let o = n[r + 1];
                if (Array.isArray(o))
                    for (let s = 0; s < o.length; s += 2) {
                        let a = i[o[s]]
                          , c = o[s + 1];
                        Or(4, a, c);
                        try {
                            c.call(a)
                        } finally {
                            Or(5, a, c)
                        }
                    }
                else {
                    Or(4, i, o);
                    try {
                        o.call(i)
                    } finally {
                        Or(5, i, o)
                    }
                }
            }
        }
}
function gM(t, e, n) {
    return mM(t, e.parent, n)
}
function mM(t, e, n) {
    let r = e;
    for (; r !== null && r.type & 40; )
        e = r,
        r = e.parent;
    if (r === null)
        return n[ui];
    {
        let {componentOffset: i} = r;
        if (i > -1) {
            let {encapsulation: o} = t.data[r.directiveStart + i];
            if (o === Ur.None || o === Ur.Emulated)
                return null
        }
        return Sr(r, n)
    }
}
function el(t, e, n, r, i) {
    t.insertBefore(e, n, r, i)
}
function b1(t, e, n) {
    t.appendChild(e, n)
}
function Nx(t, e, n, r, i) {
    r !== null ? el(t, e, n, r, i) : b1(t, e, n)
}
function yM(t, e, n, r) {
    t.removeChild(e, n, r)
}
function eg(t, e) {
    return t.parentNode(e)
}
function vM(t, e) {
    return t.nextSibling(e)
}
function xM(t, e, n) {
    return bM(t, e, n)
}
function wM(t, e, n) {
    return t.type & 40 ? Sr(t, n) : null
}
var bM = wM, Px;
function tg(t, e, n, r) {
    let i = gM(t, r, e)
      , o = e[En]
      , s = r.parent || e[_r]
      , a = xM(s, r, e);
    if (i != null)
        if (Array.isArray(n))
            for (let c = 0; c < n.length; c++)
                Nx(o, i, n[c], a, !1);
        else
            Nx(o, i, n, a, !1);
    Px !== void 0 && Px(o, r, e, n, i)
}
function ju(t, e) {
    if (e !== null) {
        let n = e.type;
        if (n & 3)
            return Sr(e, t);
        if (n & 4)
            return ip(-1, t[e.index]);
        if (n & 8) {
            let r = e.child;
            if (r !== null)
                return ju(t, r);
            {
                let i = t[e.index];
                return li(i) ? ip(-1, i) : jr(i)
            }
        } else {
            if (n & 32)
                return Jp(e, t)() || jr(t[e.index]);
            {
                let r = E1(t, e);
                if (r !== null) {
                    if (Array.isArray(r))
                        return r[0];
                    let i = $a(t[Vr]);
                    return ju(i, r)
                } else
                    return ju(t, e.next)
            }
        }
    }
    return null
}
function E1(t, e) {
    if (e !== null) {
        let r = t[Vr][_r]
          , i = e.projection;
        return r.projection[i]
    }
    return null
}
function ip(t, e) {
    let n = sr + t + 1;
    if (n < e.length) {
        let r = e[n]
          , i = r[et].firstChild;
        if (i !== null)
            return ju(r, i)
    }
    return e[_o]
}
function EM(t, e, n) {
    let r = eg(t, e);
    r && yM(t, r, e, n)
}
function ng(t, e, n, r, i, o, s) {
    for (; n != null; ) {
        let a = r[n.index]
          , c = n.type;
        if (s && e === 0 && (a && Mo(jr(a), r),
        n.flags |= 2),
        (n.flags & 32) !== 32)
            if (c & 8)
                ng(t, e, n.child, r, i, o, !1),
                Es(e, t, i, a, o);
            else if (c & 32) {
                let u = Jp(n, r), l;
                for (; l = u(); )
                    Es(e, t, i, l, o);
                Es(e, t, i, a, o)
            } else
                c & 16 ? CM(t, e, r, n, i, o) : Es(e, t, i, a, o);
        n = s ? n.projectionNext : n.next
    }
}
function Dl(t, e, n, r, i, o) {
    ng(n, r, t.firstChild, e, i, o, !1)
}
function CM(t, e, n, r, i, o) {
    let s = n[Vr]
      , c = s[_r].projection[r.projection];
    if (Array.isArray(c))
        for (let u = 0; u < c.length; u++) {
            let l = c[u];
            Es(e, t, i, l, o)
        }
    else {
        let u = c
          , l = s[bn];
        a1(r) && (u.flags |= 128),
        ng(t, e, u, l, i, o, !0)
    }
}
function DM(t, e, n, r, i) {
    let o = n[_o]
      , s = jr(n);
    o !== s && Es(e, t, r, o, i);
    for (let a = sr; a < n.length; a++) {
        let c = n[a];
        Dl(c[et], c, t, e, r, o)
    }
}
function IM(t, e, n, r, i) {
    if (e)
        i ? t.addClass(n, r) : t.removeClass(n, r);
    else {
        let o = r.indexOf("-") === -1 ? void 0 : ci.DashCase;
        i == null ? t.removeStyle(n, r, o) : (typeof i == "string" && i.endsWith("!important") && (i = i.slice(0, -10),
        o |= ci.Important),
        t.setStyle(n, r, i, o))
    }
}
function AM(t, e, n) {
    t.setAttribute(e, "style", n)
}
function C1(t, e, n) {
    n === "" ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n)
}
function D1(t, e, n) {
    let {mergedAttrs: r, classes: i, styles: o} = n;
    r !== null && z0(t, e, r),
    i !== null && C1(t, e, i),
    o !== null && AM(t, e, o)
}
var $i = {};
function kt(t=1) {
    I1(fi(), Lt(), Ps() + t, !1)
}
function I1(t, e, n, r) {
    if (!r)
        if ((e[Me] & 3) === 3) {
            let o = t.preOrderCheckHooks;
            o !== null && Uu(e, o, n)
        } else {
            let o = t.preOrderHooks;
            o !== null && Vu(e, o, 0, n)
        }
    So(n)
}
function Qn(t, e=$e.Default) {
    let n = Lt();
    if (n === null)
        return ve(t, e);
    let r = Hr();
    return n1(r, n, or(t), e)
}
function A1() {
    let t = "invalid";
    throw new Error(t)
}
function _1(t, e, n, r, i, o) {
    let s = at(null);
    try {
        let a = null;
        i & ai.SignalBased && (a = e[r][Lv]),
        a !== null && a.transformFn !== void 0 && (o = a.transformFn(o)),
        i & ai.HasDecoratorInputTransform && (o = t.inputTransforms[r].call(e, o)),
        t.setInput !== null ? t.setInput(e, a, o, n, r) : Sw(e, a, r, o)
    } finally {
        at(s)
    }
}
function _M(t, e) {
    let n = t.hostBindingOpCodes;
    if (n !== null)
        try {
            for (let r = 0; r < n.length; r++) {
                let i = n[r];
                if (i < 0)
                    So(~i);
                else {
                    let o = i
                      , s = n[++r]
                      , a = n[++r];
                    b2(s, o);
                    let c = e[o];
                    a(2, c)
                }
            }
        } finally {
            So(-1)
        }
}
function Il(t, e, n, r, i, o, s, a, c, u, l) {
    let d = e.blueprint.slice();
    return d[ui] = i,
    d[Me] = r | 4 | 128 | 8 | 64,
    (u !== null || t && t[Me] & 2048) && (d[Me] |= 2048),
    Fw(d),
    d[bn] = d[Ns] = t,
    d[Dr] = n,
    d[Ir] = s || t && t[Ir],
    d[En] = a || t && t[En],
    d[Ms] = c || t && t[Ms] || null,
    d[_r] = o,
    d[vl] = W2(),
    d[Gu] = l,
    d[Iw] = u,
    d[Vr] = e.type == 2 ? t[Vr] : d,
    d
}
function Al(t, e, n, r, i) {
    let o = t.data[e];
    if (o === null)
        o = SM(t, e, n, r, i),
        w2() && (o.flags |= 32);
    else if (o.type & 64) {
        o.type = n,
        o.value = r,
        o.attrs = i;
        let s = m2();
        o.injectorIndex = s === null ? -1 : s.injectorIndex
    }
    return Qa(o, !0),
    o
}
function SM(t, e, n, r, i) {
    let o = Ow()
      , s = Lw()
      , a = s ? o : o && o.parent
      , c = t.data[e] = RM(t, a, n, e, r, i);
    return t.firstChild === null && (t.firstChild = c),
    o !== null && (s ? o.child == null && c.parent !== null && (o.child = c) : o.next === null && (o.next = c,
    c.prev = o)),
    c
}
function S1(t, e, n, r) {
    if (n === 0)
        return -1;
    let i = e.length;
    for (let o = 0; o < n; o++)
        e.push(r),
        t.blueprint.push(r),
        t.data.push(null);
    return i
}
function M1(t, e, n, r, i) {
    let o = Ps()
      , s = r & 2;
    try {
        So(-1),
        s && e.length > Vi && I1(t, e, Vi, !1),
        Or(s ? 2 : 0, i),
        n(r, i)
    } finally {
        So(o),
        Or(s ? 3 : 1, i)
    }
}
function k1(t, e, n) {
    if (_w(e)) {
        let r = at(null);
        try {
            let i = e.directiveStart
              , o = e.directiveEnd;
            for (let s = i; s < o; s++) {
                let a = t.data[s];
                if (a.contentQueries) {
                    let c = n[s];
                    a.contentQueries(1, c, s)
                }
            }
        } finally {
            at(r)
        }
    }
}
function T1(t, e, n) {
    Pw() && (UM(t, e, n, Sr(n, e)),
    (n.flags & 64) === 64 && O1(t, e, n))
}
function B1(t, e, n=Sr) {
    let r = e.localNames;
    if (r !== null) {
        let i = e.index + 1;
        for (let o = 0; o < r.length; o += 2) {
            let s = r[o + 1]
              , a = s === -1 ? n(e, t) : t[s];
            t[i++] = a
        }
    }
}
function R1(t) {
    let e = t.tView;
    return e === null || e.incompleteFirstPass ? t.tView = rg(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts, t.id) : e
}
function rg(t, e, n, r, i, o, s, a, c, u, l) {
    let d = Vi + r
      , y = d + i
      , v = MM(d, y)
      , E = typeof u == "function" ? u() : u;
    return v[et] = {
        type: t,
        blueprint: v,
        template: n,
        queries: null,
        viewQuery: a,
        declTNode: e,
        data: v.slice().fill(null, d),
        bindingStartIndex: d,
        expandoStartIndex: y,
        hostBindingOpCodes: null,
        firstCreatePass: !0,
        firstUpdatePass: !0,
        staticViewQueries: !1,
        staticContentQueries: !1,
        preOrderHooks: null,
        preOrderCheckHooks: null,
        contentHooks: null,
        contentCheckHooks: null,
        viewHooks: null,
        viewCheckHooks: null,
        destroyHooks: null,
        cleanup: null,
        contentQueries: null,
        components: null,
        directiveRegistry: typeof o == "function" ? o() : o,
        pipeRegistry: typeof s == "function" ? s() : s,
        firstChild: null,
        schemas: c,
        consts: E,
        incompleteFirstPass: !1,
        ssrId: l
    }
}
function MM(t, e) {
    let n = [];
    for (let r = 0; r < e; r++)
        n.push(r < t ? null : $i);
    return n
}
function kM(t, e, n, r) {
    let o = r.get(eM, h1) || n === Ur.ShadowDom
      , s = t.selectRootElement(e, o);
    return TM(s),
    s
}
function TM(t) {
    BM(t)
}
var BM = ()=>null;
function RM(t, e, n, r, i, o) {
    let s = e ? e.injectorIndex : -1
      , a = 0;
    return h2() && (a |= 128),
    {
        type: n,
        index: r,
        insertBeforeIndex: null,
        injectorIndex: s,
        directiveStart: -1,
        directiveEnd: -1,
        directiveStylingLast: -1,
        componentOffset: -1,
        propertyBindings: null,
        flags: a,
        providerIndexes: 0,
        value: i,
        attrs: o,
        mergedAttrs: null,
        localNames: null,
        initialInputs: void 0,
        inputs: null,
        outputs: null,
        tView: null,
        next: null,
        prev: null,
        projectionNext: null,
        child: null,
        parent: e,
        projection: null,
        styles: null,
        stylesWithoutHost: null,
        residualStyles: void 0,
        classes: null,
        classesWithoutHost: null,
        residualClasses: void 0,
        classBindings: 0,
        styleBindings: 0
    }
}
function Ox(t, e, n, r, i) {
    for (let o in e) {
        if (!e.hasOwnProperty(o))
            continue;
        let s = e[o];
        if (s === void 0)
            continue;
        r ??= {};
        let a, c = ai.None;
        Array.isArray(s) ? (a = s[0],
        c = s[1]) : a = s;
        let u = o;
        if (i !== null) {
            if (!i.hasOwnProperty(o))
                continue;
            u = i[o]
        }
        t === 0 ? Lx(r, n, u, a, c) : Lx(r, n, u, a)
    }
    return r
}
function Lx(t, e, n, r, i) {
    let o;
    t.hasOwnProperty(n) ? (o = t[n]).push(e, r) : o = t[n] = [e, r],
    i !== void 0 && o.push(i)
}
function FM(t, e, n) {
    let r = e.directiveStart
      , i = e.directiveEnd
      , o = t.data
      , s = e.attrs
      , a = []
      , c = null
      , u = null;
    for (let l = r; l < i; l++) {
        let d = o[l]
          , y = n ? n.get(d) : null
          , v = y ? y.inputs : null
          , E = y ? y.outputs : null;
        c = Ox(0, d.inputs, l, c, v),
        u = Ox(1, d.outputs, l, u, E);
        let D = c !== null && s !== null && !Fp(e) ? KM(c, l, s) : null;
        a.push(D)
    }
    c !== null && (c.hasOwnProperty("class") && (e.flags |= 8),
    c.hasOwnProperty("style") && (e.flags |= 16)),
    e.initialInputs = a,
    e.inputs = c,
    e.outputs = u
}
function NM(t) {
    return t === "class" ? "className" : t === "for" ? "htmlFor" : t === "formaction" ? "formAction" : t === "innerHtml" ? "innerHTML" : t === "readonly" ? "readOnly" : t === "tabindex" ? "tabIndex" : t
}
function F1(t, e, n, r, i, o, s, a) {
    let c = Sr(e, n), u = e.inputs, l;
    !a && u != null && (l = u[r]) ? (ig(t, n, l, r, i),
    xl(e) && PM(n, e.index)) : e.type & 3 ? (r = NM(r),
    i = s != null ? s(i, e.value || "", r) : i,
    o.setProperty(c, r, i)) : e.type & 12
}
function PM(t, e) {
    let n = Bo(e, t);
    n[Me] & 16 || (n[Me] |= 64)
}
function N1(t, e, n, r) {
    if (Pw()) {
        let i = r === null ? null : {
            "": -1
        }, o = jM(t, n), s, a;
        o === null ? s = a = null : [s,a] = o,
        s !== null && P1(t, e, n, s, i, a),
        i && $M(n, r, i)
    }
    n.mergedAttrs = Rp(n.mergedAttrs, n.attrs)
}
function P1(t, e, n, r, i, o) {
    for (let u = 0; u < r.length; u++)
        P2(Qw(n, e), t, r[u].type);
    zM(n, t.data.length, r.length);
    for (let u = 0; u < r.length; u++) {
        let l = r[u];
        l.providersResolver && l.providersResolver(l)
    }
    let s = !1
      , a = !1
      , c = S1(t, e, r.length, null);
    for (let u = 0; u < r.length; u++) {
        let l = r[u];
        n.mergedAttrs = Rp(n.mergedAttrs, l.hostAttrs),
        qM(t, n, e, c, l),
        HM(c, l, i),
        l.contentQueries !== null && (n.flags |= 4),
        (l.hostBindings !== null || l.hostAttrs !== null || l.hostVars !== 0) && (n.flags |= 64);
        let d = l.type.prototype;
        !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((t.preOrderHooks ??= []).push(n.index),
        s = !0),
        !a && (d.ngOnChanges || d.ngDoCheck) && ((t.preOrderCheckHooks ??= []).push(n.index),
        a = !0),
        c++
    }
    FM(t, n, o)
}
function OM(t, e, n, r, i) {
    let o = i.hostBindings;
    if (o) {
        let s = t.hostBindingOpCodes;
        s === null && (s = t.hostBindingOpCodes = []);
        let a = ~e.index;
        LM(s) != a && s.push(a),
        s.push(n, r, o)
    }
}
function LM(t) {
    let e = t.length;
    for (; e > 0; ) {
        let n = t[--e];
        if (typeof n == "number" && n < 0)
            return n
    }
    return 0
}
function UM(t, e, n, r) {
    let i = n.directiveStart
      , o = n.directiveEnd;
    xl(n) && WM(e, n, t.data[i + n.componentOffset]),
    t.firstCreatePass || Qw(n, e),
    Mo(r, e);
    let s = n.initialInputs;
    for (let a = i; a < o; a++) {
        let c = t.data[a]
          , u = za(e, t, a, n);
        if (Mo(u, e),
        s !== null && GM(e, a - i, u, c, n, s),
        Za(c)) {
            let l = Bo(n.index, e);
            l[Dr] = za(e, t, a, n)
        }
    }
}
function O1(t, e, n) {
    let r = n.directiveStart
      , i = n.directiveEnd
      , o = n.index
      , s = E2();
    try {
        So(o);
        for (let a = r; a < i; a++) {
            let c = t.data[a]
              , u = e[a];
            X0(a),
            (c.hostBindings !== null || c.hostVars !== 0 || c.hostAttrs !== null) && VM(c, u)
        }
    } finally {
        So(-1),
        X0(s)
    }
}
function VM(t, e) {
    t.hostBindings !== null && t.hostBindings(1, e)
}
function jM(t, e) {
    let n = t.directiveRegistry
      , r = null
      , i = null;
    if (n)
        for (let o = 0; o < n.length; o++) {
            let s = n[o];
            if (MS(e, s.selectors, !1))
                if (r || (r = []),
                Za(s))
                    if (s.findHostDirectiveDefs !== null) {
                        let a = [];
                        i = i || new Map,
                        s.findHostDirectiveDefs(s, a, i),
                        r.unshift(...a, s);
                        let c = a.length;
                        op(t, e, c)
                    } else
                        r.unshift(s),
                        op(t, e, 0);
                else
                    i = i || new Map,
                    s.findHostDirectiveDefs?.(s, r, i),
                    r.push(s)
        }
    return r === null ? null : [r, i]
}
function op(t, e, n) {
    e.componentOffset = n,
    (t.components ??= []).push(e.index)
}
function $M(t, e, n) {
    if (e) {
        let r = t.localNames = [];
        for (let i = 0; i < e.length; i += 2) {
            let o = n[e[i + 1]];
            if (o == null)
                throw new we(-301,!1);
            r.push(e[i], o)
        }
    }
}
function HM(t, e, n) {
    if (n) {
        if (e.exportAs)
            for (let r = 0; r < e.exportAs.length; r++)
                n[e.exportAs[r]] = t;
        Za(e) && (n[""] = t)
    }
}
function zM(t, e, n) {
    t.flags |= 1,
    t.directiveStart = e,
    t.directiveEnd = e + n,
    t.providerIndexes = e
}
function qM(t, e, n, r, i) {
    t.data[r] = i;
    let o = i.factory || (i.factory = _s(i.type, !0))
      , s = new Ha(o,Za(i),Qn);
    t.blueprint[r] = s,
    n[r] = s,
    OM(t, e, r, S1(t, n, i.hostVars, $i), i)
}
function WM(t, e, n) {
    let r = Sr(e, t)
      , i = R1(n)
      , o = t[Ir].rendererFactory
      , s = 16;
    n.signals ? s = 4096 : n.onPush && (s = 64);
    let a = _l(t, Il(t, i, null, s, r, e, null, o.createRenderer(r, n), null, null, null));
    t[e.index] = a
}
function GM(t, e, n, r, i, o) {
    let s = o[e];
    if (s !== null)
        for (let a = 0; a < s.length; ) {
            let c = s[a++]
              , u = s[a++]
              , l = s[a++]
              , d = s[a++];
            _1(r, n, c, u, l, d)
        }
}
function KM(t, e, n) {
    let r = null
      , i = 0;
    for (; i < n.length; ) {
        let o = n[i];
        if (o === 0) {
            i += 4;
            continue
        } else if (o === 5) {
            i += 2;
            continue
        }
        if (typeof o == "number")
            break;
        if (t.hasOwnProperty(o)) {
            r === null && (r = []);
            let s = t[o];
            for (let a = 0; a < s.length; a += 3)
                if (s[a] === e) {
                    r.push(o, s[a + 1], s[a + 2], n[i + 1]);
                    break
                }
        }
        i += 2
    }
    return r
}
function L1(t, e, n, r) {
    return [t, !0, 0, e, null, r, null, n, null, null]
}
function U1(t, e) {
    let n = t.contentQueries;
    if (n !== null) {
        let r = at(null);
        try {
            for (let i = 0; i < n.length; i += 2) {
                let o = n[i]
                  , s = n[i + 1];
                if (s !== -1) {
                    let a = t.data[s];
                    Vw(o),
                    a.contentQueries(2, e[s], s)
                }
            }
        } finally {
            at(r)
        }
    }
}
function _l(t, e) {
    return t[Va] ? t[_x][Cr] = e : t[Va] = e,
    t[_x] = e,
    e
}
function sp(t, e, n) {
    Vw(0);
    let r = at(null);
    try {
        e(t, n)
    } finally {
        at(r)
    }
}
function YM(t) {
    return t[Ua] || (t[Ua] = [])
}
function ZM(t) {
    return t.cleanup || (t.cleanup = [])
}
function V1(t, e) {
    let n = t[Ms]
      , r = n ? n.get($r, null) : null;
    r && r.handleError(e)
}
function ig(t, e, n, r, i) {
    for (let o = 0; o < n.length; ) {
        let s = n[o++]
          , a = n[o++]
          , c = n[o++]
          , u = e[s]
          , l = t.data[s];
        _1(l, u, r, a, c, i)
    }
}
function XM(t, e, n) {
    let r = Bw(e, t);
    aM(t[En], r, n)
}
function QM(t, e) {
    let n = Bo(e, t)
      , r = n[et];
    JM(r, n);
    let i = n[ui];
    i !== null && n[Gu] === null && (n[Gu] = Zp(i, n[Ms])),
    og(r, n, n[Dr])
}
function JM(t, e) {
    for (let n = e.length; n < t.blueprint.length; n++)
        e.push(t.blueprint[n])
}
function og(t, e, n) {
    jp(e);
    try {
        let r = t.viewQuery;
        r !== null && sp(1, r, n);
        let i = t.template;
        i !== null && M1(t, e, i, 1, n),
        t.firstCreatePass && (t.firstCreatePass = !1),
        e[ks]?.finishViewCreation(t),
        t.staticContentQueries && U1(t, e),
        t.staticViewQueries && sp(2, t.viewQuery, n);
        let o = t.components;
        o !== null && ek(e, o)
    } catch (r) {
        throw t.firstCreatePass && (t.incompleteFirstPass = !0,
        t.firstCreatePass = !1),
        r
    } finally {
        e[Me] &= -5,
        $p()
    }
}
function ek(t, e) {
    for (let n = 0; n < e.length; n++)
        QM(t, e[n])
}
function tk(t, e, n, r) {
    let i = at(null);
    try {
        let o = e.tView
          , a = t[Me] & 4096 ? 4096 : 16
          , c = Il(t, o, n, a, null, e, null, null, r?.injector ?? null, r?.embeddedViewInjector ?? null, r?.dehydratedView ?? null)
          , u = t[e.index];
        c[yl] = u;
        let l = t[ks];
        return l !== null && (c[ks] = l.createEmbeddedView(o)),
        og(o, c, n),
        c
    } finally {
        at(i)
    }
}
function Ux(t, e) {
    return !e || e.firstChild === null || a1(t)
}
function nk(t, e, n, r=!0) {
    let i = e[et];
    if (fM(i, e, t, n),
    r) {
        let s = ip(n, t)
          , a = e[En]
          , c = eg(a, t[_o]);
        c !== null && uM(i, t[_r], a, e, c, s)
    }
    let o = e[Gu];
    o !== null && o.firstChild !== null && (o.firstChild = null)
}
function tl(t, e, n, r, i=!1) {
    for (; n !== null; ) {
        let o = e[n.index];
        o !== null && r.push(jr(o)),
        li(o) && rk(o, r);
        let s = n.type;
        if (s & 8)
            tl(t, e, n.child, r);
        else if (s & 32) {
            let a = Jp(n, e), c;
            for (; c = a(); )
                r.push(c)
        } else if (s & 16) {
            let a = E1(e, n);
            if (Array.isArray(a))
                r.push(...a);
            else {
                let c = $a(e[Vr]);
                tl(c[et], c, a, r, !0)
            }
        }
        n = i ? n.projectionNext : n.next
    }
    return r
}
function rk(t, e) {
    for (let n = sr; n < t.length; n++) {
        let r = t[n]
          , i = r[et].firstChild;
        i !== null && tl(r[et], r, i, e)
    }
    t[_o] !== t[ui] && e.push(t[_o])
}
var j1 = [];
function ik(t) {
    return t[Ao] ?? ok(t)
}
function ok(t) {
    let e = j1.pop() ?? Object.create(ak);
    return e.lView = t,
    e
}
function sk(t) {
    t.lView[Ao] !== t && (t.lView = null,
    j1.push(t))
}
var ak = me(ee({}, Uv), {
    consumerIsAlwaysLive: !0,
    consumerMarkedDirty: t=>{
        ja(t.lView)
    }
    ,
    consumerOnSignalRead() {
        this.lView[Ao] = this
    }
})
  , $1 = 100;
function H1(t, e=!0, n=0) {
    let r = t[Ir]
      , i = r.rendererFactory
      , o = !1;
    o || i.begin?.();
    try {
        ck(t, n)
    } catch (s) {
        throw e && V1(t, s),
        s
    } finally {
        o || (i.end?.(),
        r.inlineEffectRunner?.flush())
    }
}
function ck(t, e) {
    ap(t, e);
    let n = 0;
    for (; Vp(t); ) {
        if (n === $1)
            throw new we(103,!1);
        n++,
        ap(t, 1)
    }
}
function uk(t, e, n, r) {
    let i = e[Me];
    if ((i & 256) === 256)
        return;
    let o = !1;
    !o && e[Ir].inlineEffectRunner?.flush(),
    jp(e);
    let s = null
      , a = null;
    !o && lk(t) && (a = ik(e),
    s = Vv(a));
    try {
        Fw(e),
        v2(t.bindingStartIndex),
        n !== null && M1(t, e, n, 2, r);
        let c = (i & 3) === 3;
        if (!o)
            if (c) {
                let d = t.preOrderCheckHooks;
                d !== null && Uu(e, d, null)
            } else {
                let d = t.preOrderHooks;
                d !== null && Vu(e, d, 0, null),
                T0(e, 0)
            }
        if (fk(e),
        z1(e, 0),
        t.contentQueries !== null && U1(t, e),
        !o)
            if (c) {
                let d = t.contentCheckHooks;
                d !== null && Uu(e, d)
            } else {
                let d = t.contentHooks;
                d !== null && Vu(e, d, 1),
                T0(e, 1)
            }
        _M(t, e);
        let u = t.components;
        u !== null && W1(e, u, 0);
        let l = t.viewQuery;
        if (l !== null && sp(2, l, r),
        !o)
            if (c) {
                let d = t.viewCheckHooks;
                d !== null && Uu(e, d)
            } else {
                let d = t.viewHooks;
                d !== null && Vu(e, d, 2),
                T0(e, 2)
            }
        if (t.firstUpdatePass === !0 && (t.firstUpdatePass = !1),
        e[k0]) {
            for (let d of e[k0])
                d();
            e[k0] = null
        }
        o || (e[Me] &= -73)
    } catch (c) {
        throw ja(e),
        c
    } finally {
        a !== null && (jv(a, s),
        sk(a)),
        $p()
    }
}
function lk(t) {
    return t.type !== 2
}
function z1(t, e) {
    for (let n = u1(t); n !== null; n = l1(n))
        for (let r = sr; r < n.length; r++) {
            let i = n[r];
            q1(i, e)
        }
}
function fk(t) {
    for (let e = u1(t); e !== null; e = l1(e)) {
        if (!(e[Me] & Op.HasTransplantedViews))
            continue;
        let n = e[Yu];
        for (let r = 0; r < n.length; r++) {
            let i = n[r]
              , o = i[bn];
            a2(i)
        }
    }
}
function dk(t, e, n) {
    let r = Bo(e, t);
    q1(r, n)
}
function q1(t, e) {
    Up(t) && ap(t, e)
}
function ap(t, e) {
    let r = t[et]
      , i = t[Me]
      , o = t[Ao]
      , s = !!(e === 0 && i & 16);
    if (s ||= !!(i & 64 && e === 0),
    s ||= !!(i & 1024),
    s ||= !!(o?.dirty && l0(o)),
    o && (o.dirty = !1),
    t[Me] &= -9217,
    s)
        uk(r, t, r.template, t[Dr]);
    else if (i & 8192) {
        z1(t, 1);
        let a = r.components;
        a !== null && W1(t, a, 1)
    }
}
function W1(t, e, n) {
    for (let r = 0; r < e.length; r++)
        dk(t, e[r], n)
}
function sg(t) {
    for (t[Ir].changeDetectionScheduler?.notify(); t; ) {
        t[Me] |= 64;
        let e = $a(t);
        if (QS(t) && !e)
            return t;
        t = e
    }
    return null
}
var ko = class {
    get rootNodes() {
        let e = this._lView
          , n = e[et];
        return tl(n, e, n.firstChild, [])
    }
    constructor(e, n, r=!0) {
        this._lView = e,
        this._cdRefInjectingView = n,
        this.notifyErrorHandler = r,
        this._appRef = null,
        this._attachedToViewContainer = !1
    }
    get context() {
        return this._lView[Dr]
    }
    set context(e) {
        this._lView[Dr] = e
    }
    get destroyed() {
        return (this._lView[Me] & 256) === 256
    }
    destroy() {
        if (this._appRef)
            this._appRef.detachView(this);
        else if (this._attachedToViewContainer) {
            let e = this._lView[bn];
            if (li(e)) {
                let n = e[Ku]
                  , r = n ? n.indexOf(this) : -1;
                r > -1 && (rp(e, r),
                qu(n, r))
            }
            this._attachedToViewContainer = !1
        }
        w1(this._lView[et], this._lView)
    }
    onDestroy(e) {
        Nw(this._lView, e)
    }
    markForCheck() {
        sg(this._cdRefInjectingView || this._lView)
    }
    detach() {
        this._lView[Me] &= -129
    }
    reattach() {
        Z0(this._lView),
        this._lView[Me] |= 128
    }
    detectChanges() {
        this._lView[Me] |= 1024,
        H1(this._lView, this.notifyErrorHandler)
    }
    checkNoChanges() {}
    attachToViewContainerRef() {
        if (this._appRef)
            throw new we(902,!1);
        this._attachedToViewContainer = !0
    }
    detachFromAppRef() {
        this._appRef = null,
        v1(this._lView[et], this._lView)
    }
    attachToAppRef(e) {
        if (this._attachedToViewContainer)
            throw new we(902,!1);
        this._appRef = e,
        Z0(this._lView)
    }
}
  , Sl = (()=>{
    let e = class e {
    }
    ;
    e.__NG_ELEMENT_ID__ = gk;
    let t = e;
    return t
}
)()
  , hk = Sl
  , pk = class extends hk {
    constructor(e, n, r) {
        super(),
        this._declarationLView = e,
        this._declarationTContainer = n,
        this.elementRef = r
    }
    get ssrId() {
        return this._declarationTContainer.tView?.ssrId || null
    }
    createEmbeddedView(e, n) {
        return this.createEmbeddedViewImpl(e, n)
    }
    createEmbeddedViewImpl(e, n, r) {
        let i = tk(this._declarationLView, this._declarationTContainer, e, {
            embeddedViewInjector: n,
            dehydratedView: r
        });
        return new ko(i)
    }
}
;
function gk() {
    return mk(Hr(), Lt())
}
function mk(t, e) {
    return t.type & 4 ? new pk(e,t,bl(t, e)) : null
}
var XV = new RegExp(`^(\\d+)*(${Q2}|${X2})*(.*)`);
var yk = ()=>null;
function Vx(t, e) {
    return yk(t, e)
}
var nl = class {
}
  , cp = class {
}
  , rl = class {
}
;
function vk(t) {
    let e = Error(`No component factory found for ${$n(t)}.`);
    return e[xk] = t,
    e
}
var xk = "ngComponent";
var up = class {
    resolveComponentFactory(e) {
        throw vk(e)
    }
}
  , Ml = (()=>{
    let e = class e {
    }
    ;
    e.NULL = new up;
    let t = e;
    return t
}
)()
  , qa = class {
}
;
var wk = (()=>{
    let e = class e {
    }
    ;
    e.\u0275prov = he({
        token: e,
        providedIn: "root",
        factory: ()=>null
    });
    let t = e;
    return t
}
)()
  , P0 = {};
var jx = new Set;
function kl(t) {
    jx.has(t) || (jx.add(t),
    performance?.mark?.("mark_feature_usage", {
        detail: {
            feature: t
        }
    }))
}
function $x(...t) {}
function bk() {
    let t = typeof Xn.requestAnimationFrame == "function"
      , e = Xn[t ? "requestAnimationFrame" : "setTimeout"]
      , n = Xn[t ? "cancelAnimationFrame" : "clearTimeout"];
    if (typeof Zone < "u" && e && n) {
        let r = e[Zone.__symbol__("OriginalDelegate")];
        r && (e = r);
        let i = n[Zone.__symbol__("OriginalDelegate")];
        i && (n = i)
    }
    return {
        nativeRequestAnimationFrame: e,
        nativeCancelAnimationFrame: n
    }
}
var wt = class t {
    constructor({enableLongStackTrace: e=!1, shouldCoalesceEventChangeDetection: n=!1, shouldCoalesceRunChangeDetection: r=!1}) {
        if (this.hasPendingMacrotasks = !1,
        this.hasPendingMicrotasks = !1,
        this.isStable = !0,
        this.onUnstable = new xn(!1),
        this.onMicrotaskEmpty = new xn(!1),
        this.onStable = new xn(!1),
        this.onError = new xn(!1),
        typeof Zone > "u")
            throw new we(908,!1);
        Zone.assertZonePatched();
        let i = this;
        i._nesting = 0,
        i._outer = i._inner = Zone.current,
        Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)),
        e && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)),
        i.shouldCoalesceEventChangeDetection = !r && n,
        i.shouldCoalesceRunChangeDetection = r,
        i.lastRequestAnimationFrameId = -1,
        i.nativeRequestAnimationFrame = bk().nativeRequestAnimationFrame,
        Dk(i)
    }
    static isInAngularZone() {
        return typeof Zone < "u" && Zone.current.get("isAngularZone") === !0
    }
    static assertInAngularZone() {
        if (!t.isInAngularZone())
            throw new we(909,!1)
    }
    static assertNotInAngularZone() {
        if (t.isInAngularZone())
            throw new we(909,!1)
    }
    run(e, n, r) {
        return this._inner.run(e, n, r)
    }
    runTask(e, n, r, i) {
        let o = this._inner
          , s = o.scheduleEventTask("NgZoneEvent: " + i, e, Ek, $x, $x);
        try {
            return o.runTask(s, n, r)
        } finally {
            o.cancelTask(s)
        }
    }
    runGuarded(e, n, r) {
        return this._inner.runGuarded(e, n, r)
    }
    runOutsideAngular(e) {
        return this._outer.run(e)
    }
}
  , Ek = {};
function ag(t) {
    if (t._nesting == 0 && !t.hasPendingMicrotasks && !t.isStable)
        try {
            t._nesting++,
            t.onMicrotaskEmpty.emit(null)
        } finally {
            if (t._nesting--,
            !t.hasPendingMicrotasks)
                try {
                    t.runOutsideAngular(()=>t.onStable.emit(null))
                } finally {
                    t.isStable = !0
                }
        }
}
function Ck(t) {
    t.isCheckStableRunning || t.lastRequestAnimationFrameId !== -1 || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Xn, ()=>{
        t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", ()=>{
            t.lastRequestAnimationFrameId = -1,
            lp(t),
            t.isCheckStableRunning = !0,
            ag(t),
            t.isCheckStableRunning = !1
        }
        , void 0, ()=>{}
        , ()=>{}
        )),
        t.fakeTopEventTask.invoke()
    }
    ),
    lp(t))
}
function Dk(t) {
    let e = ()=>{
        Ck(t)
    }
    ;
    t._inner = t._inner.fork({
        name: "angular",
        properties: {
            isAngularZone: !0
        },
        onInvokeTask: (n,r,i,o,s,a)=>{
            if (Ik(a))
                return n.invokeTask(i, o, s, a);
            try {
                return Hx(t),
                n.invokeTask(i, o, s, a)
            } finally {
                (t.shouldCoalesceEventChangeDetection && o.type === "eventTask" || t.shouldCoalesceRunChangeDetection) && e(),
                zx(t)
            }
        }
        ,
        onInvoke: (n,r,i,o,s,a,c)=>{
            try {
                return Hx(t),
                n.invoke(i, o, s, a, c)
            } finally {
                t.shouldCoalesceRunChangeDetection && e(),
                zx(t)
            }
        }
        ,
        onHasTask: (n,r,i,o)=>{
            n.hasTask(i, o),
            r === i && (o.change == "microTask" ? (t._hasPendingMicrotasks = o.microTask,
            lp(t),
            ag(t)) : o.change == "macroTask" && (t.hasPendingMacrotasks = o.macroTask))
        }
        ,
        onHandleError: (n,r,i,o)=>(n.handleError(i, o),
        t.runOutsideAngular(()=>t.onError.emit(o)),
        !1)
    })
}
function lp(t) {
    t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && t.lastRequestAnimationFrameId !== -1 ? t.hasPendingMicrotasks = !0 : t.hasPendingMicrotasks = !1
}
function Hx(t) {
    t._nesting++,
    t.isStable && (t.isStable = !1,
    t.onUnstable.emit(null))
}
function zx(t) {
    t._nesting--,
    ag(t)
}
var fp = class {
    constructor() {
        this.hasPendingMicrotasks = !1,
        this.hasPendingMacrotasks = !1,
        this.isStable = !0,
        this.onUnstable = new xn,
        this.onMicrotaskEmpty = new xn,
        this.onStable = new xn,
        this.onError = new xn
    }
    run(e, n, r) {
        return e.apply(n, r)
    }
    runGuarded(e, n, r) {
        return e.apply(n, r)
    }
    runOutsideAngular(e) {
        return e()
    }
    runTask(e, n, r, i) {
        return e.apply(n, r)
    }
}
;
function Ik(t) {
    return !Array.isArray(t) || t.length !== 1 ? !1 : t[0].data?.__ignore_ng_zone__ === !0
}
function Ak(t="zone.js", e) {
    return t === "noop" ? new fp : t === "zone.js" ? new wt(e) : t
}
var Cs = function(t) {
    return t[t.EarlyRead = 0] = "EarlyRead",
    t[t.Write = 1] = "Write",
    t[t.MixedReadWrite = 2] = "MixedReadWrite",
    t[t.Read = 3] = "Read",
    t
}(Cs || {})
  , _k = {
    destroy() {}
};
function Tl(t, e) {
    !e && YS(Tl);
    let n = e?.injector ?? ie(Mr);
    if (!iM(n))
        return _k;
    kl("NgAfterNextRender");
    let r = n.get(cg)
      , i = r.handler ??= new hp
      , o = e?.phase ?? Cs.MixedReadWrite
      , s = ()=>{
        i.unregister(c),
        a()
    }
      , a = n.get(Gp).onDestroy(s)
      , c = Ar(n, ()=>new dp(o,()=>{
        s(),
        t()
    }
    ));
    return i.register(c),
    {
        destroy: s
    }
}
var dp = class {
    constructor(e, n) {
        this.phase = e,
        this.callbackFn = n,
        this.zone = ie(wt),
        this.errorHandler = ie($r, {
            optional: !0
        }),
        ie(nl, {
            optional: !0
        })?.notify(1)
    }
    invoke() {
        try {
            this.zone.runOutsideAngular(this.callbackFn)
        } catch (e) {
            this.errorHandler?.handleError(e)
        }
    }
}
  , hp = class {
    constructor() {
        this.executingCallbacks = !1,
        this.buckets = {
            [Cs.EarlyRead]: new Set,
            [Cs.Write]: new Set,
            [Cs.MixedReadWrite]: new Set,
            [Cs.Read]: new Set
        },
        this.deferredCallbacks = new Set
    }
    register(e) {
        (this.executingCallbacks ? this.deferredCallbacks : this.buckets[e.phase]).add(e)
    }
    unregister(e) {
        this.buckets[e.phase].delete(e),
        this.deferredCallbacks.delete(e)
    }
    execute() {
        this.executingCallbacks = !0;
        for (let e of Object.values(this.buckets))
            for (let n of e)
                n.invoke();
        this.executingCallbacks = !1;
        for (let e of this.deferredCallbacks)
            this.buckets[e.phase].add(e);
        this.deferredCallbacks.clear()
    }
    destroy() {
        for (let e of Object.values(this.buckets))
            e.clear();
        this.deferredCallbacks.clear()
    }
}
  , cg = (()=>{
    let e = class e {
        constructor() {
            this.handler = null,
            this.internalCallbacks = []
        }
        execute() {
            this.executeInternalCallbacks(),
            this.handler?.execute()
        }
        executeInternalCallbacks() {
            let r = [...this.internalCallbacks];
            this.internalCallbacks.length = 0;
            for (let i of r)
                i()
        }
        ngOnDestroy() {
            this.handler?.destroy(),
            this.handler = null,
            this.internalCallbacks.length = 0
        }
    }
    ;
    e.\u0275prov = he({
        token: e,
        providedIn: "root",
        factory: ()=>new e
    });
    let t = e;
    return t
}
)();
function pp(t, e, n) {
    let r = n ? t.styles : null
      , i = n ? t.classes : null
      , o = 0;
    if (e !== null)
        for (let s = 0; s < e.length; s++) {
            let a = e[s];
            if (typeof a == "number")
                o = a;
            else if (o == 1)
                i = V0(i, a);
            else if (o == 2) {
                let c = a
                  , u = e[++s];
                r = V0(r, c + ": " + u + ";")
            }
        }
    n ? t.styles = r : t.stylesWithoutHost = r,
    n ? t.classes = i : t.classesWithoutHost = i
}
var il = class extends Ml {
    constructor(e) {
        super(),
        this.ngModule = e
    }
    resolveComponentFactory(e) {
        let n = Ui(e);
        return new Ts(n,this.ngModule)
    }
}
;
function qx(t) {
    let e = [];
    for (let n in t) {
        if (!t.hasOwnProperty(n))
            continue;
        let r = t[n];
        r !== void 0 && e.push({
            propName: Array.isArray(r) ? r[0] : r,
            templateName: n
        })
    }
    return e
}
function Sk(t) {
    let e = t.toLowerCase();
    return e === "svg" ? n2 : e === "math" ? r2 : null
}
var gp = class {
    constructor(e, n) {
        this.injector = e,
        this.parentInjector = n
    }
    get(e, n, r) {
        r = hl(r);
        let i = this.injector.get(e, P0, r);
        return i !== P0 || n === P0 ? i : this.parentInjector.get(e, n, r)
    }
}
  , Ts = class extends rl {
    get inputs() {
        let e = this.componentDef
          , n = e.inputTransforms
          , r = qx(e.inputs);
        if (n !== null)
            for (let i of r)
                n.hasOwnProperty(i.propName) && (i.transform = n[i.propName]);
        return r
    }
    get outputs() {
        return qx(this.componentDef.outputs)
    }
    constructor(e, n) {
        super(),
        this.componentDef = e,
        this.ngModule = n,
        this.componentType = e.type,
        this.selector = RS(e.selectors),
        this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [],
        this.isBoundToModule = !!n
    }
    create(e, n, r, i) {
        let o = at(null);
        try {
            i = i || this.ngModule;
            let s = i instanceof wn ? i : i?.injector;
            s && this.componentDef.getStandaloneInjector !== null && (s = this.componentDef.getStandaloneInjector(s) || s);
            let a = s ? new gp(e,s) : e
              , c = a.get(qa, null);
            if (c === null)
                throw new we(407,!1);
            let u = a.get(wk, null)
              , l = a.get(cg, null)
              , d = a.get(nl, null)
              , y = {
                rendererFactory: c,
                sanitizer: u,
                inlineEffectRunner: null,
                afterRenderEventManager: l,
                changeDetectionScheduler: d
            }
              , v = c.createRenderer(null, this.componentDef)
              , E = this.componentDef.selectors[0][0] || "div"
              , D = r ? kM(v, r, this.componentDef.encapsulation, a) : y1(v, E, Sk(E))
              , S = 512;
            this.componentDef.signals ? S |= 4096 : this.componentDef.onPush || (S |= 16);
            let w = null;
            D !== null && (w = Zp(D, a, !0));
            let M = rg(0, null, null, 1, 0, null, null, null, null, null, null)
              , F = Il(null, M, null, S, null, null, y, v, a, null, w);
            jp(F);
            let N, P;
            try {
                let O = this.componentDef, z, q = null;
                O.findHostDirectiveDefs ? (z = [],
                q = new Map,
                O.findHostDirectiveDefs(O, z, q),
                z.push(O)) : z = [O];
                let J = Mk(F, D)
                  , te = kk(J, D, O, z, F, y, v);
                P = Rw(M, Vi),
                D && Rk(v, O, D, r),
                n !== void 0 && Fk(P, this.ngContentSelectors, n),
                N = Bk(te, O, z, q, F, [Nk]),
                og(M, F, null)
            } finally {
                $p()
            }
            return new mp(this.componentType,N,bl(P, F),F,P)
        } finally {
            at(o)
        }
    }
}
  , mp = class extends cp {
    constructor(e, n, r, i, o) {
        super(),
        this.location = r,
        this._rootLView = i,
        this._tNode = o,
        this.previousInputValues = null,
        this.instance = n,
        this.hostView = this.changeDetectorRef = new ko(i,void 0,!1),
        this.componentType = e
    }
    setInput(e, n) {
        let r = this._tNode.inputs, i;
        if (r !== null && (i = r[e])) {
            if (this.previousInputValues ??= new Map,
            this.previousInputValues.has(e) && Object.is(this.previousInputValues.get(e), n))
                return;
            let o = this._rootLView;
            ig(o[et], o, i, e, n),
            this.previousInputValues.set(e, n);
            let s = Bo(this._tNode.index, o);
            sg(s)
        }
    }
    get injector() {
        return new Io(this._tNode,this._rootLView)
    }
    destroy() {
        this.hostView.destroy()
    }
    onDestroy(e) {
        this.hostView.onDestroy(e)
    }
}
;
function Mk(t, e) {
    let n = t[et]
      , r = Vi;
    return t[r] = e,
    Al(n, r, 2, "#host", null)
}
function kk(t, e, n, r, i, o, s) {
    let a = i[et];
    Tk(r, t, e, s);
    let c = null;
    e !== null && (c = Zp(e, i[Ms]));
    let u = o.rendererFactory.createRenderer(e, n)
      , l = 16;
    n.signals ? l = 4096 : n.onPush && (l = 64);
    let d = Il(i, R1(n), null, l, i[t.index], t, o, u, null, null, c);
    return a.firstCreatePass && op(a, t, r.length - 1),
    _l(i, d),
    i[t.index] = d
}
function Tk(t, e, n, r) {
    for (let i of t)
        e.mergedAttrs = Rp(e.mergedAttrs, i.hostAttrs);
    e.mergedAttrs !== null && (pp(e, e.mergedAttrs, !0),
    n !== null && D1(r, n, e))
}
function Bk(t, e, n, r, i, o) {
    let s = Hr()
      , a = i[et]
      , c = Sr(s, i);
    P1(a, i, s, n, null, r);
    for (let l = 0; l < n.length; l++) {
        let d = s.directiveStart + l
          , y = za(i, a, d, s);
        Mo(y, i)
    }
    O1(a, i, s),
    c && Mo(c, i);
    let u = za(i, a, s.directiveStart + s.componentOffset, s);
    if (t[Dr] = i[Dr] = u,
    o !== null)
        for (let l of o)
            l(u, e);
    return k1(a, s, i),
    u
}
function Rk(t, e, n, r) {
    if (r)
        z0(t, n, ["ng-version", "17.3.11"]);
    else {
        let {attrs: i, classes: o} = FS(e.selectors[0]);
        i && z0(t, n, i),
        o && o.length > 0 && C1(t, n, o.join(" "))
    }
}
function Fk(t, e, n) {
    let r = t.projection = [];
    for (let i = 0; i < e.length; i++) {
        let o = n[i];
        r.push(o != null ? Array.from(o) : null)
    }
}
function Nk() {
    let t = Hr();
    qp(Lt()[et], t)
}
var Os = (()=>{
    let e = class e {
    }
    ;
    e.__NG_ELEMENT_ID__ = Pk;
    let t = e;
    return t
}
)();
function Pk() {
    let t = Hr();
    return Lk(t, Lt())
}
var Ok = Os
  , G1 = class extends Ok {
    constructor(e, n, r) {
        super(),
        this._lContainer = e,
        this._hostTNode = n,
        this._hostLView = r
    }
    get element() {
        return bl(this._hostTNode, this._hostLView)
    }
    get injector() {
        return new Io(this._hostTNode,this._hostLView)
    }
    get parentInjector() {
        let e = Wp(this._hostTNode, this._hostLView);
        if (Yw(e)) {
            let n = Qu(e, this._hostLView)
              , r = Xu(e)
              , i = n[et].data[r + 8];
            return new Io(i,n)
        } else
            return new Io(null,this._hostLView)
    }
    clear() {
        for (; this.length > 0; )
            this.remove(this.length - 1)
    }
    get(e) {
        let n = Wx(this._lContainer);
        return n !== null && n[e] || null
    }
    get length() {
        return this._lContainer.length - sr
    }
    createEmbeddedView(e, n, r) {
        let i, o;
        typeof r == "number" ? i = r : r != null && (i = r.index,
        o = r.injector);
        let s = Vx(this._lContainer, e.ssrId)
          , a = e.createEmbeddedViewImpl(n || {}, o, s);
        return this.insertImpl(a, i, Ux(this._hostTNode, s)),
        a
    }
    createComponent(e, n, r, i, o) {
        let s = e && !XS(e), a;
        if (s)
            a = n;
        else {
            let E = n || {};
            a = E.index,
            r = E.injector,
            i = E.projectableNodes,
            o = E.environmentInjector || E.ngModuleRef
        }
        let c = s ? e : new Ts(Ui(e))
          , u = r || this.parentInjector;
        if (!o && c.ngModule == null) {
            let D = (s ? u : this.parentInjector).get(wn, null);
            D && (o = D)
        }
        let l = Ui(c.componentType ?? {})
          , d = Vx(this._lContainer, l?.id ?? null)
          , y = d?.firstChild ?? null
          , v = c.create(u, i, y, o);
        return this.insertImpl(v.hostView, a, Ux(this._hostTNode, d)),
        v
    }
    insert(e, n) {
        return this.insertImpl(e, n, !0)
    }
    insertImpl(e, n, r) {
        let i = e._lView;
        if (s2(i)) {
            let a = this.indexOf(e);
            if (a !== -1)
                this.detach(a);
            else {
                let c = i[bn]
                  , u = new G1(c,c[_r],c[bn]);
                u.detach(u.indexOf(e))
            }
        }
        let o = this._adjustIndex(n)
          , s = this._lContainer;
        return nk(s, i, o, r),
        e.attachToViewContainerRef(),
        lw(O0(s), o, e),
        e
    }
    move(e, n) {
        return this.insert(e, n)
    }
    indexOf(e) {
        let n = Wx(this._lContainer);
        return n !== null ? n.indexOf(e) : -1
    }
    remove(e) {
        let n = this._adjustIndex(e, -1)
          , r = rp(this._lContainer, n);
        r && (qu(O0(this._lContainer), n),
        w1(r[et], r))
    }
    detach(e) {
        let n = this._adjustIndex(e, -1)
          , r = rp(this._lContainer, n);
        return r && qu(O0(this._lContainer), n) != null ? new ko(r) : null
    }
    _adjustIndex(e, n=0) {
        return e ?? this.length + n
    }
}
;
function Wx(t) {
    return t[Ku]
}
function O0(t) {
    return t[Ku] || (t[Ku] = [])
}
function Lk(t, e) {
    let n, r = e[t.index];
    return li(r) ? n = r : (n = L1(r, e, null, t),
    e[t.index] = n,
    _l(e, n)),
    Vk(n, e, t, r),
    new G1(n,t,e)
}
function Uk(t, e) {
    let n = t[En]
      , r = n.createComment("")
      , i = Sr(e, t)
      , o = eg(n, i);
    return el(n, o, r, vM(n, i), !1),
    r
}
var Vk = Hk
  , jk = ()=>!1;
function $k(t, e, n) {
    return jk(t, e, n)
}
function Hk(t, e, n, r) {
    if (t[_o])
        return;
    let i;
    n.type & 8 ? i = jr(r) : i = Uk(e, n),
    t[_o] = i
}
function zk(t) {
    let e = []
      , n = new Map;
    function r(i) {
        let o = n.get(i);
        if (!o) {
            let s = t(i);
            n.set(i, o = s.then(Kk))
        }
        return o
    }
    return ol.forEach((i,o)=>{
        let s = [];
        i.templateUrl && s.push(r(i.templateUrl).then(u=>{
            i.template = u
        }
        ));
        let a = typeof i.styles == "string" ? [i.styles] : i.styles || [];
        if (i.styles = a,
        i.styleUrl && i.styleUrls?.length)
            throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
        if (i.styleUrls?.length) {
            let u = i.styles.length
              , l = i.styleUrls;
            i.styleUrls.forEach((d,y)=>{
                a.push(""),
                s.push(r(d).then(v=>{
                    a[u + y] = v,
                    l.splice(l.indexOf(d), 1),
                    l.length == 0 && (i.styleUrls = void 0)
                }
                ))
            }
            )
        } else
            i.styleUrl && s.push(r(i.styleUrl).then(u=>{
                a.push(u),
                i.styleUrl = void 0
            }
            ));
        let c = Promise.all(s).then(()=>Yk(o));
        e.push(c)
    }
    ),
    Wk(),
    Promise.all(e).then(()=>{}
    )
}
var ol = new Map
  , qk = new Set;
function Wk() {
    let t = ol;
    return ol = new Map,
    t
}
function Gk() {
    return ol.size === 0
}
function Kk(t) {
    return typeof t == "string" ? t : t.text()
}
function Yk(t) {
    qk.delete(t)
}
var ji = class {
}
  , Wa = class {
}
;
var sl = class extends ji {
    constructor(e, n, r) {
        super(),
        this._parent = n,
        this._bootstrapComponents = [],
        this.destroyCbs = [],
        this.componentFactoryResolver = new il(this);
        let i = vw(e);
        this._bootstrapComponents = m1(i.bootstrap),
        this._r3Injector = o1(e, n, [{
            provide: ji,
            useValue: this
        }, {
            provide: Ml,
            useValue: this.componentFactoryResolver
        }, ...r], $n(e), new Set(["environment"])),
        this._r3Injector.resolveInjectorInitializers(),
        this.instance = this._r3Injector.get(e)
    }
    get injector() {
        return this._r3Injector
    }
    destroy() {
        let e = this._r3Injector;
        !e.destroyed && e.destroy(),
        this.destroyCbs.forEach(n=>n()),
        this.destroyCbs = null
    }
    onDestroy(e) {
        this.destroyCbs.push(e)
    }
}
  , al = class extends Wa {
    constructor(e) {
        super(),
        this.moduleType = e
    }
    create(e) {
        return new sl(this.moduleType,e,[])
    }
}
;
function Zk(t, e, n) {
    return new sl(t,e,n)
}
var yp = class extends ji {
    constructor(e) {
        super(),
        this.componentFactoryResolver = new il(this),
        this.instance = null;
        let n = new La([...e.providers, {
            provide: ji,
            useValue: this
        }, {
            provide: Ml,
            useValue: this.componentFactoryResolver
        }],e.parent || Pp(),e.debugName,new Set(["environment"]));
        this.injector = n,
        e.runEnvironmentInitializers && n.resolveInjectorInitializers()
    }
    destroy() {
        this.injector.destroy()
    }
    onDestroy(e) {
        this.injector.onDestroy(e)
    }
}
;
function Bl(t, e, n=null) {
    return new yp({
        providers: t,
        parent: e,
        debugName: n,
        runEnvironmentInitializers: !0
    }).injector
}
var Ro = (()=>{
    let e = class e {
        constructor() {
            this.taskId = 0,
            this.pendingTasks = new Set,
            this.hasPendingTasks = new dn(!1)
        }
        get _hasPendingTasks() {
            return this.hasPendingTasks.value
        }
        add() {
            this._hasPendingTasks || this.hasPendingTasks.next(!0);
            let r = this.taskId++;
            return this.pendingTasks.add(r),
            r
        }
        remove(r) {
            this.pendingTasks.delete(r),
            this.pendingTasks.size === 0 && this._hasPendingTasks && this.hasPendingTasks.next(!1)
        }
        ngOnDestroy() {
            this.pendingTasks.clear(),
            this._hasPendingTasks && this.hasPendingTasks.next(!1)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function K1(t) {
    return Qk(t) ? Array.isArray(t) || !(t instanceof Map) && Symbol.iterator in t : !1
}
function Xk(t, e) {
    if (Array.isArray(t))
        for (let n = 0; n < t.length; n++)
            e(t[n]);
    else {
        let n = t[Symbol.iterator](), r;
        for (; !(r = n.next()).done; )
            e(r.value)
    }
}
function Qk(t) {
    return t !== null && (typeof t == "function" || typeof t == "object")
}
function ug(t, e, n) {
    let r = t[e];
    return Object.is(r, n) ? !1 : (t[e] = n,
    !0)
}
function Jk(t) {
    return (t.flags & 32) === 32
}
function eT(t, e, n, r, i, o, s, a, c) {
    let u = e.consts
      , l = Al(e, t, 4, s || null, Zu(u, a));
    N1(e, n, l, Zu(u, c)),
    qp(e, l);
    let d = l.tView = rg(2, l, r, i, o, e.directiveRegistry, e.pipeRegistry, null, e.schemas, u, null);
    return e.queries !== null && (e.queries.template(e, l),
    d.queries = e.queries.embeddedTView(l)),
    l
}
function Hi(t, e, n, r, i, o, s, a) {
    let c = Lt()
      , u = fi()
      , l = t + Vi
      , d = u.firstCreatePass ? eT(l, u, c, e, n, r, i, o, s) : u.data[l];
    Qa(d, !1);
    let y = tT(u, c, d, t);
    Hp() && tg(u, c, y, d),
    Mo(y, c);
    let v = L1(y, c, y, d);
    return c[l] = v,
    _l(c, v),
    $k(v, d, c),
    Lp(d) && T1(u, c, d),
    s != null && B1(c, d, a),
    Hi
}
var tT = nT;
function nT(t, e, n, r) {
    return zp(!0),
    e[En].createComment("")
}
function lg(t, e, n, r) {
    return ug(t, Uw(), n) ? e + Sp(n) + r : $i
}
function Pu(t, e) {
    return t << 17 | e << 2
}
function To(t) {
    return t >> 17 & 32767
}
function rT(t) {
    return (t & 2) == 2
}
function iT(t, e) {
    return t & 131071 | e << 17
}
function vp(t) {
    return t | 2
}
function Bs(t) {
    return (t & 131068) >> 2
}
function L0(t, e) {
    return t & -131069 | e << 2
}
function oT(t) {
    return (t & 1) === 1
}
function xp(t) {
    return t | 1
}
function sT(t, e, n, r, i, o) {
    let s = o ? e.classBindings : e.styleBindings
      , a = To(s)
      , c = Bs(s);
    t[r] = n;
    let u = !1, l;
    if (Array.isArray(n)) {
        let d = n;
        l = d[1],
        (l === null || Ya(d, l) > 0) && (u = !0)
    } else
        l = n;
    if (i)
        if (c !== 0) {
            let y = To(t[a + 1]);
            t[r + 1] = Pu(y, a),
            y !== 0 && (t[y + 1] = L0(t[y + 1], r)),
            t[a + 1] = iT(t[a + 1], r)
        } else
            t[r + 1] = Pu(a, 0),
            a !== 0 && (t[a + 1] = L0(t[a + 1], r)),
            a = r;
    else
        t[r + 1] = Pu(c, 0),
        a === 0 ? a = r : t[c + 1] = L0(t[c + 1], r),
        c = r;
    u && (t[r + 1] = vp(t[r + 1])),
    Gx(t, l, r, !0),
    Gx(t, l, r, !1),
    aT(e, l, t, r, o),
    s = Pu(a, c),
    o ? e.classBindings = s : e.styleBindings = s
}
function aT(t, e, n, r, i) {
    let o = i ? t.residualClasses : t.residualStyles;
    o != null && typeof e == "string" && Ya(o, e) >= 0 && (n[r + 1] = xp(n[r + 1]))
}
function Gx(t, e, n, r) {
    let i = t[n + 1]
      , o = e === null
      , s = r ? To(i) : Bs(i)
      , a = !1;
    for (; s !== 0 && (a === !1 || o); ) {
        let c = t[s]
          , u = t[s + 1];
        cT(c, e) && (a = !0,
        t[s + 1] = r ? xp(u) : vp(u)),
        s = r ? To(u) : Bs(u)
    }
    a && (t[n + 1] = r ? vp(i) : xp(i))
}
function cT(t, e) {
    return t === null || e == null || (Array.isArray(t) ? t[1] : t) === e ? !0 : Array.isArray(t) && typeof e == "string" ? Ya(t, e) >= 0 : !1
}
var Er = {
    textEnd: 0,
    key: 0,
    keyEnd: 0,
    value: 0,
    valueEnd: 0
};
function uT(t) {
    return t.substring(Er.key, Er.keyEnd)
}
function lT(t) {
    return fT(t),
    Y1(t, Z1(t, 0, Er.textEnd))
}
function Y1(t, e) {
    let n = Er.textEnd;
    return n === e ? -1 : (e = Er.keyEnd = dT(t, Er.key = e, n),
    Z1(t, e, n))
}
function fT(t) {
    Er.key = 0,
    Er.keyEnd = 0,
    Er.value = 0,
    Er.valueEnd = 0,
    Er.textEnd = t.length
}
function Z1(t, e, n) {
    for (; e < n && t.charCodeAt(e) <= 32; )
        e++;
    return e
}
function dT(t, e, n) {
    for (; e < n && t.charCodeAt(e) > 32; )
        e++;
    return e
}
function Cn(t, e, n) {
    let r = Lt()
      , i = Uw();
    if (ug(r, i, e)) {
        let o = fi()
          , s = Ww();
        F1(o, s, r, t, e, r[En], n, !1)
    }
    return Cn
}
function wp(t, e, n, r, i) {
    let o = e.inputs
      , s = i ? "class" : "style";
    ig(t, n, o[s], s, r)
}
function hT(t, e) {
    for (let n = lT(e); n >= 0; n = Y1(e, n))
        Bp(t, uT(e), !0)
}
function pT(t, e, n, r) {
    let i = fi()
      , o = x2(2);
    i.firstUpdatePass && gT(i, null, o, r);
    let s = Lt();
    if (n !== $i && ug(s, o, n)) {
        let a = i.data[Ps()];
        if (Q1(a, r) && !X1(i, o)) {
            let c = r ? a.classesWithoutHost : a.stylesWithoutHost;
            c !== null && (n = V0(c, n || "")),
            wp(i, a, s, n, r)
        } else
            bT(i, a, s, s[En], s[o + 1], s[o + 1] = wT(t, e, n), r, o)
    }
}
function X1(t, e) {
    return e >= t.expandoStartIndex
}
function gT(t, e, n, r) {
    let i = t.data;
    if (i[n + 1] === null) {
        let o = i[Ps()]
          , s = X1(t, n);
        Q1(o, r) && e === null && !s && (e = !1),
        e = mT(i, o, e, r),
        sT(i, o, e, n, s, r)
    }
}
function mT(t, e, n, r) {
    let i = C2(t)
      , o = r ? e.residualClasses : e.residualStyles;
    if (i === null)
        (r ? e.classBindings : e.styleBindings) === 0 && (n = U0(null, t, e, n, r),
        n = Ga(n, e.attrs, r),
        o = null);
    else {
        let s = e.directiveStylingLast;
        if (s === -1 || t[s] !== i)
            if (n = U0(i, t, e, n, r),
            o === null) {
                let c = yT(t, e, r);
                c !== void 0 && Array.isArray(c) && (c = U0(null, t, e, c[1], r),
                c = Ga(c, e.attrs, r),
                vT(t, e, r, c))
            } else
                o = xT(t, e, r)
    }
    return o !== void 0 && (r ? e.residualClasses = o : e.residualStyles = o),
    n
}
function yT(t, e, n) {
    let r = n ? e.classBindings : e.styleBindings;
    if (Bs(r) !== 0)
        return t[To(r)]
}
function vT(t, e, n, r) {
    let i = n ? e.classBindings : e.styleBindings;
    t[To(i)] = r
}
function xT(t, e, n) {
    let r, i = e.directiveEnd;
    for (let o = 1 + e.directiveStylingLast; o < i; o++) {
        let s = t[o].hostAttrs;
        r = Ga(r, s, n)
    }
    return Ga(r, e.attrs, n)
}
function U0(t, e, n, r, i) {
    let o = null
      , s = n.directiveEnd
      , a = n.directiveStylingLast;
    for (a === -1 ? a = n.directiveStart : a++; a < s && (o = e[a],
    r = Ga(r, o.hostAttrs, i),
    o !== t); )
        a++;
    return t !== null && (n.directiveStylingLast = a),
    r
}
function Ga(t, e, n) {
    let r = n ? 1 : 2
      , i = -1;
    if (e !== null)
        for (let o = 0; o < e.length; o++) {
            let s = e[o];
            typeof s == "number" ? i = s : i === r && (Array.isArray(t) || (t = t === void 0 ? [] : ["", t]),
            Bp(t, s, n ? !0 : e[++o]))
        }
    return t === void 0 ? null : t
}
function wT(t, e, n) {
    if (n == null || n === "")
        return Zn;
    let r = []
      , i = Cl(n);
    if (Array.isArray(i))
        for (let o = 0; o < i.length; o++)
            t(r, i[o], !0);
    else if (typeof i == "object")
        for (let o in i)
            i.hasOwnProperty(o) && t(r, o, i[o]);
    else
        typeof i == "string" && e(r, i);
    return r
}
function bT(t, e, n, r, i, o, s, a) {
    i === $i && (i = Zn);
    let c = 0
      , u = 0
      , l = 0 < i.length ? i[0] : null
      , d = 0 < o.length ? o[0] : null;
    for (; l !== null || d !== null; ) {
        let y = c < i.length ? i[c + 1] : void 0, v = u < o.length ? o[u + 1] : void 0, E = null, D;
        l === d ? (c += 2,
        u += 2,
        y !== v && (E = d,
        D = v)) : d === null || l !== null && l < d ? (c += 2,
        E = l) : (u += 2,
        E = d,
        D = v),
        E !== null && ET(t, e, n, r, E, D, s, a),
        l = c < i.length ? i[c] : null,
        d = u < o.length ? o[u] : null
    }
}
function ET(t, e, n, r, i, o, s, a) {
    if (!(e.type & 3))
        return;
    let c = t.data
      , u = c[a + 1]
      , l = oT(u) ? Kx(c, e, n, i, Bs(u), s) : void 0;
    if (!cl(l)) {
        cl(o) || rT(u) && (o = Kx(c, null, n, i, a, s));
        let d = Bw(Ps(), n);
        IM(r, s, d, i, o)
    }
}
function Kx(t, e, n, r, i, o) {
    let s = e === null, a;
    for (; i > 0; ) {
        let c = t[i]
          , u = Array.isArray(c)
          , l = u ? c[1] : c
          , d = l === null
          , y = n[i + 1];
        y === $i && (y = d ? Zn : void 0);
        let v = d ? S0(y, r) : l === r ? y : void 0;
        if (u && !cl(v) && (v = S0(c, r)),
        cl(v) && (a = v,
        s))
            return a;
        let E = t[i + 1];
        i = s ? To(E) : Bs(E)
    }
    if (e !== null) {
        let c = o ? e.residualClasses : e.residualStyles;
        c != null && (a = S0(c, r))
    }
    return a
}
function cl(t) {
    return t !== void 0
}
function Q1(t, e) {
    return (t.flags & (e ? 8 : 16)) !== 0
}
function J1(t, e, n) {
    let r = Lt()
      , i = lg(r, t, e, n);
    pT(Bp, hT, i, !0)
}
function CT(t, e, n, r, i, o) {
    let s = e.consts
      , a = Zu(s, i)
      , c = Al(e, t, 2, r, a);
    return N1(e, n, c, Zu(s, o)),
    c.attrs !== null && pp(c, c.attrs, !1),
    c.mergedAttrs !== null && pp(c, c.mergedAttrs, !0),
    e.queries !== null && e.queries.elementStart(e, c),
    c
}
function Ve(t, e, n, r) {
    let i = Lt()
      , o = fi()
      , s = Vi + t
      , a = i[En]
      , c = o.firstCreatePass ? CT(s, o, i, e, n, r) : o.data[s]
      , u = DT(o, i, c, a, e, t);
    i[s] = u;
    let l = Lp(c);
    return Qa(c, !0),
    D1(a, u, c),
    !Jk(c) && Hp() && tg(o, i, u, c),
    l2() === 0 && Mo(u, i),
    f2(),
    l && (T1(o, i, c),
    k1(o, c, i)),
    r !== null && B1(i, c),
    Ve
}
function Oe() {
    let t = Hr();
    Lw() ? y2() : (t = t.parent,
    Qa(t, !1));
    let e = t;
    p2(e) && g2(),
    d2();
    let n = fi();
    return n.firstCreatePass && (qp(n, t),
    _w(t) && n.queries.elementEnd(t)),
    e.classesWithoutHost != null && k2(e) && wp(n, e, Lt(), e.classesWithoutHost, !0),
    e.stylesWithoutHost != null && T2(e) && wp(n, e, Lt(), e.stylesWithoutHost, !1),
    Oe
}
function qr(t, e, n, r) {
    return Ve(t, e, n, r),
    Oe(),
    qr
}
var DT = (t,e,n,r,i,o)=>(zp(!0),
y1(r, i, A2()));
function ec() {
    return Lt()
}
var ul = "en-US";
var IT = ul;
function AT(t) {
    typeof t == "string" && (IT = t.toLowerCase().replace(/_/g, "-"))
}
function ar(t, e, n, r) {
    let i = Lt()
      , o = fi()
      , s = Hr();
    return ST(o, i, i[En], s, t, e, r),
    ar
}
function _T(t, e, n, r) {
    let i = t.cleanup;
    if (i != null)
        for (let o = 0; o < i.length - 1; o += 2) {
            let s = i[o];
            if (s === n && i[o + 1] === r) {
                let a = e[Ua]
                  , c = i[o + 2];
                return a.length > c ? a[c] : null
            }
            typeof s == "string" && (o += 2)
        }
    return null
}
function ST(t, e, n, r, i, o, s) {
    let a = Lp(r)
      , u = t.firstCreatePass && ZM(t)
      , l = e[Dr]
      , d = YM(e)
      , y = !0;
    if (r.type & 3 || s) {
        let D = Sr(r, e)
          , S = s ? s(D) : D
          , w = d.length
          , M = s ? N=>s(jr(N[r.index])) : r.index
          , F = null;
        if (!s && a && (F = _T(t, e, i, r.index)),
        F !== null) {
            let N = F.__ngLastListenerFn__ || F;
            N.__ngNextListenerFn__ = o,
            F.__ngLastListenerFn__ = o,
            y = !1
        } else {
            o = Zx(r, e, l, o, !1);
            let N = n.listen(S, i, o);
            d.push(o, N),
            u && u.push(i, M, w, w + 1)
        }
    } else
        o = Zx(r, e, l, o, !1);
    let v = r.outputs, E;
    if (y && v !== null && (E = v[i])) {
        let D = E.length;
        if (D)
            for (let S = 0; S < D; S += 2) {
                let w = E[S]
                  , M = E[S + 1]
                  , P = e[w][M].subscribe(o)
                  , O = d.length;
                d.push(o, P),
                u && u.push(i, r.index, O, -(O + 1))
            }
    }
}
function Yx(t, e, n, r) {
    let i = at(null);
    try {
        return Or(6, e, n),
        n(r) !== !1
    } catch (o) {
        return V1(t, o),
        !1
    } finally {
        Or(7, e, n),
        at(i)
    }
}
function Zx(t, e, n, r, i) {
    return function o(s) {
        if (s === Function)
            return r;
        let a = t.componentOffset > -1 ? Bo(t.index, e) : e;
        sg(a);
        let c = Yx(e, n, r, s)
          , u = o.__ngNextListenerFn__;
        for (; u; )
            c = Yx(e, n, u, s) && c,
            u = u.__ngNextListenerFn__;
        return i && c === !1 && s.preventDefault(),
        c
    }
}
function Nn(t=1) {
    return I2(t)
}
function Rl(t, e, n, r, i) {
    let o = Lt()
      , s = lg(o, e, n, r);
    if (s !== $i) {
        let a = fi()
          , c = Ww();
        F1(a, c, o, t, s, o[En], i, !1)
    }
    return Rl
}
function ht(t, e="") {
    let n = Lt()
      , r = fi()
      , i = t + Vi
      , o = r.firstCreatePass ? Al(r, i, 1, e, null) : r.data[i]
      , s = MT(r, n, o, e, t);
    n[i] = s,
    Hp() && tg(r, n, s, o),
    Qa(o, !1)
}
var MT = (t,e,n,r,i)=>(zp(!0),
sM(e[En], r));
function Fo(t) {
    return Ls("", t, ""),
    Fo
}
function Ls(t, e, n) {
    let r = Lt()
      , i = lg(r, t, e, n);
    return i !== $i && XM(r, Ps(), i),
    Ls
}
var kT = (()=>{
    let e = class e {
        constructor(r) {
            this._injector = r,
            this.cachedInjectors = new Map
        }
        getOrCreateStandaloneInjector(r) {
            if (!r.standalone)
                return null;
            if (!this.cachedInjectors.has(r)) {
                let i = bw(!1, r.type)
                  , o = i.length > 0 ? Bl([i], this._injector, `Standalone[${r.type.name}]`) : null;
                this.cachedInjectors.set(r, o)
            }
            return this.cachedInjectors.get(r)
        }
        ngOnDestroy() {
            try {
                for (let r of this.cachedInjectors.values())
                    r !== null && r.destroy()
            } finally {
                this.cachedInjectors.clear()
            }
        }
    }
    ;
    e.\u0275prov = he({
        token: e,
        providedIn: "environment",
        factory: ()=>new e(ve(wn))
    });
    let t = e;
    return t
}
)();
function eb(t) {
    kl("NgStandalone"),
    t.getStandaloneInjector = e=>e.get(kT).getOrCreateStandaloneInjector(t)
}
var Ou = null;
function TT(t) {
    Ou !== null && (t.defaultEncapsulation !== Ou.defaultEncapsulation || t.preserveWhitespaces !== Ou.preserveWhitespaces) || (Ou = t)
}
var Fl = (()=>{
    let e = class e {
        log(r) {
            console.log(r)
        }
        warn(r) {
            console.warn(r)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "platform"
    });
    let t = e;
    return t
}
)();
var fg = new be("")
  , tc = new be("")
  , Nl = (()=>{
    let e = class e {
        constructor(r, i, o) {
            this._ngZone = r,
            this.registry = i,
            this._pendingCount = 0,
            this._isZoneStable = !0,
            this._callbacks = [],
            this.taskTrackingZone = null,
            dg || (BT(o),
            o.addToWindow(i)),
            this._watchAngularEvents(),
            r.run(()=>{
                this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone")
            }
            )
        }
        _watchAngularEvents() {
            this._ngZone.onUnstable.subscribe({
                next: ()=>{
                    this._isZoneStable = !1
                }
            }),
            this._ngZone.runOutsideAngular(()=>{
                this._ngZone.onStable.subscribe({
                    next: ()=>{
                        wt.assertNotInAngularZone(),
                        queueMicrotask(()=>{
                            this._isZoneStable = !0,
                            this._runCallbacksIfReady()
                        }
                        )
                    }
                })
            }
            )
        }
        increasePendingRequestCount() {
            return this._pendingCount += 1,
            this._pendingCount
        }
        decreasePendingRequestCount() {
            if (this._pendingCount -= 1,
            this._pendingCount < 0)
                throw new Error("pending async requests below zero");
            return this._runCallbacksIfReady(),
            this._pendingCount
        }
        isStable() {
            return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks
        }
        _runCallbacksIfReady() {
            if (this.isStable())
                queueMicrotask(()=>{
                    for (; this._callbacks.length !== 0; ) {
                        let r = this._callbacks.pop();
                        clearTimeout(r.timeoutId),
                        r.doneCb()
                    }
                }
                );
            else {
                let r = this.getPendingTasks();
                this._callbacks = this._callbacks.filter(i=>i.updateCb && i.updateCb(r) ? (clearTimeout(i.timeoutId),
                !1) : !0)
            }
        }
        getPendingTasks() {
            return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(r=>({
                source: r.source,
                creationLocation: r.creationLocation,
                data: r.data
            })) : []
        }
        addCallback(r, i, o) {
            let s = -1;
            i && i > 0 && (s = setTimeout(()=>{
                this._callbacks = this._callbacks.filter(a=>a.timeoutId !== s),
                r()
            }
            , i)),
            this._callbacks.push({
                doneCb: r,
                timeoutId: s,
                updateCb: o
            })
        }
        whenStable(r, i, o) {
            if (o && !this.taskTrackingZone)
                throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
            this.addCallback(r, i, o),
            this._runCallbacksIfReady()
        }
        getPendingRequestCount() {
            return this._pendingCount
        }
        registerApplication(r) {
            this.registry.registerApplication(r, this)
        }
        unregisterApplication(r) {
            this.registry.unregisterApplication(r)
        }
        findProviders(r, i, o) {
            return []
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(wt),ve(Pl),ve(tc))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , Pl = (()=>{
    let e = class e {
        constructor() {
            this._applications = new Map
        }
        registerApplication(r, i) {
            this._applications.set(r, i)
        }
        unregisterApplication(r) {
            this._applications.delete(r)
        }
        unregisterAllApplications() {
            this._applications.clear()
        }
        getTestability(r) {
            return this._applications.get(r) || null
        }
        getAllTestabilities() {
            return Array.from(this._applications.values())
        }
        getAllRootElements() {
            return Array.from(this._applications.keys())
        }
        findTestabilityInTree(r, i=!0) {
            return dg?.findTestabilityInTree(this, r, i) ?? null
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "platform"
    });
    let t = e;
    return t
}
)();
function BT(t) {
    dg = t
}
var dg;
function Us(t) {
    return !!t && typeof t.then == "function"
}
function tb(t) {
    return !!t && typeof t.subscribe == "function"
}
var Ol = new be("")
  , nb = (()=>{
    let e = class e {
        constructor() {
            this.initialized = !1,
            this.done = !1,
            this.donePromise = new Promise((r,i)=>{
                this.resolve = r,
                this.reject = i
            }
            ),
            this.appInits = ie(Ol, {
                optional: !0
            }) ?? []
        }
        runInitializers() {
            if (this.initialized)
                return;
            let r = [];
            for (let o of this.appInits) {
                let s = o();
                if (Us(s))
                    r.push(s);
                else if (tb(s)) {
                    let a = new Promise((c,u)=>{
                        s.subscribe({
                            complete: c,
                            error: u
                        })
                    }
                    );
                    r.push(a)
                }
            }
            let i = ()=>{
                this.done = !0,
                this.resolve()
            }
            ;
            Promise.all(r).then(()=>{
                i()
            }
            ).catch(o=>{
                this.reject(o)
            }
            ),
            r.length === 0 && i(),
            this.initialized = !0
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , Ll = new be("");
function RT() {
    Hv(()=>{
        throw new we(600,!1)
    }
    )
}
function FT(t) {
    return t.isBoundToModule
}
function NT(t, e, n) {
    try {
        let r = n();
        return Us(r) ? r.catch(i=>{
            throw e.runOutsideAngular(()=>t.handleError(i)),
            i
        }
        ) : r
    } catch (r) {
        throw e.runOutsideAngular(()=>t.handleError(r)),
        r
    }
}
function rb(t, e) {
    return Array.isArray(e) ? e.reduce(rb, t) : ee(ee({}, t), e)
}
var No = (()=>{
    let e = class e {
        constructor() {
            this._bootstrapListeners = [],
            this._runningTick = !1,
            this._destroyed = !1,
            this._destroyListeners = [],
            this._views = [],
            this.internalErrorHandler = ie(s1),
            this.afterRenderEffectManager = ie(cg),
            this.externalTestViews = new Set,
            this.beforeRender = new Fn,
            this.afterTick = new Fn,
            this.componentTypes = [],
            this.components = [],
            this.isStable = ie(Ro).hasPendingTasks.pipe(Ue(r=>!r)),
            this._injector = ie(wn)
        }
        get destroyed() {
            return this._destroyed
        }
        get injector() {
            return this._injector
        }
        bootstrap(r, i) {
            let o = r instanceof rl;
            if (!this._injector.get(nb).done) {
                let v = !o && yw(r)
                  , E = !1;
                throw new we(405,E)
            }
            let a;
            o ? a = r : a = this._injector.get(Ml).resolveComponentFactory(r),
            this.componentTypes.push(a.componentType);
            let c = FT(a) ? void 0 : this._injector.get(ji)
              , u = i || a.selector
              , l = a.create(Mr.NULL, [], u, c)
              , d = l.location.nativeElement
              , y = l.injector.get(fg, null);
            return y?.registerApplication(d),
            l.onDestroy(()=>{
                this.detachView(l.hostView),
                $u(this.components, l),
                y?.unregisterApplication(d)
            }
            ),
            this._loadComponent(l),
            l
        }
        tick() {
            this._tick(!0)
        }
        _tick(r) {
            if (this._runningTick)
                throw new we(101,!1);
            let i = at(null);
            try {
                this._runningTick = !0,
                this.detectChangesInAttachedViews(r)
            } catch (o) {
                this.internalErrorHandler(o)
            } finally {
                this.afterTick.next(),
                this._runningTick = !1,
                at(i)
            }
        }
        detectChangesInAttachedViews(r) {
            let i = 0
              , o = this.afterRenderEffectManager;
            for (; ; ) {
                if (i === $1)
                    throw new we(103,!1);
                if (r) {
                    let s = i === 0;
                    this.beforeRender.next(s);
                    for (let {_lView: a, notifyErrorHandler: c} of this._views)
                        PT(a, s, c)
                }
                if (i++,
                o.executeInternalCallbacks(),
                ![...this.externalTestViews.keys(), ...this._views].some(({_lView: s})=>bp(s)) && (o.execute(),
                ![...this.externalTestViews.keys(), ...this._views].some(({_lView: s})=>bp(s))))
                    break
            }
        }
        attachView(r) {
            let i = r;
            this._views.push(i),
            i.attachToAppRef(this)
        }
        detachView(r) {
            let i = r;
            $u(this._views, i),
            i.detachFromAppRef()
        }
        _loadComponent(r) {
            this.attachView(r.hostView),
            this.tick(),
            this.components.push(r);
            let i = this._injector.get(Ll, []);
            [...this._bootstrapListeners, ...i].forEach(o=>o(r))
        }
        ngOnDestroy() {
            if (!this._destroyed)
                try {
                    this._destroyListeners.forEach(r=>r()),
                    this._views.slice().forEach(r=>r.destroy())
                } finally {
                    this._destroyed = !0,
                    this._views = [],
                    this._bootstrapListeners = [],
                    this._destroyListeners = []
                }
        }
        onDestroy(r) {
            return this._destroyListeners.push(r),
            ()=>$u(this._destroyListeners, r)
        }
        destroy() {
            if (this._destroyed)
                throw new we(406,!1);
            let r = this._injector;
            r.destroy && !r.destroyed && r.destroy()
        }
        get viewCount() {
            return this._views.length
        }
        warnIfDestroyed() {}
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function $u(t, e) {
    let n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}
function PT(t, e, n) {
    !e && !bp(t) || OT(t, n, e)
}
function bp(t) {
    return Vp(t)
}
function OT(t, e, n) {
    let r;
    n ? (r = 0,
    t[Me] |= 1024) : t[Me] & 64 ? r = 0 : r = 1,
    H1(t, e, r)
}
var Ep = class {
    constructor(e, n) {
        this.ngModuleFactory = e,
        this.componentFactories = n
    }
}
  , Ul = (()=>{
    let e = class e {
        compileModuleSync(r) {
            return new al(r)
        }
        compileModuleAsync(r) {
            return Promise.resolve(this.compileModuleSync(r))
        }
        compileModuleAndAllComponentsSync(r) {
            let i = this.compileModuleSync(r)
              , o = vw(r)
              , s = m1(o.declarations).reduce((a,c)=>{
                let u = Ui(c);
                return u && a.push(new Ts(u)),
                a
            }
            , []);
            return new Ep(i,s)
        }
        compileModuleAndAllComponentsAsync(r) {
            return Promise.resolve(this.compileModuleAndAllComponentsSync(r))
        }
        clearCache() {}
        clearCacheFor(r) {}
        getModuleId(r) {}
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , LT = new be("");
function UT(t, e, n) {
    let r = new al(n);
    return Promise.resolve(r)
}
function Xx(t) {
    for (let e = t.length - 1; e >= 0; e--)
        if (t[e] !== void 0)
            return t[e]
}
var VT = (()=>{
    let e = class e {
        constructor() {
            this.zone = ie(wt),
            this.applicationRef = ie(No)
        }
        initialize() {
            this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
                next: ()=>{
                    this.zone.run(()=>{
                        this.applicationRef.tick()
                    }
                    )
                }
            }))
        }
        ngOnDestroy() {
            this._onMicrotaskEmptySubscription?.unsubscribe()
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function jT(t) {
    return [{
        provide: wt,
        useFactory: t
    }, {
        provide: Ss,
        multi: !0,
        useFactory: ()=>{
            let e = ie(VT, {
                optional: !0
            });
            return ()=>e.initialize()
        }
    }, {
        provide: Ss,
        multi: !0,
        useFactory: ()=>{
            let e = ie(zT);
            return ()=>{
                e.initialize()
            }
        }
    }, {
        provide: s1,
        useFactory: $T
    }]
}
function $T() {
    let t = ie(wt)
      , e = ie($r);
    return n=>t.runOutsideAngular(()=>e.handleError(n))
}
function HT(t) {
    return {
        enableLongStackTrace: !1,
        shouldCoalesceEventChangeDetection: t?.eventCoalescing ?? !1,
        shouldCoalesceRunChangeDetection: t?.runCoalescing ?? !1
    }
}
var zT = (()=>{
    let e = class e {
        constructor() {
            this.subscription = new en,
            this.initialized = !1,
            this.zone = ie(wt),
            this.pendingTasks = ie(Ro)
        }
        initialize() {
            if (this.initialized)
                return;
            this.initialized = !0;
            let r = null;
            !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (r = this.pendingTasks.add()),
            this.zone.runOutsideAngular(()=>{
                this.subscription.add(this.zone.onStable.subscribe(()=>{
                    wt.assertNotInAngularZone(),
                    queueMicrotask(()=>{
                        r !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(r),
                        r = null)
                    }
                    )
                }
                ))
            }
            ),
            this.subscription.add(this.zone.onUnstable.subscribe(()=>{
                wt.assertInAngularZone(),
                r ??= this.pendingTasks.add()
            }
            ))
        }
        ngOnDestroy() {
            this.subscription.unsubscribe()
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function qT() {
    return typeof $localize < "u" && $localize.locale || ul
}
var hg = new be("",{
    providedIn: "root",
    factory: ()=>ie(hg, $e.Optional | $e.SkipSelf) || qT()
});
var ib = new be("")
  , ob = (()=>{
    let e = class e {
        constructor(r) {
            this._injector = r,
            this._modules = [],
            this._destroyListeners = [],
            this._destroyed = !1
        }
        bootstrapModuleFactory(r, i) {
            let o = Ak(i?.ngZone, HT({
                eventCoalescing: i?.ngZoneEventCoalescing,
                runCoalescing: i?.ngZoneRunCoalescing
            }));
            return o.run(()=>{
                let s = Zk(r.moduleType, this.injector, jT(()=>o))
                  , a = s.injector.get($r, null);
                return o.runOutsideAngular(()=>{
                    let c = o.onError.subscribe({
                        next: u=>{
                            a.handleError(u)
                        }
                    });
                    s.onDestroy(()=>{
                        $u(this._modules, s),
                        c.unsubscribe()
                    }
                    )
                }
                ),
                NT(a, o, ()=>{
                    let c = s.injector.get(nb);
                    return c.runInitializers(),
                    c.donePromise.then(()=>{
                        let u = s.injector.get(hg, ul);
                        return AT(u || ul),
                        this._moduleDoBootstrap(s),
                        s
                    }
                    )
                }
                )
            }
            )
        }
        bootstrapModule(r, i=[]) {
            let o = rb({}, i);
            return UT(this.injector, o, r).then(s=>this.bootstrapModuleFactory(s, o))
        }
        _moduleDoBootstrap(r) {
            let i = r.injector.get(No);
            if (r._bootstrapComponents.length > 0)
                r._bootstrapComponents.forEach(o=>i.bootstrap(o));
            else if (r.instance.ngDoBootstrap)
                r.instance.ngDoBootstrap(i);
            else
                throw new we(-403,!1);
            this._modules.push(r)
        }
        onDestroy(r) {
            this._destroyListeners.push(r)
        }
        get injector() {
            return this._injector
        }
        destroy() {
            if (this._destroyed)
                throw new we(404,!1);
            this._modules.slice().forEach(i=>i.destroy()),
            this._destroyListeners.forEach(i=>i());
            let r = this._injector.get(ib, null);
            r && (r.forEach(i=>i()),
            r.clear()),
            this._destroyed = !0
        }
        get destroyed() {
            return this._destroyed
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Mr))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "platform"
    });
    let t = e;
    return t
}
)()
  , Na = null
  , sb = new be("");
function WT(t) {
    if (Na && !Na.get(sb, !1))
        throw new we(400,!1);
    RT(),
    Na = t;
    let e = t.get(ob);
    return YT(t),
    e
}
function pg(t, e, n=[]) {
    let r = `Platform: ${e}`
      , i = new be(r);
    return (o=[])=>{
        let s = ab();
        if (!s || s.injector.get(sb, !1)) {
            let a = [...n, ...o, {
                provide: i,
                useValue: !0
            }];
            t ? t(a) : WT(GT(a, r))
        }
        return KT(i)
    }
}
function GT(t=[], e) {
    return Mr.create({
        name: e,
        providers: [{
            provide: ml,
            useValue: "platform"
        }, {
            provide: ib,
            useValue: new Set([()=>Na = null])
        }, ...t]
    })
}
function KT(t) {
    let e = ab();
    if (!e)
        throw new we(401,!1);
    return e
}
function ab() {
    return Na?.get(ob) ?? null
}
function YT(t) {
    t.get(Kp, null)?.forEach(n=>n())
}
var Vs = (()=>{
    let e = class e {
    }
    ;
    e.__NG_ELEMENT_ID__ = ZT;
    let t = e;
    return t
}
)();
function ZT(t) {
    return XT(Hr(), Lt(), (t & 16) === 16)
}
function XT(t, e, n) {
    if (xl(t) && !n) {
        let r = Bo(t.index, e);
        return new ko(r,r)
    } else if (t.type & 47) {
        let r = e[Vr];
        return new ko(r,e)
    }
    return null
}
var Cp = class {
    constructor() {}
    supports(e) {
        return K1(e)
    }
    create(e) {
        return new Dp(e)
    }
}
  , QT = (t,e)=>e
  , Dp = class {
    constructor(e) {
        this.length = 0,
        this._linkedRecords = null,
        this._unlinkedRecords = null,
        this._previousItHead = null,
        this._itHead = null,
        this._itTail = null,
        this._additionsHead = null,
        this._additionsTail = null,
        this._movesHead = null,
        this._movesTail = null,
        this._removalsHead = null,
        this._removalsTail = null,
        this._identityChangesHead = null,
        this._identityChangesTail = null,
        this._trackByFn = e || QT
    }
    forEachItem(e) {
        let n;
        for (n = this._itHead; n !== null; n = n._next)
            e(n)
    }
    forEachOperation(e) {
        let n = this._itHead
          , r = this._removalsHead
          , i = 0
          , o = null;
        for (; n || r; ) {
            let s = !r || n && n.currentIndex < Qx(r, i, o) ? n : r
              , a = Qx(s, i, o)
              , c = s.currentIndex;
            if (s === r)
                i--,
                r = r._nextRemoved;
            else if (n = n._next,
            s.previousIndex == null)
                i++;
            else {
                o || (o = []);
                let u = a - i
                  , l = c - i;
                if (u != l) {
                    for (let y = 0; y < u; y++) {
                        let v = y < o.length ? o[y] : o[y] = 0
                          , E = v + y;
                        l <= E && E < u && (o[y] = v + 1)
                    }
                    let d = s.previousIndex;
                    o[d] = l - u
                }
            }
            a !== c && e(s, a, c)
        }
    }
    forEachPreviousItem(e) {
        let n;
        for (n = this._previousItHead; n !== null; n = n._nextPrevious)
            e(n)
    }
    forEachAddedItem(e) {
        let n;
        for (n = this._additionsHead; n !== null; n = n._nextAdded)
            e(n)
    }
    forEachMovedItem(e) {
        let n;
        for (n = this._movesHead; n !== null; n = n._nextMoved)
            e(n)
    }
    forEachRemovedItem(e) {
        let n;
        for (n = this._removalsHead; n !== null; n = n._nextRemoved)
            e(n)
    }
    forEachIdentityChange(e) {
        let n;
        for (n = this._identityChangesHead; n !== null; n = n._nextIdentityChange)
            e(n)
    }
    diff(e) {
        if (e == null && (e = []),
        !K1(e))
            throw new we(900,!1);
        return this.check(e) ? this : null
    }
    onDestroy() {}
    check(e) {
        this._reset();
        let n = this._itHead, r = !1, i, o, s;
        if (Array.isArray(e)) {
            this.length = e.length;
            for (let a = 0; a < this.length; a++)
                o = e[a],
                s = this._trackByFn(a, o),
                n === null || !Object.is(n.trackById, s) ? (n = this._mismatch(n, o, s, a),
                r = !0) : (r && (n = this._verifyReinsertion(n, o, s, a)),
                Object.is(n.item, o) || this._addIdentityChange(n, o)),
                n = n._next
        } else
            i = 0,
            Xk(e, a=>{
                s = this._trackByFn(i, a),
                n === null || !Object.is(n.trackById, s) ? (n = this._mismatch(n, a, s, i),
                r = !0) : (r && (n = this._verifyReinsertion(n, a, s, i)),
                Object.is(n.item, a) || this._addIdentityChange(n, a)),
                n = n._next,
                i++
            }
            ),
            this.length = i;
        return this._truncate(n),
        this.collection = e,
        this.isDirty
    }
    get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null
    }
    _reset() {
        if (this.isDirty) {
            let e;
            for (e = this._previousItHead = this._itHead; e !== null; e = e._next)
                e._nextPrevious = e._next;
            for (e = this._additionsHead; e !== null; e = e._nextAdded)
                e.previousIndex = e.currentIndex;
            for (this._additionsHead = this._additionsTail = null,
            e = this._movesHead; e !== null; e = e._nextMoved)
                e.previousIndex = e.currentIndex;
            this._movesHead = this._movesTail = null,
            this._removalsHead = this._removalsTail = null,
            this._identityChangesHead = this._identityChangesTail = null
        }
    }
    _mismatch(e, n, r, i) {
        let o;
        return e === null ? o = this._itTail : (o = e._prev,
        this._remove(e)),
        e = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null),
        e !== null ? (Object.is(e.item, n) || this._addIdentityChange(e, n),
        this._reinsertAfter(e, o, i)) : (e = this._linkedRecords === null ? null : this._linkedRecords.get(r, i),
        e !== null ? (Object.is(e.item, n) || this._addIdentityChange(e, n),
        this._moveAfter(e, o, i)) : e = this._addAfter(new Ip(n,r), o, i)),
        e
    }
    _verifyReinsertion(e, n, r, i) {
        let o = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null);
        return o !== null ? e = this._reinsertAfter(o, e._prev, i) : e.currentIndex != i && (e.currentIndex = i,
        this._addToMoves(e, i)),
        e
    }
    _truncate(e) {
        for (; e !== null; ) {
            let n = e._next;
            this._addToRemovals(this._unlink(e)),
            e = n
        }
        this._unlinkedRecords !== null && this._unlinkedRecords.clear(),
        this._additionsTail !== null && (this._additionsTail._nextAdded = null),
        this._movesTail !== null && (this._movesTail._nextMoved = null),
        this._itTail !== null && (this._itTail._next = null),
        this._removalsTail !== null && (this._removalsTail._nextRemoved = null),
        this._identityChangesTail !== null && (this._identityChangesTail._nextIdentityChange = null)
    }
    _reinsertAfter(e, n, r) {
        this._unlinkedRecords !== null && this._unlinkedRecords.remove(e);
        let i = e._prevRemoved
          , o = e._nextRemoved;
        return i === null ? this._removalsHead = o : i._nextRemoved = o,
        o === null ? this._removalsTail = i : o._prevRemoved = i,
        this._insertAfter(e, n, r),
        this._addToMoves(e, r),
        e
    }
    _moveAfter(e, n, r) {
        return this._unlink(e),
        this._insertAfter(e, n, r),
        this._addToMoves(e, r),
        e
    }
    _addAfter(e, n, r) {
        return this._insertAfter(e, n, r),
        this._additionsTail === null ? this._additionsTail = this._additionsHead = e : this._additionsTail = this._additionsTail._nextAdded = e,
        e
    }
    _insertAfter(e, n, r) {
        let i = n === null ? this._itHead : n._next;
        return e._next = i,
        e._prev = n,
        i === null ? this._itTail = e : i._prev = e,
        n === null ? this._itHead = e : n._next = e,
        this._linkedRecords === null && (this._linkedRecords = new ll),
        this._linkedRecords.put(e),
        e.currentIndex = r,
        e
    }
    _remove(e) {
        return this._addToRemovals(this._unlink(e))
    }
    _unlink(e) {
        this._linkedRecords !== null && this._linkedRecords.remove(e);
        let n = e._prev
          , r = e._next;
        return n === null ? this._itHead = r : n._next = r,
        r === null ? this._itTail = n : r._prev = n,
        e
    }
    _addToMoves(e, n) {
        return e.previousIndex === n || (this._movesTail === null ? this._movesTail = this._movesHead = e : this._movesTail = this._movesTail._nextMoved = e),
        e
    }
    _addToRemovals(e) {
        return this._unlinkedRecords === null && (this._unlinkedRecords = new ll),
        this._unlinkedRecords.put(e),
        e.currentIndex = null,
        e._nextRemoved = null,
        this._removalsTail === null ? (this._removalsTail = this._removalsHead = e,
        e._prevRemoved = null) : (e._prevRemoved = this._removalsTail,
        this._removalsTail = this._removalsTail._nextRemoved = e),
        e
    }
    _addIdentityChange(e, n) {
        return e.item = n,
        this._identityChangesTail === null ? this._identityChangesTail = this._identityChangesHead = e : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = e,
        e
    }
}
  , Ip = class {
    constructor(e, n) {
        this.item = e,
        this.trackById = n,
        this.currentIndex = null,
        this.previousIndex = null,
        this._nextPrevious = null,
        this._prev = null,
        this._next = null,
        this._prevDup = null,
        this._nextDup = null,
        this._prevRemoved = null,
        this._nextRemoved = null,
        this._nextAdded = null,
        this._nextMoved = null,
        this._nextIdentityChange = null
    }
}
  , Ap = class {
    constructor() {
        this._head = null,
        this._tail = null
    }
    add(e) {
        this._head === null ? (this._head = this._tail = e,
        e._nextDup = null,
        e._prevDup = null) : (this._tail._nextDup = e,
        e._prevDup = this._tail,
        e._nextDup = null,
        this._tail = e)
    }
    get(e, n) {
        let r;
        for (r = this._head; r !== null; r = r._nextDup)
            if ((n === null || n <= r.currentIndex) && Object.is(r.trackById, e))
                return r;
        return null
    }
    remove(e) {
        let n = e._prevDup
          , r = e._nextDup;
        return n === null ? this._head = r : n._nextDup = r,
        r === null ? this._tail = n : r._prevDup = n,
        this._head === null
    }
}
  , ll = class {
    constructor() {
        this.map = new Map
    }
    put(e) {
        let n = e.trackById
          , r = this.map.get(n);
        r || (r = new Ap,
        this.map.set(n, r)),
        r.add(e)
    }
    get(e, n) {
        let r = e
          , i = this.map.get(r);
        return i ? i.get(e, n) : null
    }
    remove(e) {
        let n = e.trackById;
        return this.map.get(n).remove(e) && this.map.delete(n),
        e
    }
    get isEmpty() {
        return this.map.size === 0
    }
    clear() {
        this.map.clear()
    }
}
;
function Qx(t, e, n) {
    let r = t.previousIndex;
    if (r === null)
        return r;
    let i = 0;
    return n && r < n.length && (i = n[r]),
    r + e + i
}
function Jx() {
    return new gg([new Cp])
}
var gg = (()=>{
    let e = class e {
        constructor(r) {
            this.factories = r
        }
        static create(r, i) {
            if (i != null) {
                let o = i.factories.slice();
                r = r.concat(o)
            }
            return new e(r)
        }
        static extend(r) {
            return {
                provide: e,
                useFactory: i=>e.create(r, i || Jx()),
                deps: [[e, new kp, new pl]]
            }
        }
        find(r) {
            let i = this.factories.find(o=>o.supports(r));
            if (i != null)
                return i;
            throw new we(901,!1)
        }
    }
    ;
    e.\u0275prov = he({
        token: e,
        providedIn: "root",
        factory: Jx
    });
    let t = e;
    return t
}
)();
var cb = pg(null, "core", [])
  , ub = (()=>{
    let e = class e {
        constructor(r) {}
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(No))
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({});
    let t = e;
    return t
}
)();
function lb(t) {
    let e = Ui(t);
    if (!e)
        return null;
    let n = new Ts(e);
    return {
        get selector() {
            return n.selector
        },
        get type() {
            return n.componentType
        },
        get inputs() {
            return n.inputs
        },
        get outputs() {
            return n.outputs
        },
        get ngContentSelectors() {
            return n.ngContentSelectors
        },
        get isStandalone() {
            return e.standalone
        },
        get isSignal() {
            return e.signals
        }
    }
}
var mb = null;
function Po() {
    return mb
}
function yb(t) {
    mb ??= t
}
var Vl = class {
}
;
var Dn = new be("")
  , Eg = (()=>{
    let e = class e {
        historyGo(r) {
            throw new Error("")
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>ie(tB),
        providedIn: "platform"
    });
    let t = e;
    return t
}
)()
  , vb = new be("")
  , tB = (()=>{
    let e = class e extends Eg {
        constructor() {
            super(),
            this._doc = ie(Dn),
            this._location = window.location,
            this._history = window.history
        }
        getBaseHrefFromDOM() {
            return Po().getBaseHref(this._doc)
        }
        onPopState(r) {
            let i = Po().getGlobalEventTarget(this._doc, "window");
            return i.addEventListener("popstate", r, !1),
            ()=>i.removeEventListener("popstate", r)
        }
        onHashChange(r) {
            let i = Po().getGlobalEventTarget(this._doc, "window");
            return i.addEventListener("hashchange", r, !1),
            ()=>i.removeEventListener("hashchange", r)
        }
        get href() {
            return this._location.href
        }
        get protocol() {
            return this._location.protocol
        }
        get hostname() {
            return this._location.hostname
        }
        get port() {
            return this._location.port
        }
        get pathname() {
            return this._location.pathname
        }
        get search() {
            return this._location.search
        }
        get hash() {
            return this._location.hash
        }
        set pathname(r) {
            this._location.pathname = r
        }
        pushState(r, i, o) {
            this._history.pushState(r, i, o)
        }
        replaceState(r, i, o) {
            this._history.replaceState(r, i, o)
        }
        forward() {
            this._history.forward()
        }
        back() {
            this._history.back()
        }
        historyGo(r=0) {
            this._history.go(r)
        }
        getState() {
            return this._history.state
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>new e,
        providedIn: "platform"
    });
    let t = e;
    return t
}
)();
function Cg(t, e) {
    if (t.length == 0)
        return e;
    if (e.length == 0)
        return t;
    let n = 0;
    return t.endsWith("/") && n++,
    e.startsWith("/") && n++,
    n == 2 ? t + e.substring(1) : n == 1 ? t + e : t + "/" + e
}
function fb(t) {
    let e = t.match(/#|\?|$/)
      , n = e && e.index || t.length
      , r = n - (t[n - 1] === "/" ? 1 : 0);
    return t.slice(0, r) + t.slice(n)
}
function pi(t) {
    return t && t[0] !== "?" ? "?" + t : t
}
var Oo = (()=>{
    let e = class e {
        historyGo(r) {
            throw new Error("")
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>ie(Dg),
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , xb = new be("")
  , Dg = (()=>{
    let e = class e extends Oo {
        constructor(r, i) {
            super(),
            this._platformLocation = r,
            this._removeListenerFns = [],
            this._baseHref = i ?? this._platformLocation.getBaseHrefFromDOM() ?? ie(Dn).location?.origin ?? ""
        }
        ngOnDestroy() {
            for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()()
        }
        onPopState(r) {
            this._removeListenerFns.push(this._platformLocation.onPopState(r), this._platformLocation.onHashChange(r))
        }
        getBaseHref() {
            return this._baseHref
        }
        prepareExternalUrl(r) {
            return Cg(this._baseHref, r)
        }
        path(r=!1) {
            let i = this._platformLocation.pathname + pi(this._platformLocation.search)
              , o = this._platformLocation.hash;
            return o && r ? `${i}${o}` : i
        }
        pushState(r, i, o, s) {
            let a = this.prepareExternalUrl(o + pi(s));
            this._platformLocation.pushState(r, i, a)
        }
        replaceState(r, i, o, s) {
            let a = this.prepareExternalUrl(o + pi(s));
            this._platformLocation.replaceState(r, i, a)
        }
        forward() {
            this._platformLocation.forward()
        }
        back() {
            this._platformLocation.back()
        }
        getState() {
            return this._platformLocation.getState()
        }
        historyGo(r=0) {
            this._platformLocation.historyGo?.(r)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Eg),ve(xb, 8))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , wb = (()=>{
    let e = class e extends Oo {
        constructor(r, i) {
            super(),
            this._platformLocation = r,
            this._baseHref = "",
            this._removeListenerFns = [],
            i != null && (this._baseHref = i)
        }
        ngOnDestroy() {
            for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()()
        }
        onPopState(r) {
            this._removeListenerFns.push(this._platformLocation.onPopState(r), this._platformLocation.onHashChange(r))
        }
        getBaseHref() {
            return this._baseHref
        }
        path(r=!1) {
            let i = this._platformLocation.hash ?? "#";
            return i.length > 0 ? i.substring(1) : i
        }
        prepareExternalUrl(r) {
            let i = Cg(this._baseHref, r);
            return i.length > 0 ? "#" + i : i
        }
        pushState(r, i, o, s) {
            let a = this.prepareExternalUrl(o + pi(s));
            a.length == 0 && (a = this._platformLocation.pathname),
            this._platformLocation.pushState(r, i, a)
        }
        replaceState(r, i, o, s) {
            let a = this.prepareExternalUrl(o + pi(s));
            a.length == 0 && (a = this._platformLocation.pathname),
            this._platformLocation.replaceState(r, i, a)
        }
        forward() {
            this._platformLocation.forward()
        }
        back() {
            this._platformLocation.back()
        }
        getState() {
            return this._platformLocation.getState()
        }
        historyGo(r=0) {
            this._platformLocation.historyGo?.(r)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Eg),ve(xb, 8))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , $s = (()=>{
    let e = class e {
        constructor(r) {
            this._subject = new xn,
            this._urlChangeListeners = [],
            this._urlChangeSubscription = null,
            this._locationStrategy = r;
            let i = this._locationStrategy.getBaseHref();
            this._basePath = iB(fb(db(i))),
            this._locationStrategy.onPopState(o=>{
                this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: o.state,
                    type: o.type
                })
            }
            )
        }
        ngOnDestroy() {
            this._urlChangeSubscription?.unsubscribe(),
            this._urlChangeListeners = []
        }
        path(r=!1) {
            return this.normalize(this._locationStrategy.path(r))
        }
        getState() {
            return this._locationStrategy.getState()
        }
        isCurrentPathEqualTo(r, i="") {
            return this.path() == this.normalize(r + pi(i))
        }
        normalize(r) {
            return e.stripTrailingSlash(rB(this._basePath, db(r)))
        }
        prepareExternalUrl(r) {
            return r && r[0] !== "/" && (r = "/" + r),
            this._locationStrategy.prepareExternalUrl(r)
        }
        go(r, i="", o=null) {
            this._locationStrategy.pushState(o, "", r, i),
            this._notifyUrlChangeListeners(this.prepareExternalUrl(r + pi(i)), o)
        }
        replaceState(r, i="", o=null) {
            this._locationStrategy.replaceState(o, "", r, i),
            this._notifyUrlChangeListeners(this.prepareExternalUrl(r + pi(i)), o)
        }
        forward() {
            this._locationStrategy.forward()
        }
        back() {
            this._locationStrategy.back()
        }
        historyGo(r=0) {
            this._locationStrategy.historyGo?.(r)
        }
        onUrlChange(r) {
            return this._urlChangeListeners.push(r),
            this._urlChangeSubscription ??= this.subscribe(i=>{
                this._notifyUrlChangeListeners(i.url, i.state)
            }
            ),
            ()=>{
                let i = this._urlChangeListeners.indexOf(r);
                this._urlChangeListeners.splice(i, 1),
                this._urlChangeListeners.length === 0 && (this._urlChangeSubscription?.unsubscribe(),
                this._urlChangeSubscription = null)
            }
        }
        _notifyUrlChangeListeners(r="", i) {
            this._urlChangeListeners.forEach(o=>o(r, i))
        }
        subscribe(r, i, o) {
            return this._subject.subscribe({
                next: r,
                error: i,
                complete: o
            })
        }
    }
    ;
    e.normalizeQueryParams = pi,
    e.joinWithSlash = Cg,
    e.stripTrailingSlash = fb,
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Oo))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>nB(),
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function nB() {
    return new $s(ve(Oo))
}
function rB(t, e) {
    if (!t || !e.startsWith(t))
        return e;
    let n = e.substring(t.length);
    return n === "" || ["/", ";", "?", "#"].includes(n[0]) ? n : e
}
function db(t) {
    return t.replace(/\/index.html$/, "")
}
function iB(t) {
    if (new RegExp("^(https?:)?//").test(t)) {
        let[,n] = t.split(/\/\/[^\/]+/);
        return n
    }
    return t
}
function jl(t, e) {
    e = encodeURIComponent(e);
    for (let n of t.split(";")) {
        let r = n.indexOf("=")
          , [i,o] = r == -1 ? [n, ""] : [n.slice(0, r), n.slice(r + 1)];
        if (i.trim() === e)
            return decodeURIComponent(o)
    }
    return null
}
var mg = class {
    constructor(e, n, r, i) {
        this.$implicit = e,
        this.ngForOf = n,
        this.index = r,
        this.count = i
    }
    get first() {
        return this.index === 0
    }
    get last() {
        return this.index === this.count - 1
    }
    get even() {
        return this.index % 2 === 0
    }
    get odd() {
        return !this.even
    }
}
  , bb = (()=>{
    let e = class e {
        set ngForOf(r) {
            this._ngForOf = r,
            this._ngForOfDirty = !0
        }
        set ngForTrackBy(r) {
            this._trackByFn = r
        }
        get ngForTrackBy() {
            return this._trackByFn
        }
        constructor(r, i, o) {
            this._viewContainer = r,
            this._template = i,
            this._differs = o,
            this._ngForOf = null,
            this._ngForOfDirty = !0,
            this._differ = null
        }
        set ngForTemplate(r) {
            r && (this._template = r)
        }
        ngDoCheck() {
            if (this._ngForOfDirty) {
                this._ngForOfDirty = !1;
                let r = this._ngForOf;
                if (!this._differ && r)
                    if (0)
                        try {} catch {}
                    else
                        this._differ = this._differs.find(r).create(this.ngForTrackBy)
            }
            if (this._differ) {
                let r = this._differ.diff(this._ngForOf);
                r && this._applyChanges(r)
            }
        }
        _applyChanges(r) {
            let i = this._viewContainer;
            r.forEachOperation((o,s,a)=>{
                if (o.previousIndex == null)
                    i.createEmbeddedView(this._template, new mg(o.item,this._ngForOf,-1,-1), a === null ? void 0 : a);
                else if (a == null)
                    i.remove(s === null ? void 0 : s);
                else if (s !== null) {
                    let c = i.get(s);
                    i.move(c, a),
                    hb(c, o)
                }
            }
            );
            for (let o = 0, s = i.length; o < s; o++) {
                let c = i.get(o).context;
                c.index = o,
                c.count = s,
                c.ngForOf = this._ngForOf
            }
            r.forEachIdentityChange(o=>{
                let s = i.get(o.currentIndex);
                hb(s, o)
            }
            )
        }
        static ngTemplateContextGuard(r, i) {
            return !0
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(Qn(Os),Qn(Sl),Qn(gg))
    }
    ,
    e.\u0275dir = Fs({
        type: e,
        selectors: [["", "ngFor", "", "ngForOf", ""]],
        inputs: {
            ngForOf: "ngForOf",
            ngForTrackBy: "ngForTrackBy",
            ngForTemplate: "ngForTemplate"
        },
        standalone: !0
    });
    let t = e;
    return t
}
)();
function hb(t, e) {
    t.context.$implicit = e.item
}
var Eb = (()=>{
    let e = class e {
        constructor(r, i) {
            this._viewContainer = r,
            this._context = new yg,
            this._thenTemplateRef = null,
            this._elseTemplateRef = null,
            this._thenViewRef = null,
            this._elseViewRef = null,
            this._thenTemplateRef = i
        }
        set ngIf(r) {
            this._context.$implicit = this._context.ngIf = r,
            this._updateView()
        }
        set ngIfThen(r) {
            pb("ngIfThen", r),
            this._thenTemplateRef = r,
            this._thenViewRef = null,
            this._updateView()
        }
        set ngIfElse(r) {
            pb("ngIfElse", r),
            this._elseTemplateRef = r,
            this._elseViewRef = null,
            this._updateView()
        }
        _updateView() {
            this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(),
            this._elseViewRef = null,
            this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(),
            this._thenViewRef = null,
            this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
        }
        static ngTemplateContextGuard(r, i) {
            return !0
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(Qn(Os),Qn(Sl))
    }
    ,
    e.\u0275dir = Fs({
        type: e,
        selectors: [["", "ngIf", ""]],
        inputs: {
            ngIf: "ngIf",
            ngIfThen: "ngIfThen",
            ngIfElse: "ngIfElse"
        },
        standalone: !0
    });
    let t = e;
    return t
}
)()
  , yg = class {
    constructor() {
        this.$implicit = null,
        this.ngIf = null
    }
}
;
function pb(t, e) {
    if (!!!(!e || e.createEmbeddedView))
        throw new Error(`${t} must be a TemplateRef, but received '${$n(e)}'.`)
}
var Cb = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({});
    let t = e;
    return t
}
)()
  , Ig = "browser"
  , oB = "server";
function sB(t) {
    return t === Ig
}
function $l(t) {
    return t === oB
}
var Db = (()=>{
    let e = class e {
    }
    ;
    e.\u0275prov = he({
        token: e,
        providedIn: "root",
        factory: ()=>sB(ie(zr)) ? new vg(ie(Dn),window) : new xg
    });
    let t = e;
    return t
}
)()
  , vg = class {
    constructor(e, n) {
        this.document = e,
        this.window = n,
        this.offset = ()=>[0, 0]
    }
    setOffset(e) {
        Array.isArray(e) ? this.offset = ()=>e : this.offset = e
    }
    getScrollPosition() {
        return [this.window.scrollX, this.window.scrollY]
    }
    scrollToPosition(e) {
        this.window.scrollTo(e[0], e[1])
    }
    scrollToAnchor(e) {
        let n = aB(this.document, e);
        n && (this.scrollToElement(n),
        n.focus())
    }
    setHistoryScrollRestoration(e) {
        this.window.history.scrollRestoration = e
    }
    scrollToElement(e) {
        let n = e.getBoundingClientRect()
          , r = n.left + this.window.pageXOffset
          , i = n.top + this.window.pageYOffset
          , o = this.offset();
        this.window.scrollTo(r - o[0], i - o[1])
    }
}
;
function aB(t, e) {
    let n = t.getElementById(e) || t.getElementsByName(e)[0];
    if (n)
        return n;
    if (typeof t.createTreeWalker == "function" && t.body && typeof t.body.attachShadow == "function") {
        let r = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT)
          , i = r.currentNode;
        for (; i; ) {
            let o = i.shadowRoot;
            if (o) {
                let s = o.getElementById(e) || o.querySelector(`[name="${e}"]`);
                if (s)
                    return s
            }
            i = r.nextNode()
        }
    }
    return null
}
var xg = class {
    setOffset(e) {}
    getScrollPosition() {
        return [0, 0]
    }
    scrollToPosition(e) {}
    scrollToAnchor(e) {}
    setHistoryScrollRestoration(e) {}
}
  , js = class {
}
;
var rc = class {
}
  , zl = class {
}
  , Wr = class t {
    constructor(e) {
        this.normalizedNames = new Map,
        this.lazyUpdate = null,
        e ? typeof e == "string" ? this.lazyInit = ()=>{
            this.headers = new Map,
            e.split(`
`).forEach(n=>{
                let r = n.indexOf(":");
                if (r > 0) {
                    let i = n.slice(0, r)
                      , o = i.toLowerCase()
                      , s = n.slice(r + 1).trim();
                    this.maybeSetNormalizedName(i, o),
                    this.headers.has(o) ? this.headers.get(o).push(s) : this.headers.set(o, [s])
                }
            }
            )
        }
        : typeof Headers < "u" && e instanceof Headers ? (this.headers = new Map,
        e.forEach((n,r)=>{
            this.setHeaderEntries(r, n)
        }
        )) : this.lazyInit = ()=>{
            this.headers = new Map,
            Object.entries(e).forEach(([n,r])=>{
                this.setHeaderEntries(n, r)
            }
            )
        }
        : this.headers = new Map
    }
    has(e) {
        return this.init(),
        this.headers.has(e.toLowerCase())
    }
    get(e) {
        this.init();
        let n = this.headers.get(e.toLowerCase());
        return n && n.length > 0 ? n[0] : null
    }
    keys() {
        return this.init(),
        Array.from(this.normalizedNames.values())
    }
    getAll(e) {
        return this.init(),
        this.headers.get(e.toLowerCase()) || null
    }
    append(e, n) {
        return this.clone({
            name: e,
            value: n,
            op: "a"
        })
    }
    set(e, n) {
        return this.clone({
            name: e,
            value: n,
            op: "s"
        })
    }
    delete(e, n) {
        return this.clone({
            name: e,
            value: n,
            op: "d"
        })
    }
    maybeSetNormalizedName(e, n) {
        this.normalizedNames.has(n) || this.normalizedNames.set(n, e)
    }
    init() {
        this.lazyInit && (this.lazyInit instanceof t ? this.copyFrom(this.lazyInit) : this.lazyInit(),
        this.lazyInit = null,
        this.lazyUpdate && (this.lazyUpdate.forEach(e=>this.applyUpdate(e)),
        this.lazyUpdate = null))
    }
    copyFrom(e) {
        e.init(),
        Array.from(e.headers.keys()).forEach(n=>{
            this.headers.set(n, e.headers.get(n)),
            this.normalizedNames.set(n, e.normalizedNames.get(n))
        }
        )
    }
    clone(e) {
        let n = new t;
        return n.lazyInit = this.lazyInit && this.lazyInit instanceof t ? this.lazyInit : this,
        n.lazyUpdate = (this.lazyUpdate || []).concat([e]),
        n
    }
    applyUpdate(e) {
        let n = e.name.toLowerCase();
        switch (e.op) {
        case "a":
        case "s":
            let r = e.value;
            if (typeof r == "string" && (r = [r]),
            r.length === 0)
                return;
            this.maybeSetNormalizedName(e.name, n);
            let i = (e.op === "a" ? this.headers.get(n) : void 0) || [];
            i.push(...r),
            this.headers.set(n, i);
            break;
        case "d":
            let o = e.value;
            if (!o)
                this.headers.delete(n),
                this.normalizedNames.delete(n);
            else {
                let s = this.headers.get(n);
                if (!s)
                    return;
                s = s.filter(a=>o.indexOf(a) === -1),
                s.length === 0 ? (this.headers.delete(n),
                this.normalizedNames.delete(n)) : this.headers.set(n, s)
            }
            break
        }
    }
    setHeaderEntries(e, n) {
        let r = (Array.isArray(n) ? n : [n]).map(o=>o.toString())
          , i = e.toLowerCase();
        this.headers.set(i, r),
        this.maybeSetNormalizedName(e, i)
    }
    forEach(e) {
        this.init(),
        Array.from(this.normalizedNames.keys()).forEach(n=>e(this.normalizedNames.get(n), this.headers.get(n)))
    }
}
;
var _g = class {
    encodeKey(e) {
        return Ab(e)
    }
    encodeValue(e) {
        return Ab(e)
    }
    decodeKey(e) {
        return decodeURIComponent(e)
    }
    decodeValue(e) {
        return decodeURIComponent(e)
    }
}
;
function lB(t, e) {
    let n = new Map;
    return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(i=>{
        let o = i.indexOf("=")
          , [s,a] = o == -1 ? [e.decodeKey(i), ""] : [e.decodeKey(i.slice(0, o)), e.decodeValue(i.slice(o + 1))]
          , c = n.get(s) || [];
        c.push(a),
        n.set(s, c)
    }
    ),
    n
}
var fB = /%(\d[a-f0-9])/gi
  , dB = {
    40: "@",
    "3A": ":",
    24: "$",
    "2C": ",",
    "3B": ";",
    "3D": "=",
    "3F": "?",
    "2F": "/"
};
function Ab(t) {
    return encodeURIComponent(t).replace(fB, (e,n)=>dB[n] ?? e)
}
function Hl(t) {
    return `${t}`
}
var zi = class t {
    constructor(e={}) {
        if (this.updates = null,
        this.cloneFrom = null,
        this.encoder = e.encoder || new _g,
        e.fromString) {
            if (e.fromObject)
                throw new Error("Cannot specify both fromString and fromObject.");
            this.map = lB(e.fromString, this.encoder)
        } else
            e.fromObject ? (this.map = new Map,
            Object.keys(e.fromObject).forEach(n=>{
                let r = e.fromObject[n]
                  , i = Array.isArray(r) ? r.map(Hl) : [Hl(r)];
                this.map.set(n, i)
            }
            )) : this.map = null
    }
    has(e) {
        return this.init(),
        this.map.has(e)
    }
    get(e) {
        this.init();
        let n = this.map.get(e);
        return n ? n[0] : null
    }
    getAll(e) {
        return this.init(),
        this.map.get(e) || null
    }
    keys() {
        return this.init(),
        Array.from(this.map.keys())
    }
    append(e, n) {
        return this.clone({
            param: e,
            value: n,
            op: "a"
        })
    }
    appendAll(e) {
        let n = [];
        return Object.keys(e).forEach(r=>{
            let i = e[r];
            Array.isArray(i) ? i.forEach(o=>{
                n.push({
                    param: r,
                    value: o,
                    op: "a"
                })
            }
            ) : n.push({
                param: r,
                value: i,
                op: "a"
            })
        }
        ),
        this.clone(n)
    }
    set(e, n) {
        return this.clone({
            param: e,
            value: n,
            op: "s"
        })
    }
    delete(e, n) {
        return this.clone({
            param: e,
            value: n,
            op: "d"
        })
    }
    toString() {
        return this.init(),
        this.keys().map(e=>{
            let n = this.encoder.encodeKey(e);
            return this.map.get(e).map(r=>n + "=" + this.encoder.encodeValue(r)).join("&")
        }
        ).filter(e=>e !== "").join("&")
    }
    clone(e) {
        let n = new t({
            encoder: this.encoder
        });
        return n.cloneFrom = this.cloneFrom || this,
        n.updates = (this.updates || []).concat(e),
        n
    }
    init() {
        this.map === null && (this.map = new Map),
        this.cloneFrom !== null && (this.cloneFrom.init(),
        this.cloneFrom.keys().forEach(e=>this.map.set(e, this.cloneFrom.map.get(e))),
        this.updates.forEach(e=>{
            switch (e.op) {
            case "a":
            case "s":
                let n = (e.op === "a" ? this.map.get(e.param) : void 0) || [];
                n.push(Hl(e.value)),
                this.map.set(e.param, n);
                break;
            case "d":
                if (e.value !== void 0) {
                    let r = this.map.get(e.param) || []
                      , i = r.indexOf(Hl(e.value));
                    i !== -1 && r.splice(i, 1),
                    r.length > 0 ? this.map.set(e.param, r) : this.map.delete(e.param)
                } else {
                    this.map.delete(e.param);
                    break
                }
            }
        }
        ),
        this.cloneFrom = this.updates = null)
    }
}
;
var Sg = class {
    constructor() {
        this.map = new Map
    }
    set(e, n) {
        return this.map.set(e, n),
        this
    }
    get(e) {
        return this.map.has(e) || this.map.set(e, e.defaultValue()),
        this.map.get(e)
    }
    delete(e) {
        return this.map.delete(e),
        this
    }
    has(e) {
        return this.map.has(e)
    }
    keys() {
        return this.map.keys()
    }
}
;
function hB(t) {
    switch (t) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
        return !1;
    default:
        return !0
    }
}
function _b(t) {
    return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer
}
function Sb(t) {
    return typeof Blob < "u" && t instanceof Blob
}
function Mb(t) {
    return typeof FormData < "u" && t instanceof FormData
}
function pB(t) {
    return typeof URLSearchParams < "u" && t instanceof URLSearchParams
}
var nc = class t {
    constructor(e, n, r, i) {
        this.url = n,
        this.body = null,
        this.reportProgress = !1,
        this.withCredentials = !1,
        this.responseType = "json",
        this.method = e.toUpperCase();
        let o;
        if (hB(this.method) || i ? (this.body = r !== void 0 ? r : null,
        o = i) : o = r,
        o && (this.reportProgress = !!o.reportProgress,
        this.withCredentials = !!o.withCredentials,
        o.responseType && (this.responseType = o.responseType),
        o.headers && (this.headers = o.headers),
        o.context && (this.context = o.context),
        o.params && (this.params = o.params),
        this.transferCache = o.transferCache),
        this.headers ??= new Wr,
        this.context ??= new Sg,
        !this.params)
            this.params = new zi,
            this.urlWithParams = n;
        else {
            let s = this.params.toString();
            if (s.length === 0)
                this.urlWithParams = n;
            else {
                let a = n.indexOf("?")
                  , c = a === -1 ? "?" : a < n.length - 1 ? "&" : "";
                this.urlWithParams = n + c + s
            }
        }
    }
    serializeBody() {
        return this.body === null ? null : typeof this.body == "string" || _b(this.body) || Sb(this.body) || Mb(this.body) || pB(this.body) ? this.body : this.body instanceof zi ? this.body.toString() : typeof this.body == "object" || typeof this.body == "boolean" || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
    }
    detectContentTypeHeader() {
        return this.body === null || Mb(this.body) ? null : Sb(this.body) ? this.body.type || null : _b(this.body) ? null : typeof this.body == "string" ? "text/plain" : this.body instanceof zi ? "application/x-www-form-urlencoded;charset=UTF-8" : typeof this.body == "object" || typeof this.body == "number" || typeof this.body == "boolean" ? "application/json" : null
    }
    clone(e={}) {
        let n = e.method || this.method
          , r = e.url || this.url
          , i = e.responseType || this.responseType
          , o = e.transferCache ?? this.transferCache
          , s = e.body !== void 0 ? e.body : this.body
          , a = e.withCredentials ?? this.withCredentials
          , c = e.reportProgress ?? this.reportProgress
          , u = e.headers || this.headers
          , l = e.params || this.params
          , d = e.context ?? this.context;
        return e.setHeaders !== void 0 && (u = Object.keys(e.setHeaders).reduce((y,v)=>y.set(v, e.setHeaders[v]), u)),
        e.setParams && (l = Object.keys(e.setParams).reduce((y,v)=>y.set(v, e.setParams[v]), l)),
        new t(n,r,s,{
            params: l,
            headers: u,
            context: d,
            reportProgress: c,
            responseType: i,
            withCredentials: a,
            transferCache: o
        })
    }
}
  , Hs = function(t) {
    return t[t.Sent = 0] = "Sent",
    t[t.UploadProgress = 1] = "UploadProgress",
    t[t.ResponseHeader = 2] = "ResponseHeader",
    t[t.DownloadProgress = 3] = "DownloadProgress",
    t[t.Response = 4] = "Response",
    t[t.User = 5] = "User",
    t
}(Hs || {})
  , ic = class {
    constructor(e, n=Gl.Ok, r="OK") {
        this.headers = e.headers || new Wr,
        this.status = e.status !== void 0 ? e.status : n,
        this.statusText = e.statusText || r,
        this.url = e.url || null,
        this.ok = this.status >= 200 && this.status < 300
    }
}
  , Mg = class t extends ic {
    constructor(e={}) {
        super(e),
        this.type = Hs.ResponseHeader
    }
    clone(e={}) {
        return new t({
            headers: e.headers || this.headers,
            status: e.status !== void 0 ? e.status : this.status,
            statusText: e.statusText || this.statusText,
            url: e.url || this.url || void 0
        })
    }
}
  , ql = class t extends ic {
    constructor(e={}) {
        super(e),
        this.type = Hs.Response,
        this.body = e.body !== void 0 ? e.body : null
    }
    clone(e={}) {
        return new t({
            body: e.body !== void 0 ? e.body : this.body,
            headers: e.headers || this.headers,
            status: e.status !== void 0 ? e.status : this.status,
            statusText: e.statusText || this.statusText,
            url: e.url || this.url || void 0
        })
    }
}
  , Wl = class extends ic {
    constructor(e) {
        super(e, 0, "Unknown Error"),
        this.name = "HttpErrorResponse",
        this.ok = !1,
        this.status >= 200 && this.status < 300 ? this.message = `Http failure during parsing for ${e.url || "(unknown url)"}` : this.message = `Http failure response for ${e.url || "(unknown url)"}: ${e.status} ${e.statusText}`,
        this.error = e.error || null
    }
}
  , Gl = function(t) {
    return t[t.Continue = 100] = "Continue",
    t[t.SwitchingProtocols = 101] = "SwitchingProtocols",
    t[t.Processing = 102] = "Processing",
    t[t.EarlyHints = 103] = "EarlyHints",
    t[t.Ok = 200] = "Ok",
    t[t.Created = 201] = "Created",
    t[t.Accepted = 202] = "Accepted",
    t[t.NonAuthoritativeInformation = 203] = "NonAuthoritativeInformation",
    t[t.NoContent = 204] = "NoContent",
    t[t.ResetContent = 205] = "ResetContent",
    t[t.PartialContent = 206] = "PartialContent",
    t[t.MultiStatus = 207] = "MultiStatus",
    t[t.AlreadyReported = 208] = "AlreadyReported",
    t[t.ImUsed = 226] = "ImUsed",
    t[t.MultipleChoices = 300] = "MultipleChoices",
    t[t.MovedPermanently = 301] = "MovedPermanently",
    t[t.Found = 302] = "Found",
    t[t.SeeOther = 303] = "SeeOther",
    t[t.NotModified = 304] = "NotModified",
    t[t.UseProxy = 305] = "UseProxy",
    t[t.Unused = 306] = "Unused",
    t[t.TemporaryRedirect = 307] = "TemporaryRedirect",
    t[t.PermanentRedirect = 308] = "PermanentRedirect",
    t[t.BadRequest = 400] = "BadRequest",
    t[t.Unauthorized = 401] = "Unauthorized",
    t[t.PaymentRequired = 402] = "PaymentRequired",
    t[t.Forbidden = 403] = "Forbidden",
    t[t.NotFound = 404] = "NotFound",
    t[t.MethodNotAllowed = 405] = "MethodNotAllowed",
    t[t.NotAcceptable = 406] = "NotAcceptable",
    t[t.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired",
    t[t.RequestTimeout = 408] = "RequestTimeout",
    t[t.Conflict = 409] = "Conflict",
    t[t.Gone = 410] = "Gone",
    t[t.LengthRequired = 411] = "LengthRequired",
    t[t.PreconditionFailed = 412] = "PreconditionFailed",
    t[t.PayloadTooLarge = 413] = "PayloadTooLarge",
    t[t.UriTooLong = 414] = "UriTooLong",
    t[t.UnsupportedMediaType = 415] = "UnsupportedMediaType",
    t[t.RangeNotSatisfiable = 416] = "RangeNotSatisfiable",
    t[t.ExpectationFailed = 417] = "ExpectationFailed",
    t[t.ImATeapot = 418] = "ImATeapot",
    t[t.MisdirectedRequest = 421] = "MisdirectedRequest",
    t[t.UnprocessableEntity = 422] = "UnprocessableEntity",
    t[t.Locked = 423] = "Locked",
    t[t.FailedDependency = 424] = "FailedDependency",
    t[t.TooEarly = 425] = "TooEarly",
    t[t.UpgradeRequired = 426] = "UpgradeRequired",
    t[t.PreconditionRequired = 428] = "PreconditionRequired",
    t[t.TooManyRequests = 429] = "TooManyRequests",
    t[t.RequestHeaderFieldsTooLarge = 431] = "RequestHeaderFieldsTooLarge",
    t[t.UnavailableForLegalReasons = 451] = "UnavailableForLegalReasons",
    t[t.InternalServerError = 500] = "InternalServerError",
    t[t.NotImplemented = 501] = "NotImplemented",
    t[t.BadGateway = 502] = "BadGateway",
    t[t.ServiceUnavailable = 503] = "ServiceUnavailable",
    t[t.GatewayTimeout = 504] = "GatewayTimeout",
    t[t.HttpVersionNotSupported = 505] = "HttpVersionNotSupported",
    t[t.VariantAlsoNegotiates = 506] = "VariantAlsoNegotiates",
    t[t.InsufficientStorage = 507] = "InsufficientStorage",
    t[t.LoopDetected = 508] = "LoopDetected",
    t[t.NotExtended = 510] = "NotExtended",
    t[t.NetworkAuthenticationRequired = 511] = "NetworkAuthenticationRequired",
    t
}(Gl || {});
function Ag(t, e) {
    return {
        body: e,
        headers: t.headers,
        context: t.context,
        observe: t.observe,
        params: t.params,
        reportProgress: t.reportProgress,
        responseType: t.responseType,
        withCredentials: t.withCredentials,
        transferCache: t.transferCache
    }
}
var kg = (()=>{
    let e = class e {
        constructor(r) {
            this.handler = r
        }
        request(r, i, o={}) {
            let s;
            if (r instanceof nc)
                s = r;
            else {
                let u;
                o.headers instanceof Wr ? u = o.headers : u = new Wr(o.headers);
                let l;
                o.params && (o.params instanceof zi ? l = o.params : l = new zi({
                    fromObject: o.params
                })),
                s = new nc(r,i,o.body !== void 0 ? o.body : null,{
                    headers: u,
                    context: o.context,
                    params: l,
                    reportProgress: o.reportProgress,
                    responseType: o.responseType || "json",
                    withCredentials: o.withCredentials,
                    transferCache: o.transferCache
                })
            }
            let a = Ie(s).pipe(oi(u=>this.handler.handle(u)));
            if (r instanceof nc || o.observe === "events")
                return a;
            let c = a.pipe(Vn(u=>u instanceof ql));
            switch (o.observe || "body") {
            case "body":
                switch (s.responseType) {
                case "arraybuffer":
                    return c.pipe(Ue(u=>{
                        if (u.body !== null && !(u.body instanceof ArrayBuffer))
                            throw new Error("Response is not an ArrayBuffer.");
                        return u.body
                    }
                    ));
                case "blob":
                    return c.pipe(Ue(u=>{
                        if (u.body !== null && !(u.body instanceof Blob))
                            throw new Error("Response is not a Blob.");
                        return u.body
                    }
                    ));
                case "text":
                    return c.pipe(Ue(u=>{
                        if (u.body !== null && typeof u.body != "string")
                            throw new Error("Response is not a string.");
                        return u.body
                    }
                    ));
                case "json":
                default:
                    return c.pipe(Ue(u=>u.body))
                }
            case "response":
                return c;
            default:
                throw new Error(`Unreachable: unhandled observe type ${o.observe}}`)
            }
        }
        delete(r, i={}) {
            return this.request("DELETE", r, i)
        }
        get(r, i={}) {
            return this.request("GET", r, i)
        }
        head(r, i={}) {
            return this.request("HEAD", r, i)
        }
        jsonp(r, i) {
            return this.request("JSONP", r, {
                params: new zi().append(i, "JSONP_CALLBACK"),
                observe: "body",
                responseType: "json"
            })
        }
        options(r, i={}) {
            return this.request("OPTIONS", r, i)
        }
        patch(r, i, o={}) {
            return this.request("PATCH", r, Ag(o, i))
        }
        post(r, i, o={}) {
            return this.request("POST", r, Ag(o, i))
        }
        put(r, i, o={}) {
            return this.request("PUT", r, Ag(o, i))
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(rc))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)();
function Rb(t, e) {
    return e(t)
}
function gB(t, e) {
    return (n,r)=>e.intercept(n, {
        handle: i=>t(i, r)
    })
}
function mB(t, e, n) {
    return (r,i)=>Ar(n, ()=>e(r, o=>t(o, i)))
}
var yB = new be("")
  , Tg = new be("")
  , vB = new be("")
  , xB = new be("");
function wB() {
    let t = null;
    return (e,n)=>{
        t === null && (t = (ie(yB, {
            optional: !0
        }) ?? []).reduceRight(gB, Rb));
        let r = ie(Ro)
          , i = r.add();
        return t(e, n).pipe(Pi(()=>r.remove(i)))
    }
}
var kb = (()=>{
    let e = class e extends rc {
        constructor(r, i) {
            super(),
            this.backend = r,
            this.injector = i,
            this.chain = null,
            this.pendingTasks = ie(Ro);
            let o = ie(xB, {
                optional: !0
            });
            this.backend = o ?? r
        }
        handle(r) {
            if (this.chain === null) {
                let o = Array.from(new Set([...this.injector.get(Tg), ...this.injector.get(vB, [])]));
                this.chain = o.reduceRight((s,a)=>mB(s, a, this.injector), Rb)
            }
            let i = this.pendingTasks.add();
            return this.chain(r, o=>this.backend.handle(o)).pipe(Pi(()=>this.pendingTasks.remove(i)))
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(zl),ve(wn))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)();
var bB = /^\)\]\}',?\n/;
function EB(t) {
    return "responseURL"in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null
}
var Tb = (()=>{
    let e = class e {
        constructor(r) {
            this.xhrFactory = r
        }
        handle(r) {
            if (r.method === "JSONP")
                throw new we(-2800,!1);
            let i = this.xhrFactory;
            return (i.\u0275loadImpl ? Mt(i.\u0275loadImpl()) : Ie(null)).pipe(jn(()=>new ct(s=>{
                let a = i.build();
                if (a.open(r.method, r.urlWithParams),
                r.withCredentials && (a.withCredentials = !0),
                r.headers.forEach((S,w)=>a.setRequestHeader(S, w.join(","))),
                r.headers.has("Accept") || a.setRequestHeader("Accept", "application/json, text/plain, */*"),
                !r.headers.has("Content-Type")) {
                    let S = r.detectContentTypeHeader();
                    S !== null && a.setRequestHeader("Content-Type", S)
                }
                if (r.responseType) {
                    let S = r.responseType.toLowerCase();
                    a.responseType = S !== "json" ? S : "text"
                }
                let c = r.serializeBody()
                  , u = null
                  , l = ()=>{
                    if (u !== null)
                        return u;
                    let S = a.statusText || "OK"
                      , w = new Wr(a.getAllResponseHeaders())
                      , M = EB(a) || r.url;
                    return u = new Mg({
                        headers: w,
                        status: a.status,
                        statusText: S,
                        url: M
                    }),
                    u
                }
                  , d = ()=>{
                    let {headers: S, status: w, statusText: M, url: F} = l()
                      , N = null;
                    w !== Gl.NoContent && (N = typeof a.response > "u" ? a.responseText : a.response),
                    w === 0 && (w = N ? Gl.Ok : 0);
                    let P = w >= 200 && w < 300;
                    if (r.responseType === "json" && typeof N == "string") {
                        let O = N;
                        N = N.replace(bB, "");
                        try {
                            N = N !== "" ? JSON.parse(N) : null
                        } catch (z) {
                            N = O,
                            P && (P = !1,
                            N = {
                                error: z,
                                text: N
                            })
                        }
                    }
                    P ? (s.next(new ql({
                        body: N,
                        headers: S,
                        status: w,
                        statusText: M,
                        url: F || void 0
                    })),
                    s.complete()) : s.error(new Wl({
                        error: N,
                        headers: S,
                        status: w,
                        statusText: M,
                        url: F || void 0
                    }))
                }
                  , y = S=>{
                    let {url: w} = l()
                      , M = new Wl({
                        error: S,
                        status: a.status || 0,
                        statusText: a.statusText || "Unknown Error",
                        url: w || void 0
                    });
                    s.error(M)
                }
                  , v = !1
                  , E = S=>{
                    v || (s.next(l()),
                    v = !0);
                    let w = {
                        type: Hs.DownloadProgress,
                        loaded: S.loaded
                    };
                    S.lengthComputable && (w.total = S.total),
                    r.responseType === "text" && a.responseText && (w.partialText = a.responseText),
                    s.next(w)
                }
                  , D = S=>{
                    let w = {
                        type: Hs.UploadProgress,
                        loaded: S.loaded
                    };
                    S.lengthComputable && (w.total = S.total),
                    s.next(w)
                }
                ;
                return a.addEventListener("load", d),
                a.addEventListener("error", y),
                a.addEventListener("timeout", y),
                a.addEventListener("abort", y),
                r.reportProgress && (a.addEventListener("progress", E),
                c !== null && a.upload && a.upload.addEventListener("progress", D)),
                a.send(c),
                s.next({
                    type: Hs.Sent
                }),
                ()=>{
                    a.removeEventListener("error", y),
                    a.removeEventListener("abort", y),
                    a.removeEventListener("load", d),
                    a.removeEventListener("timeout", y),
                    r.reportProgress && (a.removeEventListener("progress", E),
                    c !== null && a.upload && a.upload.removeEventListener("progress", D)),
                    a.readyState !== a.DONE && a.abort()
                }
            }
            )))
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(js))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , Fb = new be("")
  , CB = "XSRF-TOKEN"
  , DB = new be("",{
    providedIn: "root",
    factory: ()=>CB
})
  , IB = "X-XSRF-TOKEN"
  , AB = new be("",{
    providedIn: "root",
    factory: ()=>IB
})
  , Kl = class {
}
  , _B = (()=>{
    let e = class e {
        constructor(r, i, o) {
            this.doc = r,
            this.platform = i,
            this.cookieName = o,
            this.lastCookieString = "",
            this.lastToken = null,
            this.parseCount = 0
        }
        getToken() {
            if (this.platform === "server")
                return null;
            let r = this.doc.cookie || "";
            return r !== this.lastCookieString && (this.parseCount++,
            this.lastToken = jl(r, this.cookieName),
            this.lastCookieString = r),
            this.lastToken
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Dn),ve(zr),ve(DB))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)();
function SB(t, e) {
    let n = t.url.toLowerCase();
    if (!ie(Fb) || t.method === "GET" || t.method === "HEAD" || n.startsWith("http://") || n.startsWith("https://"))
        return e(t);
    let r = ie(Kl).getToken()
      , i = ie(AB);
    return r != null && !t.headers.has(i) && (t = t.clone({
        headers: t.headers.set(i, r)
    })),
    e(t)
}
var Nb = function(t) {
    return t[t.Interceptors = 0] = "Interceptors",
    t[t.LegacyInterceptors = 1] = "LegacyInterceptors",
    t[t.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration",
    t[t.NoXsrfProtection = 3] = "NoXsrfProtection",
    t[t.JsonpSupport = 4] = "JsonpSupport",
    t[t.RequestsMadeViaParent = 5] = "RequestsMadeViaParent",
    t[t.Fetch = 6] = "Fetch",
    t
}(Nb || {});
function MB(t, e) {
    return {
        \u0275kind: t,
        \u0275providers: e
    }
}
function kB(...t) {
    let e = [kg, Tb, kb, {
        provide: rc,
        useExisting: kb
    }, {
        provide: zl,
        useExisting: Tb
    }, {
        provide: Tg,
        useValue: SB,
        multi: !0
    }, {
        provide: Fb,
        useValue: !0
    }, {
        provide: Kl,
        useClass: _B
    }];
    for (let n of t)
        e.push(...n.\u0275providers);
    return gl(e)
}
var Bb = new be("");
function TB() {
    return MB(Nb.LegacyInterceptors, [{
        provide: Bb,
        useFactory: wB
    }, {
        provide: Tg,
        useExisting: Bb,
        multi: !0
    }])
}
var Pb = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({
        providers: [kB(TB())]
    });
    let t = e;
    return t
}
)();
var Fg = class extends Vl {
    constructor() {
        super(...arguments),
        this.supportsDOMEvents = !0
    }
}
  , Ng = class t extends Fg {
    static makeCurrent() {
        yb(new t)
    }
    onAndCancel(e, n, r) {
        return e.addEventListener(n, r),
        ()=>{
            e.removeEventListener(n, r)
        }
    }
    dispatchEvent(e, n) {
        e.dispatchEvent(n)
    }
    remove(e) {
        e.parentNode && e.parentNode.removeChild(e)
    }
    createElement(e, n) {
        return n = n || this.getDefaultDocument(),
        n.createElement(e)
    }
    createHtmlDocument() {
        return document.implementation.createHTMLDocument("fakeTitle")
    }
    getDefaultDocument() {
        return document
    }
    isElementNode(e) {
        return e.nodeType === Node.ELEMENT_NODE
    }
    isShadowRoot(e) {
        return e instanceof DocumentFragment
    }
    getGlobalEventTarget(e, n) {
        return n === "window" ? window : n === "document" ? e : n === "body" ? e.body : null
    }
    getBaseHref(e) {
        let n = RB();
        return n == null ? null : FB(n)
    }
    resetBaseElement() {
        oc = null
    }
    getUserAgent() {
        return window.navigator.userAgent
    }
    getCookie(e) {
        return jl(document.cookie, e)
    }
}
  , oc = null;
function RB() {
    return oc = oc || document.querySelector("base"),
    oc ? oc.getAttribute("href") : null
}
function FB(t) {
    return new URL(t,document.baseURI).pathname
}
var Pg = class {
    addToWindow(e) {
        Xn.getAngularTestability = (r,i=!0)=>{
            let o = e.findTestabilityInTree(r, i);
            if (o == null)
                throw new we(5103,!1);
            return o
        }
        ,
        Xn.getAllAngularTestabilities = ()=>e.getAllTestabilities(),
        Xn.getAllAngularRootElements = ()=>e.getAllRootElements();
        let n = r=>{
            let i = Xn.getAllAngularTestabilities()
              , o = i.length
              , s = function() {
                o--,
                o == 0 && r()
            };
            i.forEach(a=>{
                a.whenStable(s)
            }
            )
        }
        ;
        Xn.frameworkStabilizers || (Xn.frameworkStabilizers = []),
        Xn.frameworkStabilizers.push(n)
    }
    findTestabilityInTree(e, n, r) {
        if (n == null)
            return null;
        let i = e.getTestability(n);
        return i ?? (r ? Po().isShadowRoot(n) ? this.findTestabilityInTree(e, n.host, !0) : this.findTestabilityInTree(e, n.parentElement, !0) : null)
    }
}
  , NB = (()=>{
    let e = class e {
        build() {
            return new XMLHttpRequest
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , Og = new be("")
  , Vb = (()=>{
    let e = class e {
        constructor(r, i) {
            this._zone = i,
            this._eventNameToPlugin = new Map,
            r.forEach(o=>{
                o.manager = this
            }
            ),
            this._plugins = r.slice().reverse()
        }
        addEventListener(r, i, o) {
            return this._findPluginFor(i).addEventListener(r, i, o)
        }
        getZone() {
            return this._zone
        }
        _findPluginFor(r) {
            let i = this._eventNameToPlugin.get(r);
            if (i)
                return i;
            if (i = this._plugins.find(s=>s.supports(r)),
            !i)
                throw new we(5101,!1);
            return this._eventNameToPlugin.set(r, i),
            i
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Og),ve(wt))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , Yl = class {
    constructor(e) {
        this._doc = e
    }
}
  , Bg = "ng-app-id"
  , jb = (()=>{
    let e = class e {
        constructor(r, i, o, s={}) {
            this.doc = r,
            this.appId = i,
            this.nonce = o,
            this.platformId = s,
            this.styleRef = new Map,
            this.hostNodes = new Set,
            this.styleNodesInDOM = this.collectServerRenderedStyles(),
            this.platformIsServer = $l(s),
            this.resetHostNodes()
        }
        addStyles(r) {
            for (let i of r)
                this.changeUsageCount(i, 1) === 1 && this.onStyleAdded(i)
        }
        removeStyles(r) {
            for (let i of r)
                this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i)
        }
        ngOnDestroy() {
            let r = this.styleNodesInDOM;
            r && (r.forEach(i=>i.remove()),
            r.clear());
            for (let i of this.getAllStyles())
                this.onStyleRemoved(i);
            this.resetHostNodes()
        }
        addHost(r) {
            this.hostNodes.add(r);
            for (let i of this.getAllStyles())
                this.addStyleToHost(r, i)
        }
        removeHost(r) {
            this.hostNodes.delete(r)
        }
        getAllStyles() {
            return this.styleRef.keys()
        }
        onStyleAdded(r) {
            for (let i of this.hostNodes)
                this.addStyleToHost(i, r)
        }
        onStyleRemoved(r) {
            let i = this.styleRef;
            i.get(r)?.elements?.forEach(o=>o.remove()),
            i.delete(r)
        }
        collectServerRenderedStyles() {
            let r = this.doc.head?.querySelectorAll(`style[${Bg}="${this.appId}"]`);
            if (r?.length) {
                let i = new Map;
                return r.forEach(o=>{
                    o.textContent != null && i.set(o.textContent, o)
                }
                ),
                i
            }
            return null
        }
        changeUsageCount(r, i) {
            let o = this.styleRef;
            if (o.has(r)) {
                let s = o.get(r);
                return s.usage += i,
                s.usage
            }
            return o.set(r, {
                usage: i,
                elements: []
            }),
            i
        }
        getStyleElement(r, i) {
            let o = this.styleNodesInDOM
              , s = o?.get(i);
            if (s?.parentNode === r)
                return o.delete(i),
                s.removeAttribute(Bg),
                s;
            {
                let a = this.doc.createElement("style");
                return this.nonce && a.setAttribute("nonce", this.nonce),
                a.textContent = i,
                this.platformIsServer && a.setAttribute(Bg, this.appId),
                r.appendChild(a),
                a
            }
        }
        addStyleToHost(r, i) {
            let o = this.getStyleElement(r, i)
              , s = this.styleRef
              , a = s.get(i)?.elements;
            a ? a.push(o) : s.set(i, {
                elements: [o],
                usage: 1
            })
        }
        resetHostNodes() {
            let r = this.hostNodes;
            r.clear(),
            r.add(this.doc.head)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Dn),ve(El),ve(Yp, 8),ve(zr))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , Rg = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/",
    math: "http://www.w3.org/1998/MathML/"
}
  , Ug = /%COMP%/g
  , $b = "%COMP%"
  , PB = `_nghost-${$b}`
  , OB = `_ngcontent-${$b}`
  , LB = !0
  , UB = new be("",{
    providedIn: "root",
    factory: ()=>LB
});
function VB(t) {
    return OB.replace(Ug, t)
}
function jB(t) {
    return PB.replace(Ug, t)
}
function Hb(t, e) {
    return e.map(n=>n.replace(Ug, t))
}
var Ob = (()=>{
    let e = class e {
        constructor(r, i, o, s, a, c, u, l=null) {
            this.eventManager = r,
            this.sharedStylesHost = i,
            this.appId = o,
            this.removeStylesOnCompDestroy = s,
            this.doc = a,
            this.platformId = c,
            this.ngZone = u,
            this.nonce = l,
            this.rendererByCompId = new Map,
            this.platformIsServer = $l(c),
            this.defaultRenderer = new sc(r,a,u,this.platformIsServer)
        }
        createRenderer(r, i) {
            if (!r || !i)
                return this.defaultRenderer;
            this.platformIsServer && i.encapsulation === Ur.ShadowDom && (i = me(ee({}, i), {
                encapsulation: Ur.Emulated
            }));
            let o = this.getOrCreateRenderer(r, i);
            return o instanceof Zl ? o.applyToHost(r) : o instanceof ac && o.applyStyles(),
            o
        }
        getOrCreateRenderer(r, i) {
            let o = this.rendererByCompId
              , s = o.get(i.id);
            if (!s) {
                let a = this.doc
                  , c = this.ngZone
                  , u = this.eventManager
                  , l = this.sharedStylesHost
                  , d = this.removeStylesOnCompDestroy
                  , y = this.platformIsServer;
                switch (i.encapsulation) {
                case Ur.Emulated:
                    s = new Zl(u,l,i,this.appId,d,a,c,y);
                    break;
                case Ur.ShadowDom:
                    return new Lg(u,l,r,i,a,c,this.nonce,y);
                default:
                    s = new ac(u,l,i,d,a,c,y);
                    break
                }
                o.set(i.id, s)
            }
            return s
        }
        ngOnDestroy() {
            this.rendererByCompId.clear()
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Vb),ve(jb),ve(El),ve(UB),ve(Dn),ve(zr),ve(wt),ve(Yp))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , sc = class {
    constructor(e, n, r, i) {
        this.eventManager = e,
        this.doc = n,
        this.ngZone = r,
        this.platformIsServer = i,
        this.data = Object.create(null),
        this.throwOnSyntheticProps = !0,
        this.destroyNode = null
    }
    destroy() {}
    createElement(e, n) {
        return n ? this.doc.createElementNS(Rg[n] || n, e) : this.doc.createElement(e)
    }
    createComment(e) {
        return this.doc.createComment(e)
    }
    createText(e) {
        return this.doc.createTextNode(e)
    }
    appendChild(e, n) {
        (Lb(e) ? e.content : e).appendChild(n)
    }
    insertBefore(e, n, r) {
        e && (Lb(e) ? e.content : e).insertBefore(n, r)
    }
    removeChild(e, n) {
        e && e.removeChild(n)
    }
    selectRootElement(e, n) {
        let r = typeof e == "string" ? this.doc.querySelector(e) : e;
        if (!r)
            throw new we(-5104,!1);
        return n || (r.textContent = ""),
        r
    }
    parentNode(e) {
        return e.parentNode
    }
    nextSibling(e) {
        return e.nextSibling
    }
    setAttribute(e, n, r, i) {
        if (i) {
            n = i + ":" + n;
            let o = Rg[i];
            o ? e.setAttributeNS(o, n, r) : e.setAttribute(n, r)
        } else
            e.setAttribute(n, r)
    }
    removeAttribute(e, n, r) {
        if (r) {
            let i = Rg[r];
            i ? e.removeAttributeNS(i, n) : e.removeAttribute(`${r}:${n}`)
        } else
            e.removeAttribute(n)
    }
    addClass(e, n) {
        e.classList.add(n)
    }
    removeClass(e, n) {
        e.classList.remove(n)
    }
    setStyle(e, n, r, i) {
        i & (ci.DashCase | ci.Important) ? e.style.setProperty(n, r, i & ci.Important ? "important" : "") : e.style[n] = r
    }
    removeStyle(e, n, r) {
        r & ci.DashCase ? e.style.removeProperty(n) : e.style[n] = ""
    }
    setProperty(e, n, r) {
        e != null && (e[n] = r)
    }
    setValue(e, n) {
        e.nodeValue = n
    }
    listen(e, n, r) {
        if (typeof e == "string" && (e = Po().getGlobalEventTarget(this.doc, e),
        !e))
            throw new Error(`Unsupported event target ${e} for event ${n}`);
        return this.eventManager.addEventListener(e, n, this.decoratePreventDefault(r))
    }
    decoratePreventDefault(e) {
        return n=>{
            if (n === "__ngUnwrap__")
                return e;
            (this.platformIsServer ? this.ngZone.runGuarded(()=>e(n)) : e(n)) === !1 && n.preventDefault()
        }
    }
}
;
function Lb(t) {
    return t.tagName === "TEMPLATE" && t.content !== void 0
}
var Lg = class extends sc {
    constructor(e, n, r, i, o, s, a, c) {
        super(e, o, s, c),
        this.sharedStylesHost = n,
        this.hostEl = r,
        this.shadowRoot = r.attachShadow({
            mode: "open"
        }),
        this.sharedStylesHost.addHost(this.shadowRoot);
        let u = Hb(i.id, i.styles);
        for (let l of u) {
            let d = document.createElement("style");
            a && d.setAttribute("nonce", a),
            d.textContent = l,
            this.shadowRoot.appendChild(d)
        }
    }
    nodeOrShadowRoot(e) {
        return e === this.hostEl ? this.shadowRoot : e
    }
    appendChild(e, n) {
        return super.appendChild(this.nodeOrShadowRoot(e), n)
    }
    insertBefore(e, n, r) {
        return super.insertBefore(this.nodeOrShadowRoot(e), n, r)
    }
    removeChild(e, n) {
        return super.removeChild(this.nodeOrShadowRoot(e), n)
    }
    parentNode(e) {
        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))
    }
    destroy() {
        this.sharedStylesHost.removeHost(this.shadowRoot)
    }
}
  , ac = class extends sc {
    constructor(e, n, r, i, o, s, a, c) {
        super(e, o, s, a),
        this.sharedStylesHost = n,
        this.removeStylesOnCompDestroy = i,
        this.styles = c ? Hb(c, r.styles) : r.styles
    }
    applyStyles() {
        this.sharedStylesHost.addStyles(this.styles)
    }
    destroy() {
        this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles)
    }
}
  , Zl = class extends ac {
    constructor(e, n, r, i, o, s, a, c) {
        let u = i + "-" + r.id;
        super(e, n, r, o, s, a, c, u),
        this.contentAttr = VB(u),
        this.hostAttr = jB(u)
    }
    applyToHost(e) {
        this.applyStyles(),
        this.setAttribute(e, this.hostAttr, "")
    }
    createElement(e, n) {
        let r = super.createElement(e, n);
        return super.setAttribute(r, this.contentAttr, ""),
        r
    }
}
  , $B = (()=>{
    let e = class e extends Yl {
        constructor(r) {
            super(r)
        }
        supports(r) {
            return !0
        }
        addEventListener(r, i, o) {
            return r.addEventListener(i, o, !1),
            ()=>this.removeEventListener(r, i, o)
        }
        removeEventListener(r, i, o) {
            return r.removeEventListener(i, o)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Dn))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)()
  , Ub = ["alt", "control", "meta", "shift"]
  , HB = {
    "\b": "Backspace",
    "	": "Tab",
    "\x7F": "Delete",
    "\x1B": "Escape",
    Del: "Delete",
    Esc: "Escape",
    Left: "ArrowLeft",
    Right: "ArrowRight",
    Up: "ArrowUp",
    Down: "ArrowDown",
    Menu: "ContextMenu",
    Scroll: "ScrollLock",
    Win: "OS"
}
  , zB = {
    alt: t=>t.altKey,
    control: t=>t.ctrlKey,
    meta: t=>t.metaKey,
    shift: t=>t.shiftKey
}
  , qB = (()=>{
    let e = class e extends Yl {
        constructor(r) {
            super(r)
        }
        supports(r) {
            return e.parseEventName(r) != null
        }
        addEventListener(r, i, o) {
            let s = e.parseEventName(i)
              , a = e.eventCallback(s.fullKey, o, this.manager.getZone());
            return this.manager.getZone().runOutsideAngular(()=>Po().onAndCancel(r, s.domEventName, a))
        }
        static parseEventName(r) {
            let i = r.toLowerCase().split(".")
              , o = i.shift();
            if (i.length === 0 || !(o === "keydown" || o === "keyup"))
                return null;
            let s = e._normalizeKey(i.pop())
              , a = ""
              , c = i.indexOf("code");
            if (c > -1 && (i.splice(c, 1),
            a = "code."),
            Ub.forEach(l=>{
                let d = i.indexOf(l);
                d > -1 && (i.splice(d, 1),
                a += l + ".")
            }
            ),
            a += s,
            i.length != 0 || s.length === 0)
                return null;
            let u = {};
            return u.domEventName = o,
            u.fullKey = a,
            u
        }
        static matchEventFullKeyCode(r, i) {
            let o = HB[r.key] || r.key
              , s = "";
            return i.indexOf("code.") > -1 && (o = r.code,
            s = "code."),
            o == null || !o ? !1 : (o = o.toLowerCase(),
            o === " " ? o = "space" : o === "." && (o = "dot"),
            Ub.forEach(a=>{
                if (a !== o) {
                    let c = zB[a];
                    c(r) && (s += a + ".")
                }
            }
            ),
            s += o,
            s === i)
        }
        static eventCallback(r, i, o) {
            return s=>{
                e.matchEventFullKeyCode(s, r) && o.runGuarded(()=>i(s))
            }
        }
        static _normalizeKey(r) {
            return r === "esc" ? "escape" : r
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Dn))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)();
function WB() {
    Ng.makeCurrent()
}
function GB() {
    return new $r
}
function KB() {
    return d1(document),
    document
}
var YB = [{
    provide: zr,
    useValue: Ig
}, {
    provide: Kp,
    useValue: WB,
    multi: !0
}, {
    provide: Dn,
    useFactory: KB,
    deps: []
}]
  , zb = pg(cb, "browser", YB)
  , ZB = new be("")
  , XB = [{
    provide: tc,
    useClass: Pg,
    deps: []
}, {
    provide: fg,
    useClass: Nl,
    deps: [wt, Pl, tc]
}, {
    provide: Nl,
    useClass: Nl,
    deps: [wt, Pl, tc]
}]
  , QB = [{
    provide: ml,
    useValue: "root"
}, {
    provide: $r,
    useFactory: GB,
    deps: []
}, {
    provide: Og,
    useClass: $B,
    multi: !0,
    deps: [Dn, wt, zr]
}, {
    provide: Og,
    useClass: qB,
    multi: !0,
    deps: [Dn]
}, Ob, jb, Vb, {
    provide: qa,
    useExisting: Ob
}, {
    provide: js,
    useClass: NB,
    deps: []
}, []]
  , qb = (()=>{
    let e = class e {
        constructor(r) {}
        static withServerTransition(r) {
            return {
                ngModule: e,
                providers: [{
                    provide: El,
                    useValue: r.appId
                }]
            }
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(ZB, 12))
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({
        providers: [...QB, ...XB],
        imports: [Cb, ub]
    });
    let t = e;
    return t
}
)();
var Wb = (()=>{
    let e = class e {
        constructor(r) {
            this._doc = r
        }
        getTitle() {
            return this._doc.title
        }
        setTitle(r) {
            this._doc.title = r || ""
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Dn))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
var Ne = "primary"
  , Ec = Symbol("RouteTitle")
  , zg = class {
    constructor(e) {
        this.params = e || {}
    }
    has(e) {
        return Object.prototype.hasOwnProperty.call(this.params, e)
    }
    get(e) {
        if (this.has(e)) {
            let n = this.params[e];
            return Array.isArray(n) ? n[0] : n
        }
        return null
    }
    getAll(e) {
        if (this.has(e)) {
            let n = this.params[e];
            return Array.isArray(n) ? n : [n]
        }
        return []
    }
    get keys() {
        return Object.keys(this.params)
    }
}
;
function Ks(t) {
    return new zg(t)
}
function e8(t, e, n) {
    let r = n.path.split("/");
    if (r.length > t.length || n.pathMatch === "full" && (e.hasChildren() || r.length < t.length))
        return null;
    let i = {};
    for (let o = 0; o < r.length; o++) {
        let s = r[o]
          , a = t[o];
        if (s.startsWith(":"))
            i[s.substring(1)] = a;
        else if (s !== a.path)
            return null
    }
    return {
        consumed: t.slice(0, r.length),
        posParams: i
    }
}
function t8(t, e) {
    if (t.length !== e.length)
        return !1;
    for (let n = 0; n < t.length; ++n)
        if (!Gr(t[n], e[n]))
            return !1;
    return !0
}
function Gr(t, e) {
    let n = t ? qg(t) : void 0
      , r = e ? qg(e) : void 0;
    if (!n || !r || n.length != r.length)
        return !1;
    let i;
    for (let o = 0; o < n.length; o++)
        if (i = n[o],
        !nE(t[i], e[i]))
            return !1;
    return !0
}
function qg(t) {
    return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)]
}
function nE(t, e) {
    if (Array.isArray(t) && Array.isArray(e)) {
        if (t.length !== e.length)
            return !1;
        let n = [...t].sort()
          , r = [...e].sort();
        return n.every((i,o)=>r[o] === i)
    } else
        return t === e
}
function rE(t) {
    return t.length > 0 ? t[t.length - 1] : null
}
function Yi(t) {
    return E0(t) ? t : Us(t) ? Mt(Promise.resolve(t)) : Ie(t)
}
var n8 = {
    exact: oE,
    subset: sE
}
  , iE = {
    exact: r8,
    subset: i8,
    ignored: ()=>!0
};
function Kb(t, e, n) {
    return n8[n.paths](t.root, e.root, n.matrixParams) && iE[n.queryParams](t.queryParams, e.queryParams) && !(n.fragment === "exact" && t.fragment !== e.fragment)
}
function r8(t, e) {
    return Gr(t, e)
}
function oE(t, e, n) {
    if (!Uo(t.segments, e.segments) || !Jl(t.segments, e.segments, n) || t.numberOfChildren !== e.numberOfChildren)
        return !1;
    for (let r in e.children)
        if (!t.children[r] || !oE(t.children[r], e.children[r], n))
            return !1;
    return !0
}
function i8(t, e) {
    return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n=>nE(t[n], e[n]))
}
function sE(t, e, n) {
    return aE(t, e, e.segments, n)
}
function aE(t, e, n, r) {
    if (t.segments.length > n.length) {
        let i = t.segments.slice(0, n.length);
        return !(!Uo(i, n) || e.hasChildren() || !Jl(i, n, r))
    } else if (t.segments.length === n.length) {
        if (!Uo(t.segments, n) || !Jl(t.segments, n, r))
            return !1;
        for (let i in e.children)
            if (!t.children[i] || !sE(t.children[i], e.children[i], r))
                return !1;
        return !0
    } else {
        let i = n.slice(0, t.segments.length)
          , o = n.slice(t.segments.length);
        return !Uo(t.segments, i) || !Jl(t.segments, i, r) || !t.children[Ne] ? !1 : aE(t.children[Ne], e, o, r)
    }
}
function Jl(t, e, n) {
    return e.every((r,i)=>iE[n](t[i].parameters, r.parameters))
}
var qi = class {
    constructor(e=new pt([],{}), n={}, r=null) {
        this.root = e,
        this.queryParams = n,
        this.fragment = r
    }
    get queryParamMap() {
        return this._queryParamMap ??= Ks(this.queryParams),
        this._queryParamMap
    }
    toString() {
        return a8.serialize(this)
    }
}
  , pt = class {
    constructor(e, n) {
        this.segments = e,
        this.children = n,
        this.parent = null,
        Object.values(n).forEach(r=>r.parent = this)
    }
    hasChildren() {
        return this.numberOfChildren > 0
    }
    get numberOfChildren() {
        return Object.keys(this.children).length
    }
    toString() {
        return ef(this)
    }
}
  , Lo = class {
    constructor(e, n) {
        this.path = e,
        this.parameters = n
    }
    get parameterMap() {
        return this._parameterMap ??= Ks(this.parameters),
        this._parameterMap
    }
    toString() {
        return uE(this)
    }
}
;
function o8(t, e) {
    return Uo(t, e) && t.every((n,r)=>Gr(n.parameters, e[r].parameters))
}
function Uo(t, e) {
    return t.length !== e.length ? !1 : t.every((n,r)=>n.path === e[r].path)
}
function s8(t, e) {
    let n = [];
    return Object.entries(t.children).forEach(([r,i])=>{
        r === Ne && (n = n.concat(e(i, r)))
    }
    ),
    Object.entries(t.children).forEach(([r,i])=>{
        r !== Ne && (n = n.concat(e(i, r)))
    }
    ),
    n
}
var Cc = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>new pc,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , pc = class {
    parse(e) {
        let n = new Gg(e);
        return new qi(n.parseRootSegment(),n.parseQueryParams(),n.parseFragment())
    }
    serialize(e) {
        let n = `/${cc(e.root, !0)}`
          , r = l8(e.queryParams)
          , i = typeof e.fragment == "string" ? `#${c8(e.fragment)}` : "";
        return `${n}${r}${i}`
    }
}
  , a8 = new pc;
function ef(t) {
    return t.segments.map(e=>uE(e)).join("/")
}
function cc(t, e) {
    if (!t.hasChildren())
        return ef(t);
    if (e) {
        let n = t.children[Ne] ? cc(t.children[Ne], !1) : ""
          , r = [];
        return Object.entries(t.children).forEach(([i,o])=>{
            i !== Ne && r.push(`${i}:${cc(o, !1)}`)
        }
        ),
        r.length > 0 ? `${n}(${r.join("//")})` : n
    } else {
        let n = s8(t, (r,i)=>i === Ne ? [cc(t.children[Ne], !1)] : [`${i}:${cc(r, !1)}`]);
        return Object.keys(t.children).length === 1 && t.children[Ne] != null ? `${ef(t)}/${n[0]}` : `${ef(t)}/(${n.join("//")})`
    }
}
function cE(t) {
    return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
}
function Xl(t) {
    return cE(t).replace(/%3B/gi, ";")
}
function c8(t) {
    return encodeURI(t)
}
function Wg(t) {
    return cE(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
}
function tf(t) {
    return decodeURIComponent(t)
}
function Yb(t) {
    return tf(t.replace(/\+/g, "%20"))
}
function uE(t) {
    return `${Wg(t.path)}${u8(t.parameters)}`
}
function u8(t) {
    return Object.entries(t).map(([e,n])=>`;${Wg(e)}=${Wg(n)}`).join("")
}
function l8(t) {
    let e = Object.entries(t).map(([n,r])=>Array.isArray(r) ? r.map(i=>`${Xl(n)}=${Xl(i)}`).join("&") : `${Xl(n)}=${Xl(r)}`).filter(n=>n);
    return e.length ? `?${e.join("&")}` : ""
}
var f8 = /^[^\/()?;#]+/;
function Vg(t) {
    let e = t.match(f8);
    return e ? e[0] : ""
}
var d8 = /^[^\/()?;=#]+/;
function h8(t) {
    let e = t.match(d8);
    return e ? e[0] : ""
}
var p8 = /^[^=?&#]+/;
function g8(t) {
    let e = t.match(p8);
    return e ? e[0] : ""
}
var m8 = /^[^&#]+/;
function y8(t) {
    let e = t.match(m8);
    return e ? e[0] : ""
}
var Gg = class {
    constructor(e) {
        this.url = e,
        this.remaining = e
    }
    parseRootSegment() {
        return this.consumeOptional("/"),
        this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new pt([],{}) : new pt([],this.parseChildren())
    }
    parseQueryParams() {
        let e = {};
        if (this.consumeOptional("?"))
            do
                this.parseQueryParam(e);
            while (this.consumeOptional("&"));
        return e
    }
    parseFragment() {
        return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
    }
    parseChildren() {
        if (this.remaining === "")
            return {};
        this.consumeOptional("/");
        let e = [];
        for (this.peekStartsWith("(") || e.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/("); )
            this.capture("/"),
            e.push(this.parseSegment());
        let n = {};
        this.peekStartsWith("/(") && (this.capture("/"),
        n = this.parseParens(!0));
        let r = {};
        return this.peekStartsWith("(") && (r = this.parseParens(!1)),
        (e.length > 0 || Object.keys(n).length > 0) && (r[Ne] = new pt(e,n)),
        r
    }
    parseSegment() {
        let e = Vg(this.remaining);
        if (e === "" && this.peekStartsWith(";"))
            throw new we(4009,!1);
        return this.capture(e),
        new Lo(tf(e),this.parseMatrixParams())
    }
    parseMatrixParams() {
        let e = {};
        for (; this.consumeOptional(";"); )
            this.parseParam(e);
        return e
    }
    parseParam(e) {
        let n = h8(this.remaining);
        if (!n)
            return;
        this.capture(n);
        let r = "";
        if (this.consumeOptional("=")) {
            let i = Vg(this.remaining);
            i && (r = i,
            this.capture(r))
        }
        e[tf(n)] = tf(r)
    }
    parseQueryParam(e) {
        let n = g8(this.remaining);
        if (!n)
            return;
        this.capture(n);
        let r = "";
        if (this.consumeOptional("=")) {
            let s = y8(this.remaining);
            s && (r = s,
            this.capture(r))
        }
        let i = Yb(n)
          , o = Yb(r);
        if (e.hasOwnProperty(i)) {
            let s = e[i];
            Array.isArray(s) || (s = [s],
            e[i] = s),
            s.push(o)
        } else
            e[i] = o
    }
    parseParens(e) {
        let n = {};
        for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0; ) {
            let r = Vg(this.remaining)
              , i = this.remaining[r.length];
            if (i !== "/" && i !== ")" && i !== ";")
                throw new we(4010,!1);
            let o;
            r.indexOf(":") > -1 ? (o = r.slice(0, r.indexOf(":")),
            this.capture(o),
            this.capture(":")) : e && (o = Ne);
            let s = this.parseChildren();
            n[o] = Object.keys(s).length === 1 ? s[Ne] : new pt([],s),
            this.consumeOptional("//")
        }
        return n
    }
    peekStartsWith(e) {
        return this.remaining.startsWith(e)
    }
    consumeOptional(e) {
        return this.peekStartsWith(e) ? (this.remaining = this.remaining.substring(e.length),
        !0) : !1
    }
    capture(e) {
        if (!this.consumeOptional(e))
            throw new we(4011,!1)
    }
}
;
function lE(t) {
    return t.segments.length > 0 ? new pt([],{
        [Ne]: t
    }) : t
}
function fE(t) {
    let e = {};
    for (let[r,i] of Object.entries(t.children)) {
        let o = fE(i);
        if (r === Ne && o.segments.length === 0 && o.hasChildren())
            for (let[s,a] of Object.entries(o.children))
                e[s] = a;
        else
            (o.segments.length > 0 || o.hasChildren()) && (e[r] = o)
    }
    let n = new pt(t.segments,e);
    return v8(n)
}
function v8(t) {
    if (t.numberOfChildren === 1 && t.children[Ne]) {
        let e = t.children[Ne];
        return new pt(t.segments.concat(e.segments),e.children)
    }
    return t
}
function Ys(t) {
    return t instanceof qi
}
function x8(t, e, n=null, r=null) {
    let i = dE(t);
    return hE(i, e, n, r)
}
function dE(t) {
    let e;
    function n(o) {
        let s = {};
        for (let c of o.children) {
            let u = n(c);
            s[c.outlet] = u
        }
        let a = new pt(o.url,s);
        return o === t && (e = a),
        a
    }
    let r = n(t.root)
      , i = lE(r);
    return e ?? i
}
function hE(t, e, n, r) {
    let i = t;
    for (; i.parent; )
        i = i.parent;
    if (e.length === 0)
        return jg(i, i, i, n, r);
    let o = w8(e);
    if (o.toRoot())
        return jg(i, i, new pt([],{}), n, r);
    let s = b8(o, i, t)
      , a = s.processChildren ? fc(s.segmentGroup, s.index, o.commands) : gE(s.segmentGroup, s.index, o.commands);
    return jg(i, s.segmentGroup, a, n, r)
}
function nf(t) {
    return typeof t == "object" && t != null && !t.outlets && !t.segmentPath
}
function gc(t) {
    return typeof t == "object" && t != null && t.outlets
}
function jg(t, e, n, r, i) {
    let o = {};
    r && Object.entries(r).forEach(([c,u])=>{
        o[c] = Array.isArray(u) ? u.map(l=>`${l}`) : `${u}`
    }
    );
    let s;
    t === e ? s = n : s = pE(t, e, n);
    let a = lE(fE(s));
    return new qi(a,o,i)
}
function pE(t, e, n) {
    let r = {};
    return Object.entries(t.children).forEach(([i,o])=>{
        o === e ? r[i] = n : r[i] = pE(o, e, n)
    }
    ),
    new pt(t.segments,r)
}
var rf = class {
    constructor(e, n, r) {
        if (this.isAbsolute = e,
        this.numberOfDoubleDots = n,
        this.commands = r,
        e && r.length > 0 && nf(r[0]))
            throw new we(4003,!1);
        let i = r.find(gc);
        if (i && i !== rE(r))
            throw new we(4004,!1)
    }
    toRoot() {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/"
    }
}
;
function w8(t) {
    if (typeof t[0] == "string" && t.length === 1 && t[0] === "/")
        return new rf(!0,0,t);
    let e = 0
      , n = !1
      , r = t.reduce((i,o,s)=>{
        if (typeof o == "object" && o != null) {
            if (o.outlets) {
                let a = {};
                return Object.entries(o.outlets).forEach(([c,u])=>{
                    a[c] = typeof u == "string" ? u.split("/") : u
                }
                ),
                [...i, {
                    outlets: a
                }]
            }
            if (o.segmentPath)
                return [...i, o.segmentPath]
        }
        return typeof o != "string" ? [...i, o] : s === 0 ? (o.split("/").forEach((a,c)=>{
            c == 0 && a === "." || (c == 0 && a === "" ? n = !0 : a === ".." ? e++ : a != "" && i.push(a))
        }
        ),
        i) : [...i, o]
    }
    , []);
    return new rf(n,e,r)
}
var Ws = class {
    constructor(e, n, r) {
        this.segmentGroup = e,
        this.processChildren = n,
        this.index = r
    }
}
;
function b8(t, e, n) {
    if (t.isAbsolute)
        return new Ws(e,!0,0);
    if (!n)
        return new Ws(e,!1,NaN);
    if (n.parent === null)
        return new Ws(n,!0,0);
    let r = nf(t.commands[0]) ? 0 : 1
      , i = n.segments.length - 1 + r;
    return E8(n, i, t.numberOfDoubleDots)
}
function E8(t, e, n) {
    let r = t
      , i = e
      , o = n;
    for (; o > i; ) {
        if (o -= i,
        r = r.parent,
        !r)
            throw new we(4005,!1);
        i = r.segments.length
    }
    return new Ws(r,!1,i - o)
}
function C8(t) {
    return gc(t[0]) ? t[0].outlets : {
        [Ne]: t
    }
}
function gE(t, e, n) {
    if (t ??= new pt([],{}),
    t.segments.length === 0 && t.hasChildren())
        return fc(t, e, n);
    let r = D8(t, e, n)
      , i = n.slice(r.commandIndex);
    if (r.match && r.pathIndex < t.segments.length) {
        let o = new pt(t.segments.slice(0, r.pathIndex),{});
        return o.children[Ne] = new pt(t.segments.slice(r.pathIndex),t.children),
        fc(o, 0, i)
    } else
        return r.match && i.length === 0 ? new pt(t.segments,{}) : r.match && !t.hasChildren() ? Kg(t, e, n) : r.match ? fc(t, 0, i) : Kg(t, e, n)
}
function fc(t, e, n) {
    if (n.length === 0)
        return new pt(t.segments,{});
    {
        let r = C8(n)
          , i = {};
        if (Object.keys(r).some(o=>o !== Ne) && t.children[Ne] && t.numberOfChildren === 1 && t.children[Ne].segments.length === 0) {
            let o = fc(t.children[Ne], e, n);
            return new pt(t.segments,o.children)
        }
        return Object.entries(r).forEach(([o,s])=>{
            typeof s == "string" && (s = [s]),
            s !== null && (i[o] = gE(t.children[o], e, s))
        }
        ),
        Object.entries(t.children).forEach(([o,s])=>{
            r[o] === void 0 && (i[o] = s)
        }
        ),
        new pt(t.segments,i)
    }
}
function D8(t, e, n) {
    let r = 0
      , i = e
      , o = {
        match: !1,
        pathIndex: 0,
        commandIndex: 0
    };
    for (; i < t.segments.length; ) {
        if (r >= n.length)
            return o;
        let s = t.segments[i]
          , a = n[r];
        if (gc(a))
            break;
        let c = `${a}`
          , u = r < n.length - 1 ? n[r + 1] : null;
        if (i > 0 && c === void 0)
            break;
        if (c && u && typeof u == "object" && u.outlets === void 0) {
            if (!Xb(c, u, s))
                return o;
            r += 2
        } else {
            if (!Xb(c, {}, s))
                return o;
            r++
        }
        i++
    }
    return {
        match: !0,
        pathIndex: i,
        commandIndex: r
    }
}
function Kg(t, e, n) {
    let r = t.segments.slice(0, e)
      , i = 0;
    for (; i < n.length; ) {
        let o = n[i];
        if (gc(o)) {
            let c = I8(o.outlets);
            return new pt(r,c)
        }
        if (i === 0 && nf(n[0])) {
            let c = t.segments[e];
            r.push(new Lo(c.path,Zb(n[0]))),
            i++;
            continue
        }
        let s = gc(o) ? o.outlets[Ne] : `${o}`
          , a = i < n.length - 1 ? n[i + 1] : null;
        s && a && nf(a) ? (r.push(new Lo(s,Zb(a))),
        i += 2) : (r.push(new Lo(s,{})),
        i++)
    }
    return new pt(r,{})
}
function I8(t) {
    let e = {};
    return Object.entries(t).forEach(([n,r])=>{
        typeof r == "string" && (r = [r]),
        r !== null && (e[n] = Kg(new pt([],{}), 0, r))
    }
    ),
    e
}
function Zb(t) {
    let e = {};
    return Object.entries(t).forEach(([n,r])=>e[n] = `${r}`),
    e
}
function Xb(t, e, n) {
    return t == n.path && Gr(e, n.parameters)
}
var dc = "imperative"
  , cn = function(t) {
    return t[t.NavigationStart = 0] = "NavigationStart",
    t[t.NavigationEnd = 1] = "NavigationEnd",
    t[t.NavigationCancel = 2] = "NavigationCancel",
    t[t.NavigationError = 3] = "NavigationError",
    t[t.RoutesRecognized = 4] = "RoutesRecognized",
    t[t.ResolveStart = 5] = "ResolveStart",
    t[t.ResolveEnd = 6] = "ResolveEnd",
    t[t.GuardsCheckStart = 7] = "GuardsCheckStart",
    t[t.GuardsCheckEnd = 8] = "GuardsCheckEnd",
    t[t.RouteConfigLoadStart = 9] = "RouteConfigLoadStart",
    t[t.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd",
    t[t.ChildActivationStart = 11] = "ChildActivationStart",
    t[t.ChildActivationEnd = 12] = "ChildActivationEnd",
    t[t.ActivationStart = 13] = "ActivationStart",
    t[t.ActivationEnd = 14] = "ActivationEnd",
    t[t.Scroll = 15] = "Scroll",
    t[t.NavigationSkipped = 16] = "NavigationSkipped",
    t
}(cn || {})
  , ur = class {
    constructor(e, n) {
        this.id = e,
        this.url = n
    }
}
  , Zs = class extends ur {
    constructor(e, n, r="imperative", i=null) {
        super(e, n),
        this.type = cn.NavigationStart,
        this.navigationTrigger = r,
        this.restoredState = i
    }
    toString() {
        return `NavigationStart(id: ${this.id}, url: '${this.url}')`
    }
}
  , gi = class extends ur {
    constructor(e, n, r) {
        super(e, n),
        this.urlAfterRedirects = r,
        this.type = cn.NavigationEnd
    }
    toString() {
        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
    }
}
  , er = function(t) {
    return t[t.Redirect = 0] = "Redirect",
    t[t.SupersededByNewNavigation = 1] = "SupersededByNewNavigation",
    t[t.NoDataFromResolver = 2] = "NoDataFromResolver",
    t[t.GuardRejected = 3] = "GuardRejected",
    t
}(er || {})
  , of = function(t) {
    return t[t.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation",
    t[t.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy",
    t
}(of || {})
  , Wi = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.reason = r,
        this.code = i,
        this.type = cn.NavigationCancel
    }
    toString() {
        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
    }
}
  , Gi = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.reason = r,
        this.code = i,
        this.type = cn.NavigationSkipped
    }
}
  , mc = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.error = r,
        this.target = i,
        this.type = cn.NavigationError
    }
    toString() {
        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
    }
}
  , sf = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.urlAfterRedirects = r,
        this.state = i,
        this.type = cn.RoutesRecognized
    }
    toString() {
        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , Yg = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.urlAfterRedirects = r,
        this.state = i,
        this.type = cn.GuardsCheckStart
    }
    toString() {
        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , Zg = class extends ur {
    constructor(e, n, r, i, o) {
        super(e, n),
        this.urlAfterRedirects = r,
        this.state = i,
        this.shouldActivate = o,
        this.type = cn.GuardsCheckEnd
    }
    toString() {
        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
    }
}
  , Xg = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.urlAfterRedirects = r,
        this.state = i,
        this.type = cn.ResolveStart
    }
    toString() {
        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , Qg = class extends ur {
    constructor(e, n, r, i) {
        super(e, n),
        this.urlAfterRedirects = r,
        this.state = i,
        this.type = cn.ResolveEnd
    }
    toString() {
        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
    }
}
  , Jg = class {
    constructor(e) {
        this.route = e,
        this.type = cn.RouteConfigLoadStart
    }
    toString() {
        return `RouteConfigLoadStart(path: ${this.route.path})`
    }
}
  , em = class {
    constructor(e) {
        this.route = e,
        this.type = cn.RouteConfigLoadEnd
    }
    toString() {
        return `RouteConfigLoadEnd(path: ${this.route.path})`
    }
}
  , tm = class {
    constructor(e) {
        this.snapshot = e,
        this.type = cn.ChildActivationStart
    }
    toString() {
        return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , nm = class {
    constructor(e) {
        this.snapshot = e,
        this.type = cn.ChildActivationEnd
    }
    toString() {
        return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , rm = class {
    constructor(e) {
        this.snapshot = e,
        this.type = cn.ActivationStart
    }
    toString() {
        return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , im = class {
    constructor(e) {
        this.snapshot = e,
        this.type = cn.ActivationEnd
    }
    toString() {
        return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')`
    }
}
  , af = class {
    constructor(e, n, r) {
        this.routerEvent = e,
        this.position = n,
        this.anchor = r,
        this.type = cn.Scroll
    }
    toString() {
        let e = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
        return `Scroll(anchor: '${this.anchor}', position: '${e}')`
    }
}
  , yc = class {
}
  , vc = class {
    constructor(e) {
        this.url = e
    }
}
;
var om = class {
    constructor() {
        this.outlet = null,
        this.route = null,
        this.injector = null,
        this.children = new Dc,
        this.attachRef = null
    }
}
  , Dc = (()=>{
    let e = class e {
        constructor() {
            this.contexts = new Map
        }
        onChildOutletCreated(r, i) {
            let o = this.getOrCreateContext(r);
            o.outlet = i,
            this.contexts.set(r, o)
        }
        onChildOutletDestroyed(r) {
            let i = this.getContext(r);
            i && (i.outlet = null,
            i.attachRef = null)
        }
        onOutletDeactivated() {
            let r = this.contexts;
            return this.contexts = new Map,
            r
        }
        onOutletReAttached(r) {
            this.contexts = r
        }
        getOrCreateContext(r) {
            let i = this.getContext(r);
            return i || (i = new om,
            this.contexts.set(r, i)),
            i
        }
        getContext(r) {
            return this.contexts.get(r) || null
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , cf = class {
    constructor(e) {
        this._root = e
    }
    get root() {
        return this._root.value
    }
    parent(e) {
        let n = this.pathFromRoot(e);
        return n.length > 1 ? n[n.length - 2] : null
    }
    children(e) {
        let n = sm(e, this._root);
        return n ? n.children.map(r=>r.value) : []
    }
    firstChild(e) {
        let n = sm(e, this._root);
        return n && n.children.length > 0 ? n.children[0].value : null
    }
    siblings(e) {
        let n = am(e, this._root);
        return n.length < 2 ? [] : n[n.length - 2].children.map(i=>i.value).filter(i=>i !== e)
    }
    pathFromRoot(e) {
        return am(e, this._root).map(n=>n.value)
    }
}
;
function sm(t, e) {
    if (t === e.value)
        return e;
    for (let n of e.children) {
        let r = sm(t, n);
        if (r)
            return r
    }
    return null
}
function am(t, e) {
    if (t === e.value)
        return [e];
    for (let n of e.children) {
        let r = am(t, n);
        if (r.length)
            return r.unshift(e),
            r
    }
    return []
}
var Jn = class {
    constructor(e, n) {
        this.value = e,
        this.children = n
    }
    toString() {
        return `TreeNode(${this.value})`
    }
}
;
function qs(t) {
    let e = {};
    return t && t.children.forEach(n=>e[n.value.outlet] = n),
    e
}
var uf = class extends cf {
    constructor(e, n) {
        super(e),
        this.snapshot = n,
        ym(this, e)
    }
    toString() {
        return this.snapshot.toString()
    }
}
;
function mE(t) {
    let e = A8(t)
      , n = new dn([new Lo("",{})])
      , r = new dn({})
      , i = new dn({})
      , o = new dn({})
      , s = new dn("")
      , a = new Ki(n,r,o,s,i,Ne,t,e.root);
    return a.snapshot = e.root,
    new uf(new Jn(a,[]),e)
}
function A8(t) {
    let e = {}
      , n = {}
      , r = {}
      , i = ""
      , o = new xc([],e,r,i,n,Ne,t,null,{});
    return new lf("",new Jn(o,[]))
}
var Ki = class {
    constructor(e, n, r, i, o, s, a, c) {
        this.urlSubject = e,
        this.paramsSubject = n,
        this.queryParamsSubject = r,
        this.fragmentSubject = i,
        this.dataSubject = o,
        this.outlet = s,
        this.component = a,
        this._futureSnapshot = c,
        this.title = this.dataSubject?.pipe(Ue(u=>u[Ec])) ?? Ie(void 0),
        this.url = e,
        this.params = n,
        this.queryParams = r,
        this.fragment = i,
        this.data = o
    }
    get routeConfig() {
        return this._futureSnapshot.routeConfig
    }
    get root() {
        return this._routerState.root
    }
    get parent() {
        return this._routerState.parent(this)
    }
    get firstChild() {
        return this._routerState.firstChild(this)
    }
    get children() {
        return this._routerState.children(this)
    }
    get pathFromRoot() {
        return this._routerState.pathFromRoot(this)
    }
    get paramMap() {
        return this._paramMap ??= this.params.pipe(Ue(e=>Ks(e))),
        this._paramMap
    }
    get queryParamMap() {
        return this._queryParamMap ??= this.queryParams.pipe(Ue(e=>Ks(e))),
        this._queryParamMap
    }
    toString() {
        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
    }
}
;
function mm(t, e, n="emptyOnly") {
    let r, {routeConfig: i} = t;
    return e !== null && (n === "always" || i?.path === "" || !e.component && !e.routeConfig?.loadComponent) ? r = {
        params: ee(ee({}, e.params), t.params),
        data: ee(ee({}, e.data), t.data),
        resolve: ee(ee(ee(ee({}, t.data), e.data), i?.data), t._resolvedData)
    } : r = {
        params: ee({}, t.params),
        data: ee({}, t.data),
        resolve: ee(ee({}, t.data), t._resolvedData ?? {})
    },
    i && vE(i) && (r.resolve[Ec] = i.title),
    r
}
var xc = class {
    get title() {
        return this.data?.[Ec]
    }
    constructor(e, n, r, i, o, s, a, c, u) {
        this.url = e,
        this.params = n,
        this.queryParams = r,
        this.fragment = i,
        this.data = o,
        this.outlet = s,
        this.component = a,
        this.routeConfig = c,
        this._resolve = u
    }
    get root() {
        return this._routerState.root
    }
    get parent() {
        return this._routerState.parent(this)
    }
    get firstChild() {
        return this._routerState.firstChild(this)
    }
    get children() {
        return this._routerState.children(this)
    }
    get pathFromRoot() {
        return this._routerState.pathFromRoot(this)
    }
    get paramMap() {
        return this._paramMap ??= Ks(this.params),
        this._paramMap
    }
    get queryParamMap() {
        return this._queryParamMap ??= Ks(this.queryParams),
        this._queryParamMap
    }
    toString() {
        let e = this.url.map(r=>r.toString()).join("/")
          , n = this.routeConfig ? this.routeConfig.path : "";
        return `Route(url:'${e}', path:'${n}')`
    }
}
  , lf = class extends cf {
    constructor(e, n) {
        super(n),
        this.url = e,
        ym(this, n)
    }
    toString() {
        return yE(this._root)
    }
}
;
function ym(t, e) {
    e.value._routerState = t,
    e.children.forEach(n=>ym(t, n))
}
function yE(t) {
    let e = t.children.length > 0 ? ` { ${t.children.map(yE).join(", ")} } ` : "";
    return `${t.value}${e}`
}
function $g(t) {
    if (t.snapshot) {
        let e = t.snapshot
          , n = t._futureSnapshot;
        t.snapshot = n,
        Gr(e.queryParams, n.queryParams) || t.queryParamsSubject.next(n.queryParams),
        e.fragment !== n.fragment && t.fragmentSubject.next(n.fragment),
        Gr(e.params, n.params) || t.paramsSubject.next(n.params),
        t8(e.url, n.url) || t.urlSubject.next(n.url),
        Gr(e.data, n.data) || t.dataSubject.next(n.data)
    } else
        t.snapshot = t._futureSnapshot,
        t.dataSubject.next(t._futureSnapshot.data)
}
function cm(t, e) {
    let n = Gr(t.params, e.params) && o8(t.url, e.url)
      , r = !t.parent != !e.parent;
    return n && !r && (!t.parent || cm(t.parent, e.parent))
}
function vE(t) {
    return typeof t.title == "string" || t.title === null
}
var vm = (()=>{
    let e = class e {
        constructor() {
            this.activated = null,
            this._activatedRoute = null,
            this.name = Ne,
            this.activateEvents = new xn,
            this.deactivateEvents = new xn,
            this.attachEvents = new xn,
            this.detachEvents = new xn,
            this.parentContexts = ie(Dc),
            this.location = ie(Os),
            this.changeDetector = ie(Vs),
            this.environmentInjector = ie(wn),
            this.inputBinder = ie(gf, {
                optional: !0
            }),
            this.supportsBindingToComponentInputs = !0
        }
        get activatedComponentRef() {
            return this.activated
        }
        ngOnChanges(r) {
            if (r.name) {
                let {firstChange: i, previousValue: o} = r.name;
                if (i)
                    return;
                this.isTrackedInParentContexts(o) && (this.deactivate(),
                this.parentContexts.onChildOutletDestroyed(o)),
                this.initializeOutletWithName()
            }
        }
        ngOnDestroy() {
            this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name),
            this.inputBinder?.unsubscribeFromRouteData(this)
        }
        isTrackedInParentContexts(r) {
            return this.parentContexts.getContext(r)?.outlet === this
        }
        ngOnInit() {
            this.initializeOutletWithName()
        }
        initializeOutletWithName() {
            if (this.parentContexts.onChildOutletCreated(this.name, this),
            this.activated)
                return;
            let r = this.parentContexts.getContext(this.name);
            r?.route && (r.attachRef ? this.attach(r.attachRef, r.route) : this.activateWith(r.route, r.injector))
        }
        get isActivated() {
            return !!this.activated
        }
        get component() {
            if (!this.activated)
                throw new we(4012,!1);
            return this.activated.instance
        }
        get activatedRoute() {
            if (!this.activated)
                throw new we(4012,!1);
            return this._activatedRoute
        }
        get activatedRouteData() {
            return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
        }
        detach() {
            if (!this.activated)
                throw new we(4012,!1);
            this.location.detach();
            let r = this.activated;
            return this.activated = null,
            this._activatedRoute = null,
            this.detachEvents.emit(r.instance),
            r
        }
        attach(r, i) {
            this.activated = r,
            this._activatedRoute = i,
            this.location.insert(r.hostView),
            this.inputBinder?.bindActivatedRouteToOutletComponent(this),
            this.attachEvents.emit(r.instance)
        }
        deactivate() {
            if (this.activated) {
                let r = this.component;
                this.activated.destroy(),
                this.activated = null,
                this._activatedRoute = null,
                this.deactivateEvents.emit(r)
            }
        }
        activateWith(r, i) {
            if (this.isActivated)
                throw new we(4013,!1);
            this._activatedRoute = r;
            let o = this.location
              , a = r.snapshot.component
              , c = this.parentContexts.getOrCreateContext(this.name).children
              , u = new um(r,c,o.injector);
            this.activated = o.createComponent(a, {
                index: o.length,
                injector: u,
                environmentInjector: i ?? this.environmentInjector
            }),
            this.changeDetector.markForCheck(),
            this.inputBinder?.bindActivatedRouteToOutletComponent(this),
            this.activateEvents.emit(this.activated.instance)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275dir = Fs({
        type: e,
        selectors: [["router-outlet"]],
        inputs: {
            name: "name"
        },
        outputs: {
            activateEvents: "activate",
            deactivateEvents: "deactivate",
            attachEvents: "attach",
            detachEvents: "detach"
        },
        exportAs: ["outlet"],
        standalone: !0,
        features: [Xa]
    });
    let t = e;
    return t
}
)()
  , um = class t {
    __ngOutletInjector(e) {
        return new t(this.route,this.childContexts,e)
    }
    constructor(e, n, r) {
        this.route = e,
        this.childContexts = n,
        this.parent = r
    }
    get(e, n) {
        return e === Ki ? this.route : e === Dc ? this.childContexts : this.parent.get(e, n)
    }
}
  , gf = new be("")
  , Qb = (()=>{
    let e = class e {
        constructor() {
            this.outletDataSubscriptions = new Map
        }
        bindActivatedRouteToOutletComponent(r) {
            this.unsubscribeFromRouteData(r),
            this.subscribeToRouteData(r)
        }
        unsubscribeFromRouteData(r) {
            this.outletDataSubscriptions.get(r)?.unsubscribe(),
            this.outletDataSubscriptions.delete(r)
        }
        subscribeToRouteData(r) {
            let {activatedRoute: i} = r
              , o = Ra([i.queryParams, i.params, i.data]).pipe(jn(([s,a,c],u)=>(c = ee(ee(ee({}, s), a), c),
            u === 0 ? Ie(c) : Promise.resolve(c)))).subscribe(s=>{
                if (!r.isActivated || !r.activatedComponentRef || r.activatedRoute !== i || i.component === null) {
                    this.unsubscribeFromRouteData(r);
                    return
                }
                let a = lb(i.component);
                if (!a) {
                    this.unsubscribeFromRouteData(r);
                    return
                }
                for (let {templateName: c} of a.inputs)
                    r.activatedComponentRef.setInput(c, s[c])
            }
            );
            this.outletDataSubscriptions.set(r, o)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)();
function _8(t, e, n) {
    let r = wc(t, e._root, n ? n._root : void 0);
    return new uf(r,e)
}
function wc(t, e, n) {
    if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) {
        let r = n.value;
        r._futureSnapshot = e.value;
        let i = S8(t, e, n);
        return new Jn(r,i)
    } else {
        if (t.shouldAttach(e.value)) {
            let o = t.retrieve(e.value);
            if (o !== null) {
                let s = o.route;
                return s.value._futureSnapshot = e.value,
                s.children = e.children.map(a=>wc(t, a)),
                s
            }
        }
        let r = M8(e.value)
          , i = e.children.map(o=>wc(t, o));
        return new Jn(r,i)
    }
}
function S8(t, e, n) {
    return e.children.map(r=>{
        for (let i of n.children)
            if (t.shouldReuseRoute(r.value, i.value.snapshot))
                return wc(t, r, i);
        return wc(t, r)
    }
    )
}
function M8(t) {
    return new Ki(new dn(t.url),new dn(t.params),new dn(t.queryParams),new dn(t.fragment),new dn(t.data),t.outlet,t.component,t)
}
var xE = "ngNavigationCancelingError";
function wE(t, e) {
    let {redirectTo: n, navigationBehaviorOptions: r} = Ys(e) ? {
        redirectTo: e,
        navigationBehaviorOptions: void 0
    } : e
      , i = bE(!1, er.Redirect);
    return i.url = n,
    i.navigationBehaviorOptions = r,
    i
}
function bE(t, e) {
    let n = new Error(`NavigationCancelingError: ${t || ""}`);
    return n[xE] = !0,
    n.cancellationCode = e,
    n
}
function k8(t) {
    return EE(t) && Ys(t.url)
}
function EE(t) {
    return !!t && t[xE]
}
var T8 = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275cmp = Rs({
        type: e,
        selectors: [["ng-component"]],
        standalone: !0,
        features: [eb],
        decls: 1,
        vars: 0,
        template: function(i, o) {
            i & 1 && qr(0, "router-outlet")
        },
        dependencies: [vm],
        encapsulation: 2
    });
    let t = e;
    return t
}
)();
function B8(t, e) {
    return t.providers && !t._injector && (t._injector = Bl(t.providers, e, `Route: ${t.path}`)),
    t._injector ?? e
}
function xm(t) {
    let e = t.children && t.children.map(xm)
      , n = e ? me(ee({}, t), {
        children: e
    }) : ee({}, t);
    return !n.component && !n.loadComponent && (e || n.loadChildren) && n.outlet && n.outlet !== Ne && (n.component = T8),
    n
}
function Kr(t) {
    return t.outlet || Ne
}
function R8(t, e) {
    let n = t.filter(r=>Kr(r) === e);
    return n.push(...t.filter(r=>Kr(r) !== e)),
    n
}
function Ic(t) {
    if (!t)
        return null;
    if (t.routeConfig?._injector)
        return t.routeConfig._injector;
    for (let e = t.parent; e; e = e.parent) {
        let n = e.routeConfig;
        if (n?._loadedInjector)
            return n._loadedInjector;
        if (n?._injector)
            return n._injector
    }
    return null
}
var F8 = (t,e,n,r)=>Ue(i=>(new lm(e,i.targetRouterState,i.currentRouterState,n,r).activate(t),
i))
  , lm = class {
    constructor(e, n, r, i, o) {
        this.routeReuseStrategy = e,
        this.futureState = n,
        this.currState = r,
        this.forwardEvent = i,
        this.inputBindingEnabled = o
    }
    activate(e) {
        let n = this.futureState._root
          , r = this.currState ? this.currState._root : null;
        this.deactivateChildRoutes(n, r, e),
        $g(this.futureState.root),
        this.activateChildRoutes(n, r, e)
    }
    deactivateChildRoutes(e, n, r) {
        let i = qs(n);
        e.children.forEach(o=>{
            let s = o.value.outlet;
            this.deactivateRoutes(o, i[s], r),
            delete i[s]
        }
        ),
        Object.values(i).forEach(o=>{
            this.deactivateRouteAndItsChildren(o, r)
        }
        )
    }
    deactivateRoutes(e, n, r) {
        let i = e.value
          , o = n ? n.value : null;
        if (i === o)
            if (i.component) {
                let s = r.getContext(i.outlet);
                s && this.deactivateChildRoutes(e, n, s.children)
            } else
                this.deactivateChildRoutes(e, n, r);
        else
            o && this.deactivateRouteAndItsChildren(n, r)
    }
    deactivateRouteAndItsChildren(e, n) {
        e.value.component && this.routeReuseStrategy.shouldDetach(e.value.snapshot) ? this.detachAndStoreRouteSubtree(e, n) : this.deactivateRouteAndOutlet(e, n)
    }
    detachAndStoreRouteSubtree(e, n) {
        let r = n.getContext(e.value.outlet)
          , i = r && e.value.component ? r.children : n
          , o = qs(e);
        for (let s of Object.values(o))
            this.deactivateRouteAndItsChildren(s, i);
        if (r && r.outlet) {
            let s = r.outlet.detach()
              , a = r.children.onOutletDeactivated();
            this.routeReuseStrategy.store(e.value.snapshot, {
                componentRef: s,
                route: e,
                contexts: a
            })
        }
    }
    deactivateRouteAndOutlet(e, n) {
        let r = n.getContext(e.value.outlet)
          , i = r && e.value.component ? r.children : n
          , o = qs(e);
        for (let s of Object.values(o))
            this.deactivateRouteAndItsChildren(s, i);
        r && (r.outlet && (r.outlet.deactivate(),
        r.children.onOutletDeactivated()),
        r.attachRef = null,
        r.route = null)
    }
    activateChildRoutes(e, n, r) {
        let i = qs(n);
        e.children.forEach(o=>{
            this.activateRoutes(o, i[o.value.outlet], r),
            this.forwardEvent(new im(o.value.snapshot))
        }
        ),
        e.children.length && this.forwardEvent(new nm(e.value.snapshot))
    }
    activateRoutes(e, n, r) {
        let i = e.value
          , o = n ? n.value : null;
        if ($g(i),
        i === o)
            if (i.component) {
                let s = r.getOrCreateContext(i.outlet);
                this.activateChildRoutes(e, n, s.children)
            } else
                this.activateChildRoutes(e, n, r);
        else if (i.component) {
            let s = r.getOrCreateContext(i.outlet);
            if (this.routeReuseStrategy.shouldAttach(i.snapshot)) {
                let a = this.routeReuseStrategy.retrieve(i.snapshot);
                this.routeReuseStrategy.store(i.snapshot, null),
                s.children.onOutletReAttached(a.contexts),
                s.attachRef = a.componentRef,
                s.route = a.route.value,
                s.outlet && s.outlet.attach(a.componentRef, a.route.value),
                $g(a.route.value),
                this.activateChildRoutes(e, null, s.children)
            } else {
                let a = Ic(i.snapshot);
                s.attachRef = null,
                s.route = i,
                s.injector = a,
                s.outlet && s.outlet.activateWith(i, s.injector),
                this.activateChildRoutes(e, null, s.children)
            }
        } else
            this.activateChildRoutes(e, null, r)
    }
}
  , ff = class {
    constructor(e) {
        this.path = e,
        this.route = this.path[this.path.length - 1]
    }
}
  , Gs = class {
    constructor(e, n) {
        this.component = e,
        this.route = n
    }
}
;
function N8(t, e, n) {
    let r = t._root
      , i = e ? e._root : null;
    return uc(r, i, n, [r.value])
}
function P8(t) {
    let e = t.routeConfig ? t.routeConfig.canActivateChild : null;
    return !e || e.length === 0 ? null : {
        node: t,
        guards: e
    }
}
function Qs(t, e) {
    let n = Symbol()
      , r = e.get(t, n);
    return r === n ? typeof t == "function" && !rw(t) ? t : e.get(t) : r
}
function uc(t, e, n, r, i={
    canDeactivateChecks: [],
    canActivateChecks: []
}) {
    let o = qs(e);
    return t.children.forEach(s=>{
        O8(s, o[s.value.outlet], n, r.concat([s.value]), i),
        delete o[s.value.outlet]
    }
    ),
    Object.entries(o).forEach(([s,a])=>hc(a, n.getContext(s), i)),
    i
}
function O8(t, e, n, r, i={
    canDeactivateChecks: [],
    canActivateChecks: []
}) {
    let o = t.value
      , s = e ? e.value : null
      , a = n ? n.getContext(t.value.outlet) : null;
    if (s && o.routeConfig === s.routeConfig) {
        let c = L8(s, o, o.routeConfig.runGuardsAndResolvers);
        c ? i.canActivateChecks.push(new ff(r)) : (o.data = s.data,
        o._resolvedData = s._resolvedData),
        o.component ? uc(t, e, a ? a.children : null, r, i) : uc(t, e, n, r, i),
        c && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new Gs(a.outlet.component,s))
    } else
        s && hc(e, a, i),
        i.canActivateChecks.push(new ff(r)),
        o.component ? uc(t, null, a ? a.children : null, r, i) : uc(t, null, n, r, i);
    return i
}
function L8(t, e, n) {
    if (typeof n == "function")
        return n(t, e);
    switch (n) {
    case "pathParamsChange":
        return !Uo(t.url, e.url);
    case "pathParamsOrQueryParamsChange":
        return !Uo(t.url, e.url) || !Gr(t.queryParams, e.queryParams);
    case "always":
        return !0;
    case "paramsOrQueryParamsChange":
        return !cm(t, e) || !Gr(t.queryParams, e.queryParams);
    case "paramsChange":
    default:
        return !cm(t, e)
    }
}
function hc(t, e, n) {
    let r = qs(t)
      , i = t.value;
    Object.entries(r).forEach(([o,s])=>{
        i.component ? e ? hc(s, e.children.getContext(o), n) : hc(s, null, n) : hc(s, e, n)
    }
    ),
    i.component ? e && e.outlet && e.outlet.isActivated ? n.canDeactivateChecks.push(new Gs(e.outlet.component,i)) : n.canDeactivateChecks.push(new Gs(null,i)) : n.canDeactivateChecks.push(new Gs(null,i))
}
function Ac(t) {
    return typeof t == "function"
}
function U8(t) {
    return typeof t == "boolean"
}
function V8(t) {
    return t && Ac(t.canLoad)
}
function j8(t) {
    return t && Ac(t.canActivate)
}
function $8(t) {
    return t && Ac(t.canActivateChild)
}
function H8(t) {
    return t && Ac(t.canDeactivate)
}
function z8(t) {
    return t && Ac(t.canMatch)
}
function CE(t) {
    return t instanceof ii || t?.name === "EmptyError"
}
var Ql = Symbol("INITIAL_VALUE");
function Xs() {
    return jn(t=>Ra(t.map(e=>e.pipe(si(1), A0(Ql)))).pipe(Ue(e=>{
        for (let n of e)
            if (n !== !0) {
                if (n === Ql)
                    return Ql;
                if (n === !1 || n instanceof qi)
                    return n
            }
        return !0
    }
    ), Vn(e=>e !== Ql), si(1)))
}
function q8(t, e) {
    return Zt(n=>{
        let {targetSnapshot: r, currentSnapshot: i, guards: {canActivateChecks: o, canDeactivateChecks: s}} = n;
        return s.length === 0 && o.length === 0 ? Ie(me(ee({}, n), {
            guardsResult: !0
        })) : W8(s, r, i, t).pipe(Zt(a=>a && U8(a) ? G8(r, o, t, e) : Ie(a)), Ue(a=>me(ee({}, n), {
            guardsResult: a
        })))
    }
    )
}
function W8(t, e, n, r) {
    return Mt(t).pipe(Zt(i=>Q8(i.component, i.route, n, e, r)), Pr(i=>i !== !0, !0))
}
function G8(t, e, n, r) {
    return Mt(e).pipe(oi(i=>vs(Y8(i.route.parent, r), K8(i.route, r), X8(t, i.path, n), Z8(t, i.route, n))), Pr(i=>i !== !0, !0))
}
function K8(t, e) {
    return t !== null && e && e(new rm(t)),
    Ie(!0)
}
function Y8(t, e) {
    return t !== null && e && e(new tm(t)),
    Ie(!0)
}
function Z8(t, e, n) {
    let r = e.routeConfig ? e.routeConfig.canActivate : null;
    if (!r || r.length === 0)
        return Ie(!0);
    let i = r.map(o=>Ru(()=>{
        let s = Ic(e) ?? n
          , a = Qs(o, s)
          , c = j8(a) ? a.canActivate(e, t) : Ar(s, ()=>a(e, t));
        return Yi(c).pipe(Pr())
    }
    ));
    return Ie(i).pipe(Xs())
}
function X8(t, e, n) {
    let r = e[e.length - 1]
      , o = e.slice(0, e.length - 1).reverse().map(s=>P8(s)).filter(s=>s !== null).map(s=>Ru(()=>{
        let a = s.guards.map(c=>{
            let u = Ic(s.node) ?? n
              , l = Qs(c, u)
              , d = $8(l) ? l.canActivateChild(r, t) : Ar(u, ()=>l(r, t));
            return Yi(d).pipe(Pr())
        }
        );
        return Ie(a).pipe(Xs())
    }
    ));
    return Ie(o).pipe(Xs())
}
function Q8(t, e, n, r, i) {
    let o = e && e.routeConfig ? e.routeConfig.canDeactivate : null;
    if (!o || o.length === 0)
        return Ie(!0);
    let s = o.map(a=>{
        let c = Ic(e) ?? i
          , u = Qs(a, c)
          , l = H8(u) ? u.canDeactivate(t, e, n, r) : Ar(c, ()=>u(t, e, n, r));
        return Yi(l).pipe(Pr())
    }
    );
    return Ie(s).pipe(Xs())
}
function J8(t, e, n, r) {
    let i = e.canLoad;
    if (i === void 0 || i.length === 0)
        return Ie(!0);
    let o = i.map(s=>{
        let a = Qs(s, t)
          , c = V8(a) ? a.canLoad(e, n) : Ar(t, ()=>a(e, n));
        return Yi(c)
    }
    );
    return Ie(o).pipe(Xs(), DE(r))
}
function DE(t) {
    return v0(an(e=>{
        if (Ys(e))
            throw wE(t, e)
    }
    ), Ue(e=>e === !0))
}
function eR(t, e, n, r) {
    let i = e.canMatch;
    if (!i || i.length === 0)
        return Ie(!0);
    let o = i.map(s=>{
        let a = Qs(s, t)
          , c = z8(a) ? a.canMatch(e, n) : Ar(t, ()=>a(e, n));
        return Yi(c)
    }
    );
    return Ie(o).pipe(Xs(), DE(r))
}
var bc = class {
    constructor(e) {
        this.segmentGroup = e || null
    }
}
  , df = class extends Error {
    constructor(e) {
        super(),
        this.urlTree = e
    }
}
;
function zs(t) {
    return ms(new bc(t))
}
function tR(t) {
    return ms(new we(4e3,!1))
}
function nR(t) {
    return ms(bE(!1, er.GuardRejected))
}
var fm = class {
    constructor(e, n) {
        this.urlSerializer = e,
        this.urlTree = n
    }
    lineralizeSegments(e, n) {
        let r = []
          , i = n.root;
        for (; ; ) {
            if (r = r.concat(i.segments),
            i.numberOfChildren === 0)
                return Ie(r);
            if (i.numberOfChildren > 1 || !i.children[Ne])
                return tR(e.redirectTo);
            i = i.children[Ne]
        }
    }
    applyRedirectCommands(e, n, r) {
        let i = this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), e, r);
        if (n.startsWith("/"))
            throw new df(i);
        return i
    }
    applyRedirectCreateUrlTree(e, n, r, i) {
        let o = this.createSegmentGroup(e, n.root, r, i);
        return new qi(o,this.createQueryParams(n.queryParams, this.urlTree.queryParams),n.fragment)
    }
    createQueryParams(e, n) {
        let r = {};
        return Object.entries(e).forEach(([i,o])=>{
            if (typeof o == "string" && o.startsWith(":")) {
                let a = o.substring(1);
                r[i] = n[a]
            } else
                r[i] = o
        }
        ),
        r
    }
    createSegmentGroup(e, n, r, i) {
        let o = this.createSegments(e, n.segments, r, i)
          , s = {};
        return Object.entries(n.children).forEach(([a,c])=>{
            s[a] = this.createSegmentGroup(e, c, r, i)
        }
        ),
        new pt(o,s)
    }
    createSegments(e, n, r, i) {
        return n.map(o=>o.path.startsWith(":") ? this.findPosParam(e, o, i) : this.findOrReturn(o, r))
    }
    findPosParam(e, n, r) {
        let i = r[n.path.substring(1)];
        if (!i)
            throw new we(4001,!1);
        return i
    }
    findOrReturn(e, n) {
        let r = 0;
        for (let i of n) {
            if (i.path === e.path)
                return n.splice(r),
                i;
            r++
        }
        return e
    }
}
  , dm = {
    matched: !1,
    consumedSegments: [],
    remainingSegments: [],
    parameters: {},
    positionalParamSegments: {}
};
function rR(t, e, n, r, i) {
    let o = wm(t, e, n);
    return o.matched ? (r = B8(e, r),
    eR(r, e, n, i).pipe(Ue(s=>s === !0 ? o : ee({}, dm)))) : Ie(o)
}
function wm(t, e, n) {
    if (e.path === "**")
        return iR(n);
    if (e.path === "")
        return e.pathMatch === "full" && (t.hasChildren() || n.length > 0) ? ee({}, dm) : {
            matched: !0,
            consumedSegments: [],
            remainingSegments: n,
            parameters: {},
            positionalParamSegments: {}
        };
    let i = (e.matcher || e8)(n, t, e);
    if (!i)
        return ee({}, dm);
    let o = {};
    Object.entries(i.posParams ?? {}).forEach(([a,c])=>{
        o[a] = c.path
    }
    );
    let s = i.consumed.length > 0 ? ee(ee({}, o), i.consumed[i.consumed.length - 1].parameters) : o;
    return {
        matched: !0,
        consumedSegments: i.consumed,
        remainingSegments: n.slice(i.consumed.length),
        parameters: s,
        positionalParamSegments: i.posParams ?? {}
    }
}
function iR(t) {
    return {
        matched: !0,
        parameters: t.length > 0 ? rE(t).parameters : {},
        consumedSegments: t,
        remainingSegments: [],
        positionalParamSegments: {}
    }
}
function Jb(t, e, n, r) {
    return n.length > 0 && aR(t, n, r) ? {
        segmentGroup: new pt(e,sR(r, new pt(n,t.children))),
        slicedSegments: []
    } : n.length === 0 && cR(t, n, r) ? {
        segmentGroup: new pt(t.segments,oR(t, n, r, t.children)),
        slicedSegments: n
    } : {
        segmentGroup: new pt(t.segments,t.children),
        slicedSegments: n
    }
}
function oR(t, e, n, r) {
    let i = {};
    for (let o of n)
        if (mf(t, e, o) && !r[Kr(o)]) {
            let s = new pt([],{});
            i[Kr(o)] = s
        }
    return ee(ee({}, r), i)
}
function sR(t, e) {
    let n = {};
    n[Ne] = e;
    for (let r of t)
        if (r.path === "" && Kr(r) !== Ne) {
            let i = new pt([],{});
            n[Kr(r)] = i
        }
    return n
}
function aR(t, e, n) {
    return n.some(r=>mf(t, e, r) && Kr(r) !== Ne)
}
function cR(t, e, n) {
    return n.some(r=>mf(t, e, r))
}
function mf(t, e, n) {
    return (t.hasChildren() || e.length > 0) && n.pathMatch === "full" ? !1 : n.path === ""
}
function uR(t, e, n, r) {
    return Kr(t) !== r && (r === Ne || !mf(e, n, t)) ? !1 : wm(e, t, n).matched
}
function lR(t, e, n) {
    return e.length === 0 && !t.children[n]
}
var hm = class {
}
;
function fR(t, e, n, r, i, o, s="emptyOnly") {
    return new pm(t,e,n,r,i,s,o).recognize()
}
var dR = 31
  , pm = class {
    constructor(e, n, r, i, o, s, a) {
        this.injector = e,
        this.configLoader = n,
        this.rootComponentType = r,
        this.config = i,
        this.urlTree = o,
        this.paramsInheritanceStrategy = s,
        this.urlSerializer = a,
        this.applyRedirects = new fm(this.urlSerializer,this.urlTree),
        this.absoluteRedirectCount = 0,
        this.allowRedirects = !0
    }
    noMatchError(e) {
        return new we(4002,`'${e.segmentGroup}'`)
    }
    recognize() {
        let e = Jb(this.urlTree.root, [], [], this.config).segmentGroup;
        return this.match(e).pipe(Ue(n=>{
            let r = new xc([],Object.freeze({}),Object.freeze(ee({}, this.urlTree.queryParams)),this.urlTree.fragment,{},Ne,this.rootComponentType,null,{})
              , i = new Jn(r,n)
              , o = new lf("",i)
              , s = x8(r, [], this.urlTree.queryParams, this.urlTree.fragment);
            return s.queryParams = this.urlTree.queryParams,
            o.url = this.urlSerializer.serialize(s),
            this.inheritParamsAndData(o._root, null),
            {
                state: o,
                tree: s
            }
        }
        ))
    }
    match(e) {
        return this.processSegmentGroup(this.injector, this.config, e, Ne).pipe(Fi(r=>{
            if (r instanceof df)
                return this.urlTree = r.urlTree,
                this.match(r.urlTree.root);
            throw r instanceof bc ? this.noMatchError(r) : r
        }
        ))
    }
    inheritParamsAndData(e, n) {
        let r = e.value
          , i = mm(r, n, this.paramsInheritanceStrategy);
        r.params = Object.freeze(i.params),
        r.data = Object.freeze(i.data),
        e.children.forEach(o=>this.inheritParamsAndData(o, r))
    }
    processSegmentGroup(e, n, r, i) {
        return r.segments.length === 0 && r.hasChildren() ? this.processChildren(e, n, r) : this.processSegment(e, n, r, r.segments, i, !0).pipe(Ue(o=>o instanceof Jn ? [o] : []))
    }
    processChildren(e, n, r) {
        let i = [];
        for (let o of Object.keys(r.children))
            o === "primary" ? i.unshift(o) : i.push(o);
        return Mt(i).pipe(oi(o=>{
            let s = r.children[o]
              , a = R8(n, o);
            return this.processSegmentGroup(e, a, s, o)
        }
        ), I0((o,s)=>(o.push(...s),
        o)), Ni(null), D0(), Zt(o=>{
            if (o === null)
                return zs(r);
            let s = IE(o);
            return hR(s),
            Ie(s)
        }
        ))
    }
    processSegment(e, n, r, i, o, s) {
        return Mt(n).pipe(oi(a=>this.processSegmentAgainstRoute(a._injector ?? e, n, a, r, i, o, s).pipe(Fi(c=>{
            if (c instanceof bc)
                return Ie(null);
            throw c
        }
        ))), Pr(a=>!!a), Fi(a=>{
            if (CE(a))
                return lR(r, i, o) ? Ie(new hm) : zs(r);
            throw a
        }
        ))
    }
    processSegmentAgainstRoute(e, n, r, i, o, s, a) {
        return uR(r, i, o, s) ? r.redirectTo === void 0 ? this.matchSegmentAgainstRoute(e, i, r, o, s) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(e, i, n, r, o, s) : zs(i) : zs(i)
    }
    expandSegmentAgainstRouteUsingRedirect(e, n, r, i, o, s) {
        let {matched: a, consumedSegments: c, positionalParamSegments: u, remainingSegments: l} = wm(n, i, o);
        if (!a)
            return zs(n);
        i.redirectTo.startsWith("/") && (this.absoluteRedirectCount++,
        this.absoluteRedirectCount > dR && (this.allowRedirects = !1));
        let d = this.applyRedirects.applyRedirectCommands(c, i.redirectTo, u);
        return this.applyRedirects.lineralizeSegments(i, d).pipe(Zt(y=>this.processSegment(e, r, n, y.concat(l), s, !1)))
    }
    matchSegmentAgainstRoute(e, n, r, i, o) {
        let s = rR(n, r, i, e, this.urlSerializer);
        return r.path === "**" && (n.children = {}),
        s.pipe(jn(a=>a.matched ? (e = r._injector ?? e,
        this.getChildConfig(e, r, i).pipe(jn(({routes: c})=>{
            let u = r._loadedInjector ?? e
              , {consumedSegments: l, remainingSegments: d, parameters: y} = a
              , v = new xc(l,y,Object.freeze(ee({}, this.urlTree.queryParams)),this.urlTree.fragment,gR(r),Kr(r),r.component ?? r._loadedComponent ?? null,r,mR(r))
              , {segmentGroup: E, slicedSegments: D} = Jb(n, l, d, c);
            if (D.length === 0 && E.hasChildren())
                return this.processChildren(u, c, E).pipe(Ue(w=>w === null ? null : new Jn(v,w)));
            if (c.length === 0 && D.length === 0)
                return Ie(new Jn(v,[]));
            let S = Kr(r) === o;
            return this.processSegment(u, c, E, D, S ? Ne : o, !0).pipe(Ue(w=>new Jn(v,w instanceof Jn ? [w] : [])))
        }
        ))) : zs(n)))
    }
    getChildConfig(e, n, r) {
        return n.children ? Ie({
            routes: n.children,
            injector: e
        }) : n.loadChildren ? n._loadedRoutes !== void 0 ? Ie({
            routes: n._loadedRoutes,
            injector: n._loadedInjector
        }) : J8(e, n, r, this.urlSerializer).pipe(Zt(i=>i ? this.configLoader.loadChildren(e, n).pipe(an(o=>{
            n._loadedRoutes = o.routes,
            n._loadedInjector = o.injector
        }
        )) : nR(n))) : Ie({
            routes: [],
            injector: e
        })
    }
}
;
function hR(t) {
    t.sort((e,n)=>e.value.outlet === Ne ? -1 : n.value.outlet === Ne ? 1 : e.value.outlet.localeCompare(n.value.outlet))
}
function pR(t) {
    let e = t.value.routeConfig;
    return e && e.path === ""
}
function IE(t) {
    let e = []
      , n = new Set;
    for (let r of t) {
        if (!pR(r)) {
            e.push(r);
            continue
        }
        let i = e.find(o=>r.value.routeConfig === o.value.routeConfig);
        i !== void 0 ? (i.children.push(...r.children),
        n.add(i)) : e.push(r)
    }
    for (let r of n) {
        let i = IE(r.children);
        e.push(new Jn(r.value,i))
    }
    return e.filter(r=>!n.has(r))
}
function gR(t) {
    return t.data || {}
}
function mR(t) {
    return t.resolve || {}
}
function yR(t, e, n, r, i, o) {
    return Zt(s=>fR(t, e, n, r, s.extractedUrl, i, o).pipe(Ue(({state: a, tree: c})=>me(ee({}, s), {
        targetSnapshot: a,
        urlAfterRedirects: c
    }))))
}
function vR(t, e) {
    return Zt(n=>{
        let {targetSnapshot: r, guards: {canActivateChecks: i}} = n;
        if (!i.length)
            return Ie(n);
        let o = new Set(i.map(c=>c.route))
          , s = new Set;
        for (let c of o)
            if (!s.has(c))
                for (let u of AE(c))
                    s.add(u);
        let a = 0;
        return Mt(s).pipe(oi(c=>o.has(c) ? xR(c, r, t, e) : (c.data = mm(c, c.parent, t).resolve,
        Ie(void 0))), an(()=>a++), xs(1), Zt(c=>a === s.size ? Ie(n) : Yn))
    }
    )
}
function AE(t) {
    let e = t.children.map(n=>AE(n)).flat();
    return [t, ...e]
}
function xR(t, e, n, r) {
    let i = t.routeConfig
      , o = t._resolve;
    return i?.title !== void 0 && !vE(i) && (o[Ec] = i.title),
    wR(o, t, e, r).pipe(Ue(s=>(t._resolvedData = s,
    t.data = mm(t, t.parent, n).resolve,
    null)))
}
function wR(t, e, n, r) {
    let i = qg(t);
    if (i.length === 0)
        return Ie({});
    let o = {};
    return Mt(i).pipe(Zt(s=>bR(t[s], e, n, r).pipe(Pr(), an(a=>{
        o[s] = a
    }
    ))), xs(1), C0(o), Fi(s=>CE(s) ? Yn : ms(s)))
}
function bR(t, e, n, r) {
    let i = Ic(e) ?? r
      , o = Qs(t, i)
      , s = o.resolve ? o.resolve(e, n) : Ar(i, ()=>o(e, n));
    return Yi(s)
}
function Hg(t) {
    return jn(e=>{
        let n = t(e);
        return n ? Mt(n).pipe(Ue(()=>e)) : Ie(e)
    }
    )
}
var _E = (()=>{
    let e = class e {
        buildTitle(r) {
            let i, o = r.root;
            for (; o !== void 0; )
                i = this.getResolvedTitleForRoute(o) ?? i,
                o = o.children.find(s=>s.outlet === Ne);
            return i
        }
        getResolvedTitleForRoute(r) {
            return r.data[Ec]
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>ie(ER),
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , ER = (()=>{
    let e = class e extends _E {
        constructor(r) {
            super(),
            this.title = r
        }
        updateTitle(r) {
            let i = this.buildTitle(r);
            i !== void 0 && this.title.setTitle(i)
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Wb))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , _c = new be("",{
    providedIn: "root",
    factory: ()=>({})
})
  , hf = new be("")
  , bm = (()=>{
    let e = class e {
        constructor() {
            this.componentLoaders = new WeakMap,
            this.childrenLoaders = new WeakMap,
            this.compiler = ie(Ul)
        }
        loadComponent(r) {
            if (this.componentLoaders.get(r))
                return this.componentLoaders.get(r);
            if (r._loadedComponent)
                return Ie(r._loadedComponent);
            this.onLoadStartListener && this.onLoadStartListener(r);
            let i = Yi(r.loadComponent()).pipe(Ue(SE), an(s=>{
                this.onLoadEndListener && this.onLoadEndListener(r),
                r._loadedComponent = s
            }
            ), Pi(()=>{
                this.componentLoaders.delete(r)
            }
            ))
              , o = new gs(i,()=>new Fn).pipe(ps());
            return this.componentLoaders.set(r, o),
            o
        }
        loadChildren(r, i) {
            if (this.childrenLoaders.get(i))
                return this.childrenLoaders.get(i);
            if (i._loadedRoutes)
                return Ie({
                    routes: i._loadedRoutes,
                    injector: i._loadedInjector
                });
            this.onLoadStartListener && this.onLoadStartListener(i);
            let s = CR(i, this.compiler, r, this.onLoadEndListener).pipe(Pi(()=>{
                this.childrenLoaders.delete(i)
            }
            ))
              , a = new gs(s,()=>new Fn).pipe(ps());
            return this.childrenLoaders.set(i, a),
            a
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function CR(t, e, n, r) {
    return Yi(t.loadChildren()).pipe(Ue(SE), Zt(i=>i instanceof Wa || Array.isArray(i) ? Ie(i) : Mt(e.compileModuleAsync(i))), Ue(i=>{
        r && r(t);
        let o, s, a = !1;
        return Array.isArray(i) ? (s = i,
        a = !0) : (o = i.create(n).injector,
        s = o.get(hf, [], {
            optional: !0,
            self: !0
        }).flat()),
        {
            routes: s.map(xm),
            injector: o
        }
    }
    ))
}
function DR(t) {
    return t && typeof t == "object" && "default"in t
}
function SE(t) {
    return DR(t) ? t.default : t
}
var Em = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>ie(IR),
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , IR = (()=>{
    let e = class e {
        shouldProcessUrl(r) {
            return !0
        }
        extract(r) {
            return r
        }
        merge(r, i) {
            return r
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , ME = new be("")
  , kE = new be("");
function AR(t, e, n) {
    let r = t.get(kE)
      , i = t.get(Dn);
    return t.get(wt).runOutsideAngular(()=>{
        if (!i.startViewTransition || r.skipNextTransition)
            return r.skipNextTransition = !1,
            new Promise(u=>setTimeout(u));
        let o, s = new Promise(u=>{
            o = u
        }
        ), a = i.startViewTransition(()=>(o(),
        _R(t))), {onViewTransitionCreated: c} = r;
        return c && Ar(t, ()=>c({
            transition: a,
            from: e,
            to: n
        })),
        s
    }
    )
}
function _R(t) {
    return new Promise(e=>{
        Tl(e, {
            injector: t
        })
    }
    )
}
var Cm = (()=>{
    let e = class e {
        get hasRequestedNavigation() {
            return this.navigationId !== 0
        }
        constructor() {
            this.currentNavigation = null,
            this.currentTransition = null,
            this.lastSuccessfulNavigation = null,
            this.events = new Fn,
            this.transitionAbortSubject = new Fn,
            this.configLoader = ie(bm),
            this.environmentInjector = ie(wn),
            this.urlSerializer = ie(Cc),
            this.rootContexts = ie(Dc),
            this.location = ie($s),
            this.inputBindingEnabled = ie(gf, {
                optional: !0
            }) !== null,
            this.titleStrategy = ie(_E),
            this.options = ie(_c, {
                optional: !0
            }) || {},
            this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly",
            this.urlHandlingStrategy = ie(Em),
            this.createViewTransition = ie(ME, {
                optional: !0
            }),
            this.navigationId = 0,
            this.afterPreactivation = ()=>Ie(void 0),
            this.rootComponentType = null;
            let r = o=>this.events.next(new Jg(o))
              , i = o=>this.events.next(new em(o));
            this.configLoader.onLoadEndListener = i,
            this.configLoader.onLoadStartListener = r
        }
        complete() {
            this.transitions?.complete()
        }
        handleNavigationRequest(r) {
            let i = ++this.navigationId;
            this.transitions?.next(me(ee(ee({}, this.transitions.value), r), {
                id: i
            }))
        }
        setupNavigations(r, i, o) {
            return this.transitions = new dn({
                id: 0,
                currentUrlTree: i,
                currentRawUrl: i,
                extractedUrl: this.urlHandlingStrategy.extract(i),
                urlAfterRedirects: this.urlHandlingStrategy.extract(i),
                rawUrl: i,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(!0),
                source: dc,
                restoredState: null,
                currentSnapshot: o.snapshot,
                targetSnapshot: null,
                currentRouterState: o,
                targetRouterState: null,
                guards: {
                    canActivateChecks: [],
                    canDeactivateChecks: []
                },
                guardsResult: null
            }),
            this.transitions.pipe(Vn(s=>s.id !== 0), Ue(s=>me(ee({}, s), {
                extractedUrl: this.urlHandlingStrategy.extract(s.rawUrl)
            })), jn(s=>{
                let a = !1
                  , c = !1;
                return Ie(s).pipe(jn(u=>{
                    if (this.navigationId > s.id)
                        return this.cancelNavigationTransition(s, "", er.SupersededByNewNavigation),
                        Yn;
                    this.currentTransition = s,
                    this.currentNavigation = {
                        id: u.id,
                        initialUrl: u.rawUrl,
                        extractedUrl: u.extractedUrl,
                        trigger: u.source,
                        extras: u.extras,
                        previousNavigation: this.lastSuccessfulNavigation ? me(ee({}, this.lastSuccessfulNavigation), {
                            previousNavigation: null
                        }) : null
                    };
                    let l = !r.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl()
                      , d = u.extras.onSameUrlNavigation ?? r.onSameUrlNavigation;
                    if (!l && d !== "reload") {
                        let y = "";
                        return this.events.next(new Gi(u.id,this.urlSerializer.serialize(u.rawUrl),y,of.IgnoredSameUrlNavigation)),
                        u.resolve(null),
                        Yn
                    }
                    if (this.urlHandlingStrategy.shouldProcessUrl(u.rawUrl))
                        return Ie(u).pipe(jn(y=>{
                            let v = this.transitions?.getValue();
                            return this.events.next(new Zs(y.id,this.urlSerializer.serialize(y.extractedUrl),y.source,y.restoredState)),
                            v !== this.transitions?.getValue() ? Yn : Promise.resolve(y)
                        }
                        ), yR(this.environmentInjector, this.configLoader, this.rootComponentType, r.config, this.urlSerializer, this.paramsInheritanceStrategy), an(y=>{
                            s.targetSnapshot = y.targetSnapshot,
                            s.urlAfterRedirects = y.urlAfterRedirects,
                            this.currentNavigation = me(ee({}, this.currentNavigation), {
                                finalUrl: y.urlAfterRedirects
                            });
                            let v = new sf(y.id,this.urlSerializer.serialize(y.extractedUrl),this.urlSerializer.serialize(y.urlAfterRedirects),y.targetSnapshot);
                            this.events.next(v)
                        }
                        ));
                    if (l && this.urlHandlingStrategy.shouldProcessUrl(u.currentRawUrl)) {
                        let {id: y, extractedUrl: v, source: E, restoredState: D, extras: S} = u
                          , w = new Zs(y,this.urlSerializer.serialize(v),E,D);
                        this.events.next(w);
                        let M = mE(this.rootComponentType).snapshot;
                        return this.currentTransition = s = me(ee({}, u), {
                            targetSnapshot: M,
                            urlAfterRedirects: v,
                            extras: me(ee({}, S), {
                                skipLocationChange: !1,
                                replaceUrl: !1
                            })
                        }),
                        this.currentNavigation.finalUrl = v,
                        Ie(s)
                    } else {
                        let y = "";
                        return this.events.next(new Gi(u.id,this.urlSerializer.serialize(u.extractedUrl),y,of.IgnoredByUrlHandlingStrategy)),
                        u.resolve(null),
                        Yn
                    }
                }
                ), an(u=>{
                    let l = new Yg(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);
                    this.events.next(l)
                }
                ), Ue(u=>(this.currentTransition = s = me(ee({}, u), {
                    guards: N8(u.targetSnapshot, u.currentSnapshot, this.rootContexts)
                }),
                s)), q8(this.environmentInjector, u=>this.events.next(u)), an(u=>{
                    if (s.guardsResult = u.guardsResult,
                    Ys(u.guardsResult))
                        throw wE(this.urlSerializer, u.guardsResult);
                    let l = new Zg(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot,!!u.guardsResult);
                    this.events.next(l)
                }
                ), Vn(u=>u.guardsResult ? !0 : (this.cancelNavigationTransition(u, "", er.GuardRejected),
                !1)), Hg(u=>{
                    if (u.guards.canActivateChecks.length)
                        return Ie(u).pipe(an(l=>{
                            let d = new Xg(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);
                            this.events.next(d)
                        }
                        ), jn(l=>{
                            let d = !1;
                            return Ie(l).pipe(vR(this.paramsInheritanceStrategy, this.environmentInjector), an({
                                next: ()=>d = !0,
                                complete: ()=>{
                                    d || this.cancelNavigationTransition(l, "", er.NoDataFromResolver)
                                }
                            }))
                        }
                        ), an(l=>{
                            let d = new Qg(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);
                            this.events.next(d)
                        }
                        ))
                }
                ), Hg(u=>{
                    let l = d=>{
                        let y = [];
                        d.routeConfig?.loadComponent && !d.routeConfig._loadedComponent && y.push(this.configLoader.loadComponent(d.routeConfig).pipe(an(v=>{
                            d.component = v
                        }
                        ), Ue(()=>{}
                        )));
                        for (let v of d.children)
                            y.push(...l(v));
                        return y
                    }
                    ;
                    return Ra(l(u.targetSnapshot.root)).pipe(Ni(null), si(1))
                }
                ), Hg(()=>this.afterPreactivation()), jn(()=>{
                    let {currentSnapshot: u, targetSnapshot: l} = s
                      , d = this.createViewTransition?.(this.environmentInjector, u.root, l.root);
                    return d ? Mt(d).pipe(Ue(()=>s)) : Ie(s)
                }
                ), Ue(u=>{
                    let l = _8(r.routeReuseStrategy, u.targetSnapshot, u.currentRouterState);
                    return this.currentTransition = s = me(ee({}, u), {
                        targetRouterState: l
                    }),
                    this.currentNavigation.targetRouterState = l,
                    s
                }
                ), an(()=>{
                    this.events.next(new yc)
                }
                ), F8(this.rootContexts, r.routeReuseStrategy, u=>this.events.next(u), this.inputBindingEnabled), si(1), an({
                    next: u=>{
                        a = !0,
                        this.lastSuccessfulNavigation = this.currentNavigation,
                        this.events.next(new gi(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects))),
                        this.titleStrategy?.updateTitle(u.targetRouterState.snapshot),
                        u.resolve(!0)
                    }
                    ,
                    complete: ()=>{
                        a = !0
                    }
                }), _0(this.transitionAbortSubject.pipe(an(u=>{
                    throw u
                }
                ))), Pi(()=>{
                    !a && !c && this.cancelNavigationTransition(s, "", er.SupersededByNewNavigation),
                    this.currentTransition?.id === s.id && (this.currentNavigation = null,
                    this.currentTransition = null)
                }
                ), Fi(u=>{
                    if (c = !0,
                    EE(u))
                        this.events.next(new Wi(s.id,this.urlSerializer.serialize(s.extractedUrl),u.message,u.cancellationCode)),
                        k8(u) ? this.events.next(new vc(u.url)) : s.resolve(!1);
                    else {
                        this.events.next(new mc(s.id,this.urlSerializer.serialize(s.extractedUrl),u,s.targetSnapshot ?? void 0));
                        try {
                            s.resolve(r.errorHandler(u))
                        } catch (l) {
                            this.options.resolveNavigationPromiseOnError ? s.resolve(!1) : s.reject(l)
                        }
                    }
                    return Yn
                }
                ))
            }
            ))
        }
        cancelNavigationTransition(r, i, o) {
            let s = new Wi(r.id,this.urlSerializer.serialize(r.extractedUrl),i,o);
            this.events.next(s),
            r.resolve(!1)
        }
        isUpdatingInternalState() {
            return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString()
        }
        isUpdatedBrowserUrl() {
            return this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))).toString() !== this.currentTransition?.extractedUrl.toString() && !this.currentTransition?.extras.skipLocationChange
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function SR(t) {
    return t !== dc
}
var MR = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>ie(kR),
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , gm = class {
    shouldDetach(e) {
        return !1
    }
    store(e, n) {}
    shouldAttach(e) {
        return !1
    }
    retrieve(e) {
        return null
    }
    shouldReuseRoute(e, n) {
        return e.routeConfig === n.routeConfig
    }
}
  , kR = (()=>{
    let e = class e extends gm {
    }
    ;
    e.\u0275fac = (()=>{
        let r;
        return function(o) {
            return (r || (r = wl(e)))(o || e)
        }
    }
    )(),
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , TE = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: ()=>ie(TR),
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , TR = (()=>{
    let e = class e extends TE {
        constructor() {
            super(...arguments),
            this.location = ie($s),
            this.urlSerializer = ie(Cc),
            this.options = ie(_c, {
                optional: !0
            }) || {},
            this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace",
            this.urlHandlingStrategy = ie(Em),
            this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred",
            this.currentUrlTree = new qi,
            this.rawUrlTree = this.currentUrlTree,
            this.currentPageId = 0,
            this.lastSuccessfulId = -1,
            this.routerState = mE(null),
            this.stateMemento = this.createStateMemento()
        }
        getCurrentUrlTree() {
            return this.currentUrlTree
        }
        getRawUrlTree() {
            return this.rawUrlTree
        }
        restoredState() {
            return this.location.getState()
        }
        get browserPageId() {
            return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState()?.\u0275routerPageId ?? this.currentPageId
        }
        getRouterState() {
            return this.routerState
        }
        createStateMemento() {
            return {
                rawUrlTree: this.rawUrlTree,
                currentUrlTree: this.currentUrlTree,
                routerState: this.routerState
            }
        }
        registerNonRouterCurrentEntryChangeListener(r) {
            return this.location.subscribe(i=>{
                i.type === "popstate" && r(i.url, i.state)
            }
            )
        }
        handleRouterEvent(r, i) {
            if (r instanceof Zs)
                this.stateMemento = this.createStateMemento();
            else if (r instanceof Gi)
                this.rawUrlTree = i.initialUrl;
            else if (r instanceof sf) {
                if (this.urlUpdateStrategy === "eager" && !i.extras.skipLocationChange) {
                    let o = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl);
                    this.setBrowserUrl(o, i)
                }
            } else
                r instanceof yc ? (this.currentUrlTree = i.finalUrl,
                this.rawUrlTree = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl),
                this.routerState = i.targetRouterState,
                this.urlUpdateStrategy === "deferred" && (i.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, i))) : r instanceof Wi && (r.code === er.GuardRejected || r.code === er.NoDataFromResolver) ? this.restoreHistory(i) : r instanceof mc ? this.restoreHistory(i, !0) : r instanceof gi && (this.lastSuccessfulId = r.id,
                this.currentPageId = this.browserPageId)
        }
        setBrowserUrl(r, i) {
            let o = this.urlSerializer.serialize(r);
            if (this.location.isCurrentPathEqualTo(o) || i.extras.replaceUrl) {
                let s = this.browserPageId
                  , a = ee(ee({}, i.extras.state), this.generateNgRouterState(i.id, s));
                this.location.replaceState(o, "", a)
            } else {
                let s = ee(ee({}, i.extras.state), this.generateNgRouterState(i.id, this.browserPageId + 1));
                this.location.go(o, "", s)
            }
        }
        restoreHistory(r, i=!1) {
            if (this.canceledNavigationResolution === "computed") {
                let o = this.browserPageId
                  , s = this.currentPageId - o;
                s !== 0 ? this.location.historyGo(s) : this.currentUrlTree === r.finalUrl && s === 0 && (this.resetState(r),
                this.resetUrlToCurrentUrlTree())
            } else
                this.canceledNavigationResolution === "replace" && (i && this.resetState(r),
                this.resetUrlToCurrentUrlTree())
        }
        resetState(r) {
            this.routerState = this.stateMemento.routerState,
            this.currentUrlTree = this.stateMemento.currentUrlTree,
            this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, r.finalUrl ?? this.rawUrlTree)
        }
        resetUrlToCurrentUrlTree() {
            this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId))
        }
        generateNgRouterState(r, i) {
            return this.canceledNavigationResolution === "computed" ? {
                navigationId: r,
                \u0275routerPageId: i
            } : {
                navigationId: r
            }
        }
    }
    ;
    e.\u0275fac = (()=>{
        let r;
        return function(o) {
            return (r || (r = wl(e)))(o || e)
        }
    }
    )(),
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , lc = function(t) {
    return t[t.COMPLETE = 0] = "COMPLETE",
    t[t.FAILED = 1] = "FAILED",
    t[t.REDIRECTING = 2] = "REDIRECTING",
    t
}(lc || {});
function BE(t, e) {
    t.events.pipe(Vn(n=>n instanceof gi || n instanceof Wi || n instanceof mc || n instanceof Gi), Ue(n=>n instanceof gi || n instanceof Gi ? lc.COMPLETE : (n instanceof Wi ? n.code === er.Redirect || n.code === er.SupersededByNewNavigation : !1) ? lc.REDIRECTING : lc.FAILED), Vn(n=>n !== lc.REDIRECTING), si(1)).subscribe(()=>{
        e()
    }
    )
}
function BR(t) {
    throw t
}
var RR = {
    paths: "exact",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "exact"
}
  , FR = {
    paths: "subset",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "subset"
}
  , Vo = (()=>{
    let e = class e {
        get currentUrlTree() {
            return this.stateManager.getCurrentUrlTree()
        }
        get rawUrlTree() {
            return this.stateManager.getRawUrlTree()
        }
        get events() {
            return this._events
        }
        get routerState() {
            return this.stateManager.getRouterState()
        }
        constructor() {
            this.disposed = !1,
            this.isNgZoneEnabled = !1,
            this.console = ie(Fl),
            this.stateManager = ie(TE),
            this.options = ie(_c, {
                optional: !0
            }) || {},
            this.pendingTasks = ie(Ro),
            this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred",
            this.navigationTransitions = ie(Cm),
            this.urlSerializer = ie(Cc),
            this.location = ie($s),
            this.urlHandlingStrategy = ie(Em),
            this._events = new Fn,
            this.errorHandler = this.options.errorHandler || BR,
            this.navigated = !1,
            this.routeReuseStrategy = ie(MR),
            this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore",
            this.config = ie(hf, {
                optional: !0
            })?.flat() ?? [],
            this.componentInputBindingEnabled = !!ie(gf, {
                optional: !0
            }),
            this.eventsSubscription = new en,
            this.isNgZoneEnabled = ie(wt)instanceof wt && wt.isInAngularZone(),
            this.resetConfig(this.config),
            this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({
                error: r=>{
                    this.console.warn(r)
                }
            }),
            this.subscribeToNavigationEvents()
        }
        subscribeToNavigationEvents() {
            let r = this.navigationTransitions.events.subscribe(i=>{
                try {
                    let o = this.navigationTransitions.currentTransition
                      , s = this.navigationTransitions.currentNavigation;
                    if (o !== null && s !== null) {
                        if (this.stateManager.handleRouterEvent(i, s),
                        i instanceof Wi && i.code !== er.Redirect && i.code !== er.SupersededByNewNavigation)
                            this.navigated = !0;
                        else if (i instanceof gi)
                            this.navigated = !0;
                        else if (i instanceof vc) {
                            let a = this.urlHandlingStrategy.merge(i.url, o.currentRawUrl)
                              , c = {
                                info: o.extras.info,
                                skipLocationChange: o.extras.skipLocationChange,
                                replaceUrl: this.urlUpdateStrategy === "eager" || SR(o.source)
                            };
                            this.scheduleNavigation(a, dc, null, c, {
                                resolve: o.resolve,
                                reject: o.reject,
                                promise: o.promise
                            })
                        }
                    }
                    PR(i) && this._events.next(i)
                } catch (o) {
                    this.navigationTransitions.transitionAbortSubject.next(o)
                }
            }
            );
            this.eventsSubscription.add(r)
        }
        resetRootComponentType(r) {
            this.routerState.root.component = r,
            this.navigationTransitions.rootComponentType = r
        }
        initialNavigation() {
            this.setUpLocationChangeListener(),
            this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), dc, this.stateManager.restoredState())
        }
        setUpLocationChangeListener() {
            this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((r,i)=>{
                setTimeout(()=>{
                    this.navigateToSyncWithBrowser(r, "popstate", i)
                }
                , 0)
            }
            )
        }
        navigateToSyncWithBrowser(r, i, o) {
            let s = {
                replaceUrl: !0
            }
              , a = o?.navigationId ? o : null;
            if (o) {
                let u = ee({}, o);
                delete u.navigationId,
                delete u.\u0275routerPageId,
                Object.keys(u).length !== 0 && (s.state = u)
            }
            let c = this.parseUrl(r);
            this.scheduleNavigation(c, i, a, s)
        }
        get url() {
            return this.serializeUrl(this.currentUrlTree)
        }
        getCurrentNavigation() {
            return this.navigationTransitions.currentNavigation
        }
        get lastSuccessfulNavigation() {
            return this.navigationTransitions.lastSuccessfulNavigation
        }
        resetConfig(r) {
            this.config = r.map(xm),
            this.navigated = !1
        }
        ngOnDestroy() {
            this.dispose()
        }
        dispose() {
            this.navigationTransitions.complete(),
            this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),
            this.nonRouterCurrentEntryChangeSubscription = void 0),
            this.disposed = !0,
            this.eventsSubscription.unsubscribe()
        }
        createUrlTree(r, i={}) {
            let {relativeTo: o, queryParams: s, fragment: a, queryParamsHandling: c, preserveFragment: u} = i
              , l = u ? this.currentUrlTree.fragment : a
              , d = null;
            switch (c) {
            case "merge":
                d = ee(ee({}, this.currentUrlTree.queryParams), s);
                break;
            case "preserve":
                d = this.currentUrlTree.queryParams;
                break;
            default:
                d = s || null
            }
            d !== null && (d = this.removeEmptyProps(d));
            let y;
            try {
                let v = o ? o.snapshot : this.routerState.snapshot.root;
                y = dE(v)
            } catch {
                (typeof r[0] != "string" || !r[0].startsWith("/")) && (r = []),
                y = this.currentUrlTree.root
            }
            return hE(y, r, d, l ?? null)
        }
        navigateByUrl(r, i={
            skipLocationChange: !1
        }) {
            let o = Ys(r) ? r : this.parseUrl(r)
              , s = this.urlHandlingStrategy.merge(o, this.rawUrlTree);
            return this.scheduleNavigation(s, dc, null, i)
        }
        navigate(r, i={
            skipLocationChange: !1
        }) {
            return NR(r),
            this.navigateByUrl(this.createUrlTree(r, i), i)
        }
        serializeUrl(r) {
            return this.urlSerializer.serialize(r)
        }
        parseUrl(r) {
            try {
                return this.urlSerializer.parse(r)
            } catch {
                return this.urlSerializer.parse("/")
            }
        }
        isActive(r, i) {
            let o;
            if (i === !0 ? o = ee({}, RR) : i === !1 ? o = ee({}, FR) : o = i,
            Ys(r))
                return Kb(this.currentUrlTree, r, o);
            let s = this.parseUrl(r);
            return Kb(this.currentUrlTree, s, o)
        }
        removeEmptyProps(r) {
            return Object.entries(r).reduce((i,[o,s])=>(s != null && (i[o] = s),
            i), {})
        }
        scheduleNavigation(r, i, o, s, a) {
            if (this.disposed)
                return Promise.resolve(!1);
            let c, u, l;
            a ? (c = a.resolve,
            u = a.reject,
            l = a.promise) : l = new Promise((y,v)=>{
                c = y,
                u = v
            }
            );
            let d = this.pendingTasks.add();
            return BE(this, ()=>{
                queueMicrotask(()=>this.pendingTasks.remove(d))
            }
            ),
            this.navigationTransitions.handleNavigationRequest({
                source: i,
                restoredState: o,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                rawUrl: r,
                extras: s,
                resolve: c,
                reject: u,
                promise: l,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState
            }),
            l.catch(y=>Promise.reject(y))
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function NR(t) {
    for (let e = 0; e < t.length; e++)
        if (t[e] == null)
            throw new we(4008,!1)
}
function PR(t) {
    return !(t instanceof yc) && !(t instanceof vc)
}
var pf = class {
}
;
var OR = (()=>{
    let e = class e {
        constructor(r, i, o, s, a) {
            this.router = r,
            this.injector = o,
            this.preloadingStrategy = s,
            this.loader = a
        }
        setUpPreloading() {
            this.subscription = this.router.events.pipe(Vn(r=>r instanceof gi), oi(()=>this.preload())).subscribe(()=>{}
            )
        }
        preload() {
            return this.processRoutes(this.injector, this.router.config)
        }
        ngOnDestroy() {
            this.subscription && this.subscription.unsubscribe()
        }
        processRoutes(r, i) {
            let o = [];
            for (let s of i) {
                s.providers && !s._injector && (s._injector = Bl(s.providers, r, `Route: ${s.path}`));
                let a = s._injector ?? r
                  , c = s._loadedInjector ?? a;
                (s.loadChildren && !s._loadedRoutes && s.canLoad === void 0 || s.loadComponent && !s._loadedComponent) && o.push(this.preloadConfig(a, s)),
                (s.children || s._loadedRoutes) && o.push(this.processRoutes(c, s.children ?? s._loadedRoutes))
            }
            return Mt(o).pipe(ys())
        }
        preloadConfig(r, i) {
            return this.preloadingStrategy.preload(i, ()=>{
                let o;
                i.loadChildren && i.canLoad === void 0 ? o = this.loader.loadChildren(r, i) : o = Ie(null);
                let s = o.pipe(Zt(a=>a === null ? Ie(void 0) : (i._loadedRoutes = a.routes,
                i._loadedInjector = a.injector,
                this.processRoutes(a.injector ?? r, a.routes))));
                if (i.loadComponent && !i._loadedComponent) {
                    let a = this.loader.loadComponent(i);
                    return Mt([s, a]).pipe(ys())
                } else
                    return s
            }
            )
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(Vo),ve(Ul),ve(wn),ve(pf),ve(bm))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)()
  , RE = new be("")
  , LR = (()=>{
    let e = class e {
        constructor(r, i, o, s, a={}) {
            this.urlSerializer = r,
            this.transitions = i,
            this.viewportScroller = o,
            this.zone = s,
            this.options = a,
            this.lastId = 0,
            this.lastSource = "imperative",
            this.restoredId = 0,
            this.store = {},
            this.environmentInjector = ie(wn),
            a.scrollPositionRestoration ||= "disabled",
            a.anchorScrolling ||= "disabled"
        }
        init() {
            this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.setHistoryScrollRestoration("manual"),
            this.routerEventsSubscription = this.createScrollEvents(),
            this.scrollEventsSubscription = this.consumeScrollEvents()
        }
        createScrollEvents() {
            return this.transitions.events.subscribe(r=>{
                r instanceof Zs ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(),
                this.lastSource = r.navigationTrigger,
                this.restoredId = r.restoredState ? r.restoredState.navigationId : 0) : r instanceof gi ? (this.lastId = r.id,
                this.scheduleScrollEvent(r, this.urlSerializer.parse(r.urlAfterRedirects).fragment)) : r instanceof Gi && r.code === of.IgnoredSameUrlNavigation && (this.lastSource = void 0,
                this.restoredId = 0,
                this.scheduleScrollEvent(r, this.urlSerializer.parse(r.url).fragment))
            }
            )
        }
        consumeScrollEvents() {
            return this.transitions.events.subscribe(r=>{
                r instanceof af && (r.position ? this.options.scrollPositionRestoration === "top" ? this.viewportScroller.scrollToPosition([0, 0]) : this.options.scrollPositionRestoration === "enabled" && this.viewportScroller.scrollToPosition(r.position) : r.anchor && this.options.anchorScrolling === "enabled" ? this.viewportScroller.scrollToAnchor(r.anchor) : this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.scrollToPosition([0, 0]))
            }
            )
        }
        scheduleScrollEvent(r, i) {
            this.zone.runOutsideAngular(()=>$(this, null, function*() {
                yield new Promise(o=>{
                    setTimeout(()=>{
                        o()
                    }
                    ),
                    Tl(()=>{
                        o()
                    }
                    , {
                        injector: this.environmentInjector
                    })
                }
                ),
                this.zone.run(()=>{
                    this.transitions.events.next(new af(r,this.lastSource === "popstate" ? this.store[this.restoredId] : null,i))
                }
                )
            }))
        }
        ngOnDestroy() {
            this.routerEventsSubscription?.unsubscribe(),
            this.scrollEventsSubscription?.unsubscribe()
        }
    }
    ;
    e.\u0275fac = function(i) {
        A1()
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
}
)();
function UR(t) {
    return t.routerState.root
}
function Sc(t, e) {
    return {
        \u0275kind: t,
        \u0275providers: e
    }
}
function VR() {
    let t = ie(Mr);
    return e=>{
        let n = t.get(No);
        if (e !== n.components[0])
            return;
        let r = t.get(Vo)
          , i = t.get(FE);
        t.get(Dm) === 1 && r.initialNavigation(),
        t.get(NE, null, $e.Optional)?.setUpPreloading(),
        t.get(RE, null, $e.Optional)?.init(),
        r.resetRootComponentType(n.componentTypes[0]),
        i.closed || (i.next(),
        i.complete(),
        i.unsubscribe())
    }
}
var FE = new be("",{
    factory: ()=>new Fn
})
  , Dm = new be("",{
    providedIn: "root",
    factory: ()=>1
});
function jR() {
    return Sc(2, [{
        provide: Dm,
        useValue: 0
    }, {
        provide: Ol,
        multi: !0,
        deps: [Mr],
        useFactory: e=>{
            let n = e.get(vb, Promise.resolve());
            return ()=>n.then(()=>new Promise(r=>{
                let i = e.get(Vo)
                  , o = e.get(FE);
                BE(i, ()=>{
                    r(!0)
                }
                ),
                e.get(Cm).afterPreactivation = ()=>(r(!0),
                o.closed ? Ie(void 0) : o),
                i.initialNavigation()
            }
            ))
        }
    }])
}
function $R() {
    return Sc(3, [{
        provide: Ol,
        multi: !0,
        useFactory: ()=>{
            let e = ie(Vo);
            return ()=>{
                e.setUpLocationChangeListener()
            }
        }
    }, {
        provide: Dm,
        useValue: 2
    }])
}
var NE = new be("");
function HR(t) {
    return Sc(0, [{
        provide: NE,
        useExisting: OR
    }, {
        provide: pf,
        useExisting: t
    }])
}
function zR() {
    return Sc(8, [Qb, {
        provide: gf,
        useExisting: Qb
    }])
}
function qR(t) {
    let e = [{
        provide: ME,
        useValue: AR
    }, {
        provide: kE,
        useValue: ee({
            skipNextTransition: !!t?.skipInitialTransition
        }, t)
    }];
    return Sc(9, e)
}
var eE = new be("ROUTER_FORROOT_GUARD")
  , WR = [$s, {
    provide: Cc,
    useClass: pc
}, Vo, Dc, {
    provide: Ki,
    useFactory: UR,
    deps: [Vo]
}, bm, []]
  , Im = (()=>{
    let e = class e {
        constructor(r) {}
        static forRoot(r, i) {
            return {
                ngModule: e,
                providers: [WR, [], {
                    provide: hf,
                    multi: !0,
                    useValue: r
                }, {
                    provide: eE,
                    useFactory: ZR,
                    deps: [[Vo, new pl, new kp]]
                }, {
                    provide: _c,
                    useValue: i || {}
                }, i?.useHash ? KR() : YR(), GR(), i?.preloadingStrategy ? HR(i.preloadingStrategy).\u0275providers : [], i?.initialNavigation ? XR(i) : [], i?.bindToComponentInputs ? zR().\u0275providers : [], i?.enableViewTransitions ? qR().\u0275providers : [], QR()]
            }
        }
        static forChild(r) {
            return {
                ngModule: e,
                providers: [{
                    provide: hf,
                    multi: !0,
                    useValue: r
                }]
            }
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(eE, 8))
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({});
    let t = e;
    return t
}
)();
function GR() {
    return {
        provide: RE,
        useFactory: ()=>{
            let t = ie(Db)
              , e = ie(wt)
              , n = ie(_c)
              , r = ie(Cm)
              , i = ie(Cc);
            return n.scrollOffset && t.setOffset(n.scrollOffset),
            new LR(i,r,t,e,n)
        }
    }
}
function KR() {
    return {
        provide: Oo,
        useClass: wb
    }
}
function YR() {
    return {
        provide: Oo,
        useClass: Dg
    }
}
function ZR(t) {
    return "guarded"
}
function XR(t) {
    return [t.initialNavigation === "disabled" ? $R().\u0275providers : [], t.initialNavigation === "enabledBlocking" ? jR().\u0275providers : []]
}
var tE = new be("");
function QR() {
    return [{
        provide: tE,
        useFactory: VR
    }, {
        provide: Ll,
        multi: !0,
        useExisting: tE
    }]
}
var PE = (()=>{
    let e = class e {
        constructor() {}
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275cmp = Rs({
        type: e,
        selectors: [["app-root"]],
        decls: 1,
        vars: 0,
        template: function(i, o) {
            i & 1 && qr(0, "router-outlet")
        },
        dependencies: [vm]
    });
    let t = e;
    return t
}
)();
var eF = {
    "[class.ng-untouched]": "isUntouched",
    "[class.ng-touched]": "isTouched",
    "[class.ng-pristine]": "isPristine",
    "[class.ng-dirty]": "isDirty",
    "[class.ng-valid]": "isValid",
    "[class.ng-invalid]": "isInvalid",
    "[class.ng-pending]": "isPending"
}
  , Pj = me(ee({}, eF), {
    "[class.ng-submitted]": "isSubmitted"
});
var OE = new be("CallSetDisabledState",{
    providedIn: "root",
    factory: ()=>Am
})
  , Am = "always";
var tF = new be("");
var LE = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({});
    let t = e;
    return t
}
)();
var UE = (()=>{
    let e = class e {
        static withConfig(r) {
            return {
                ngModule: e,
                providers: [{
                    provide: OE,
                    useValue: r.callSetDisabledState ?? Am
                }]
            }
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({
        imports: [LE]
    });
    let t = e;
    return t
}
)()
  , VE = (()=>{
    let e = class e {
        static withConfig(r) {
            return {
                ngModule: e,
                providers: [{
                    provide: tF,
                    useValue: r.warnOnNgModelWithFormControl ?? "always"
                }, {
                    provide: OE,
                    useValue: r.callSetDisabledState ?? Am
                }]
            }
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({
        imports: [LE]
    });
    let t = e;
    return t
}
)();
var _e = Gn(kc());
function Tc(t) {
    if (!Number.isSafeInteger(t) || t < 0)
        throw new Error(`positive integer expected, not ${t}`)
}
function FF(t) {
    return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array"
}
function Xi(t, ...e) {
    if (!FF(t))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length))
        throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)
}
function oC(t) {
    if (typeof t != "function" || typeof t.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Tc(t.outputLen),
    Tc(t.blockLen)
}
function yi(t, e=!0) {
    if (t.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && t.finished)
        throw new Error("Hash#digest() has already been called")
}
function wf(t, e) {
    Xi(t);
    let n = e.outputLen;
    if (t.length < n)
        throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
var bf = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
var sC = t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength / 4))
  , Ef = t=>new DataView(t.buffer,t.byteOffset,t.byteLength)
  , kr = (t,e)=>t << 32 - e | t >>> e;
var Um = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
  , NF = t=>t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
function Vm(t) {
    for (let e = 0; e < t.length; e++)
        t[e] = NF(t[e])
}
function aC(t) {
    if (typeof t != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}
function Ji(t) {
    return typeof t == "string" && (t = aC(t)),
    Xi(t),
    t
}
function jm(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
        let i = t[r];
        Xi(i),
        e += i.length
    }
    let n = new Uint8Array(e);
    for (let r = 0, i = 0; r < t.length; r++) {
        let o = t[r];
        n.set(o, i),
        i += o.length
    }
    return n
}
var Qi = class {
    clone() {
        return this._cloneInto()
    }
}
  , Gj = {}.toString;
function ra(t) {
    let e = r=>t().update(Ji(r)).digest()
      , n = t();
    return e.outputLen = n.outputLen,
    e.blockLen = n.blockLen,
    e.create = ()=>t(),
    e
}
function cC(t) {
    let e = (r,i)=>t(i).update(Ji(r)).digest()
      , n = t({});
    return e.outputLen = n.outputLen,
    e.blockLen = n.blockLen,
    e.create = r=>t(r),
    e
}
function Cf(t=32) {
    if (bf && typeof bf.getRandomValues == "function")
        return bf.getRandomValues(new Uint8Array(t));
    throw new Error("crypto.getRandomValues must be defined")
}
function PF(t, e, n, r) {
    if (typeof t.setBigUint64 == "function")
        return t.setBigUint64(e, n, r);
    let i = BigInt(32)
      , o = BigInt(4294967295)
      , s = Number(n >> i & o)
      , a = Number(n & o)
      , c = r ? 4 : 0
      , u = r ? 0 : 4;
    t.setUint32(e + c, s, r),
    t.setUint32(e + u, a, r)
}
var uC = (t,e,n)=>t & e ^ ~t & n
  , lC = (t,e,n)=>t & e ^ t & n ^ e & n
  , ia = class extends Qi {
    constructor(e, n, r, i) {
        super(),
        this.blockLen = e,
        this.outputLen = n,
        this.padOffset = r,
        this.isLE = i,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = Ef(this.buffer)
    }
    update(e) {
        yi(this);
        let {view: n, buffer: r, blockLen: i} = this;
        e = Ji(e);
        let o = e.length;
        for (let s = 0; s < o; ) {
            let a = Math.min(i - this.pos, o - s);
            if (a === i) {
                let c = Ef(e);
                for (; i <= o - s; s += i)
                    this.process(c, s);
                continue
            }
            r.set(e.subarray(s, s + a), this.pos),
            this.pos += a,
            s += a,
            this.pos === i && (this.process(n, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        yi(this),
        wf(e, this),
        this.finished = !0;
        let {buffer: n, view: r, blockLen: i, isLE: o} = this
          , {pos: s} = this;
        n[s++] = 128,
        this.buffer.subarray(s).fill(0),
        this.padOffset > i - s && (this.process(r, 0),
        s = 0);
        for (let d = s; d < i; d++)
            n[d] = 0;
        PF(r, i - 8, BigInt(this.length * 8), o),
        this.process(r, 0);
        let a = Ef(e)
          , c = this.outputLen;
        if (c % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        let u = c / 4
          , l = this.get();
        if (u > l.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let d = 0; d < u; d++)
            a.setUint32(4 * d, l[d], o)
    }
    digest() {
        let {buffer: e, outputLen: n} = this;
        this.digestInto(e);
        let r = e.slice(0, n);
        return this.destroy(),
        r
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        let {blockLen: n, buffer: r, length: i, finished: o, destroyed: s, pos: a} = this;
        return e.length = i,
        e.pos = a,
        e.finished = o,
        e.destroyed = s,
        i % n && e.buffer.set(r),
        e
    }
}
;
var Df = BigInt(4294967295)
  , $m = BigInt(32);
function fC(t, e=!1) {
    return e ? {
        h: Number(t & Df),
        l: Number(t >> $m & Df)
    } : {
        h: Number(t >> $m & Df) | 0,
        l: Number(t & Df) | 0
    }
}
function Hm(t, e=!1) {
    let n = new Uint32Array(t.length)
      , r = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
        let {h: o, l: s} = fC(t[i], e);
        [n[i],r[i]] = [o, s]
    }
    return [n, r]
}
var OF = (t,e)=>BigInt(t >>> 0) << $m | BigInt(e >>> 0)
  , LF = (t,e,n)=>t >>> n
  , UF = (t,e,n)=>t << 32 - n | e >>> n
  , VF = (t,e,n)=>t >>> n | e << 32 - n
  , jF = (t,e,n)=>t << 32 - n | e >>> n
  , $F = (t,e,n)=>t << 64 - n | e >>> n - 32
  , HF = (t,e,n)=>t >>> n - 32 | e << 64 - n
  , zF = (t,e)=>e
  , qF = (t,e)=>t
  , zm = (t,e,n)=>t << n | e >>> 32 - n
  , qm = (t,e,n)=>e << n | t >>> 32 - n
  , Wm = (t,e,n)=>e << n - 32 | t >>> 64 - n
  , Gm = (t,e,n)=>t << n - 32 | e >>> 64 - n;
function WF(t, e, n, r) {
    let i = (e >>> 0) + (r >>> 0);
    return {
        h: t + n + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
var GF = (t,e,n)=>(t >>> 0) + (e >>> 0) + (n >>> 0)
  , KF = (t,e,n,r)=>e + n + r + (t / 2 ** 32 | 0) | 0
  , YF = (t,e,n,r)=>(t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0)
  , ZF = (t,e,n,r,i)=>e + n + r + i + (t / 2 ** 32 | 0) | 0
  , XF = (t,e,n,r,i)=>(t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
  , QF = (t,e,n,r,i,o)=>e + n + r + i + o + (t / 2 ** 32 | 0) | 0;
var JF = {
    fromBig: fC,
    split: Hm,
    toBig: OF,
    shrSH: LF,
    shrSL: UF,
    rotrSH: VF,
    rotrSL: jF,
    rotrBH: $F,
    rotrBL: HF,
    rotr32H: zF,
    rotr32L: qF,
    rotlSH: zm,
    rotlSL: qm,
    rotlBH: Wm,
    rotlBL: Gm,
    add: WF,
    add3L: GF,
    add3H: KF,
    add4L: YF,
    add4H: ZF,
    add5H: QF,
    add5L: XF
}
  , Pe = JF;
var [e3,t3] = Pe.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t=>BigInt(t)))
  , eo = new Uint32Array(80)
  , to = new Uint32Array(80)
  , Km = class extends ia {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        let {Ah: e, Al: n, Bh: r, Bl: i, Ch: o, Cl: s, Dh: a, Dl: c, Eh: u, El: l, Fh: d, Fl: y, Gh: v, Gl: E, Hh: D, Hl: S} = this;
        return [e, n, r, i, o, s, a, c, u, l, d, y, v, E, D, S]
    }
    set(e, n, r, i, o, s, a, c, u, l, d, y, v, E, D, S) {
        this.Ah = e | 0,
        this.Al = n | 0,
        this.Bh = r | 0,
        this.Bl = i | 0,
        this.Ch = o | 0,
        this.Cl = s | 0,
        this.Dh = a | 0,
        this.Dl = c | 0,
        this.Eh = u | 0,
        this.El = l | 0,
        this.Fh = d | 0,
        this.Fl = y | 0,
        this.Gh = v | 0,
        this.Gl = E | 0,
        this.Hh = D | 0,
        this.Hl = S | 0
    }
    process(e, n) {
        for (let F = 0; F < 16; F++,
        n += 4)
            eo[F] = e.getUint32(n),
            to[F] = e.getUint32(n += 4);
        for (let F = 16; F < 80; F++) {
            let N = eo[F - 15] | 0
              , P = to[F - 15] | 0
              , O = Pe.rotrSH(N, P, 1) ^ Pe.rotrSH(N, P, 8) ^ Pe.shrSH(N, P, 7)
              , z = Pe.rotrSL(N, P, 1) ^ Pe.rotrSL(N, P, 8) ^ Pe.shrSL(N, P, 7)
              , q = eo[F - 2] | 0
              , J = to[F - 2] | 0
              , te = Pe.rotrSH(q, J, 19) ^ Pe.rotrBH(q, J, 61) ^ Pe.shrSH(q, J, 6)
              , V = Pe.rotrSL(q, J, 19) ^ Pe.rotrBL(q, J, 61) ^ Pe.shrSL(q, J, 6)
              , Q = Pe.add4L(z, V, to[F - 7], to[F - 16])
              , T = Pe.add4H(Q, O, te, eo[F - 7], eo[F - 16]);
            eo[F] = T | 0,
            to[F] = Q | 0
        }
        let {Ah: r, Al: i, Bh: o, Bl: s, Ch: a, Cl: c, Dh: u, Dl: l, Eh: d, El: y, Fh: v, Fl: E, Gh: D, Gl: S, Hh: w, Hl: M} = this;
        for (let F = 0; F < 80; F++) {
            let N = Pe.rotrSH(d, y, 14) ^ Pe.rotrSH(d, y, 18) ^ Pe.rotrBH(d, y, 41)
              , P = Pe.rotrSL(d, y, 14) ^ Pe.rotrSL(d, y, 18) ^ Pe.rotrBL(d, y, 41)
              , O = d & v ^ ~d & D
              , z = y & E ^ ~y & S
              , q = Pe.add5L(M, P, z, t3[F], to[F])
              , J = Pe.add5H(q, w, N, O, e3[F], eo[F])
              , te = q | 0
              , V = Pe.rotrSH(r, i, 28) ^ Pe.rotrBH(r, i, 34) ^ Pe.rotrBH(r, i, 39)
              , Q = Pe.rotrSL(r, i, 28) ^ Pe.rotrBL(r, i, 34) ^ Pe.rotrBL(r, i, 39)
              , T = r & o ^ r & a ^ o & a
              , f = i & s ^ i & c ^ s & c;
            w = D | 0,
            M = S | 0,
            D = v | 0,
            S = E | 0,
            v = d | 0,
            E = y | 0,
            {h: d, l: y} = Pe.add(u | 0, l | 0, J | 0, te | 0),
            u = a | 0,
            l = c | 0,
            a = o | 0,
            c = s | 0,
            o = r | 0,
            s = i | 0;
            let g = Pe.add3L(te, Q, f);
            r = Pe.add3H(g, J, V, T),
            i = g | 0
        }
        ({h: r, l: i} = Pe.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
        {h: o, l: s} = Pe.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0),
        {h: a, l: c} = Pe.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0),
        {h: u, l} = Pe.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0),
        {h: d, l: y} = Pe.add(this.Eh | 0, this.El | 0, d | 0, y | 0),
        {h: v, l: E} = Pe.add(this.Fh | 0, this.Fl | 0, v | 0, E | 0),
        {h: D, l: S} = Pe.add(this.Gh | 0, this.Gl | 0, D | 0, S | 0),
        {h: w, l: M} = Pe.add(this.Hh | 0, this.Hl | 0, w | 0, M | 0),
        this.set(r, i, o, s, a, c, u, l, d, y, v, E, D, S, w, M)
    }
    roundClean() {
        eo.fill(0),
        to.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
;
var dC = ra(()=>new Km);
var Af = {};
a0(Af, {
    abytes: ()=>oa,
    bitGet: ()=>c3,
    bitLen: ()=>a3,
    bitMask: ()=>Bc,
    bitSet: ()=>u3,
    bytesToHex: ()=>xi,
    bytesToNumberBE: ()=>wi,
    bytesToNumberLE: ()=>ro,
    concatBytes: ()=>bi,
    createHmacDrbg: ()=>Xm,
    ensureBytes: ()=>Ut,
    equalBytes: ()=>o3,
    hexToBytes: ()=>Ho,
    hexToNumber: ()=>Zm,
    isBytes: ()=>no,
    numberToBytesBE: ()=>io,
    numberToBytesLE: ()=>zo,
    numberToHexUnpadded: ()=>mC,
    numberToVarBytesBE: ()=>i3,
    utf8ToBytes: ()=>s3,
    validateObject: ()=>Xr
});
var gC = BigInt(0)
  , If = BigInt(1)
  , n3 = BigInt(2);
function no(t) {
    return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array"
}
function oa(t) {
    if (!no(t))
        throw new Error("Uint8Array expected")
}
var r3 = Array.from({
    length: 256
}, (t,e)=>e.toString(16).padStart(2, "0"));
function xi(t) {
    oa(t);
    let e = "";
    for (let n = 0; n < t.length; n++)
        e += r3[t[n]];
    return e
}
function mC(t) {
    let e = t.toString(16);
    return e.length & 1 ? `0${e}` : e
}
function Zm(t) {
    if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
    return BigInt(t === "" ? "0" : `0x${t}`)
}
var vi = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function hC(t) {
    if (t >= vi._0 && t <= vi._9)
        return t - vi._0;
    if (t >= vi._A && t <= vi._F)
        return t - (vi._A - 10);
    if (t >= vi._a && t <= vi._f)
        return t - (vi._a - 10)
}
function Ho(t) {
    if (typeof t != "string")
        throw new Error("hex string expected, got " + typeof t);
    let e = t.length
      , n = e / 2;
    if (e % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + e);
    let r = new Uint8Array(n);
    for (let i = 0, o = 0; i < n; i++,
    o += 2) {
        let s = hC(t.charCodeAt(o))
          , a = hC(t.charCodeAt(o + 1));
        if (s === void 0 || a === void 0) {
            let c = t[o] + t[o + 1];
            throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + o)
        }
        r[i] = s * 16 + a
    }
    return r
}
function wi(t) {
    return Zm(xi(t))
}
function ro(t) {
    return oa(t),
    Zm(xi(Uint8Array.from(t).reverse()))
}
function io(t, e) {
    return Ho(t.toString(16).padStart(e * 2, "0"))
}
function zo(t, e) {
    return io(t, e).reverse()
}
function i3(t) {
    return Ho(mC(t))
}
function Ut(t, e, n) {
    let r;
    if (typeof e == "string")
        try {
            r = Ho(e)
        } catch (o) {
            throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${o}`)
        }
    else if (no(e))
        r = Uint8Array.from(e);
    else
        throw new Error(`${t} must be hex string or Uint8Array`);
    let i = r.length;
    if (typeof n == "number" && i !== n)
        throw new Error(`${t} expected ${n} bytes, got ${i}`);
    return r
}
function bi(...t) {
    let e = 0;
    for (let r = 0; r < t.length; r++) {
        let i = t[r];
        oa(i),
        e += i.length
    }
    let n = new Uint8Array(e);
    for (let r = 0, i = 0; r < t.length; r++) {
        let o = t[r];
        n.set(o, i),
        i += o.length
    }
    return n
}
function o3(t, e) {
    if (t.length !== e.length)
        return !1;
    let n = 0;
    for (let r = 0; r < t.length; r++)
        n |= t[r] ^ e[r];
    return n === 0
}
function s3(t) {
    if (typeof t != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}
function a3(t) {
    let e;
    for (e = 0; t > gC; t >>= If,
    e += 1)
        ;
    return e
}
function c3(t, e) {
    return t >> BigInt(e) & If
}
function u3(t, e, n) {
    return t | (n ? If : gC) << BigInt(e)
}
var Bc = t=>(n3 << BigInt(t - 1)) - If
  , Ym = t=>new Uint8Array(t)
  , pC = t=>Uint8Array.from(t);
function Xm(t, e, n) {
    if (typeof t != "number" || t < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof n != "function")
        throw new Error("hmacFn must be a function");
    let r = Ym(t)
      , i = Ym(t)
      , o = 0
      , s = ()=>{
        r.fill(1),
        i.fill(0),
        o = 0
    }
      , a = (...d)=>n(i, r, ...d)
      , c = (d=Ym())=>{
        i = a(pC([0]), d),
        r = a(),
        d.length !== 0 && (i = a(pC([1]), d),
        r = a())
    }
      , u = ()=>{
        if (o++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let d = 0
          , y = [];
        for (; d < e; ) {
            r = a();
            let v = r.slice();
            y.push(v),
            d += r.length
        }
        return bi(...y)
    }
    ;
    return (d,y)=>{
        s(),
        c(d);
        let v;
        for (; !(v = y(u())); )
            c();
        return s(),
        v
    }
}
var l3 = {
    bigint: t=>typeof t == "bigint",
    function: t=>typeof t == "function",
    boolean: t=>typeof t == "boolean",
    string: t=>typeof t == "string",
    stringOrUint8Array: t=>typeof t == "string" || no(t),
    isSafeInteger: t=>Number.isSafeInteger(t),
    array: t=>Array.isArray(t),
    field: (t,e)=>e.Fp.isValid(t),
    hash: t=>typeof t == "function" && Number.isSafeInteger(t.outputLen)
};
function Xr(t, e, n={}) {
    let r = (i,o,s)=>{
        let a = l3[o];
        if (typeof a != "function")
            throw new Error(`Invalid validator "${o}", expected function`);
        let c = t[i];
        if (!(s && c === void 0) && !a(c, t))
            throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`)
    }
    ;
    for (let[i,o] of Object.entries(e))
        r(i, o, !1);
    for (let[i,o] of Object.entries(n))
        r(i, o, !0);
    return t
}
var tn = BigInt(0)
  , Dt = BigInt(1)
  , qo = BigInt(2)
  , f3 = BigInt(3)
  , Qm = BigInt(4)
  , yC = BigInt(5)
  , vC = BigInt(8)
  , d3 = BigInt(9)
  , h3 = BigInt(16);
function mt(t, e) {
    let n = t % e;
    return n >= tn ? n : e + n
}
function p3(t, e, n) {
    if (n <= tn || e < tn)
        throw new Error("Expected power/modulo > 0");
    if (n === Dt)
        return tn;
    let r = Dt;
    for (; e > tn; )
        e & Dt && (r = r * t % n),
        t = t * t % n,
        e >>= Dt;
    return r
}
function It(t, e, n) {
    let r = t;
    for (; e-- > tn; )
        r *= r,
        r %= n;
    return r
}
function _f(t, e) {
    if (t === tn || e <= tn)
        throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
    let n = mt(t, e)
      , r = e
      , i = tn
      , o = Dt
      , s = Dt
      , a = tn;
    for (; n !== tn; ) {
        let u = r / n
          , l = r % n
          , d = i - s * u
          , y = o - a * u;
        r = n,
        n = l,
        i = s,
        o = a,
        s = d,
        a = y
    }
    if (r !== Dt)
        throw new Error("invert: does not exist");
    return mt(i, e)
}
function g3(t) {
    let e = (t - Dt) / qo, n, r, i;
    for (n = t - Dt,
    r = 0; n % qo === tn; n /= qo,
    r++)
        ;
    for (i = qo; i < t && p3(i, e, t) !== t - Dt; i++)
        ;
    if (r === 1) {
        let s = (t + Dt) / Qm;
        return function(c, u) {
            let l = c.pow(u, s);
            if (!c.eql(c.sqr(l), u))
                throw new Error("Cannot find square root");
            return l
        }
    }
    let o = (n + Dt) / qo;
    return function(a, c) {
        if (a.pow(c, e) === a.neg(a.ONE))
            throw new Error("Cannot find square root");
        let u = r
          , l = a.pow(a.mul(a.ONE, i), n)
          , d = a.pow(c, o)
          , y = a.pow(c, n);
        for (; !a.eql(y, a.ONE); ) {
            if (a.eql(y, a.ZERO))
                return a.ZERO;
            let v = 1;
            for (let D = a.sqr(y); v < u && !a.eql(D, a.ONE); v++)
                D = a.sqr(D);
            let E = a.pow(l, Dt << BigInt(u - v - 1));
            l = a.sqr(E),
            d = a.mul(d, E),
            y = a.mul(y, l),
            u = v
        }
        return d
    }
}
function m3(t) {
    if (t % Qm === f3) {
        let e = (t + Dt) / Qm;
        return function(r, i) {
            let o = r.pow(i, e);
            if (!r.eql(r.sqr(o), i))
                throw new Error("Cannot find square root");
            return o
        }
    }
    if (t % vC === yC) {
        let e = (t - yC) / vC;
        return function(r, i) {
            let o = r.mul(i, qo)
              , s = r.pow(o, e)
              , a = r.mul(i, s)
              , c = r.mul(r.mul(a, qo), s)
              , u = r.mul(a, r.sub(c, r.ONE));
            if (!r.eql(r.sqr(u), i))
                throw new Error("Cannot find square root");
            return u
        }
    }
    return t % h3,
    g3(t)
}
var xC = (t,e)=>(mt(t, e) & Dt) === Dt
  , y3 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Jm(t) {
    let e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , n = y3.reduce((r,i)=>(r[i] = "function",
    r), e);
    return Xr(t, n)
}
function v3(t, e, n) {
    if (n < tn)
        throw new Error("Expected power > 0");
    if (n === tn)
        return t.ONE;
    if (n === Dt)
        return e;
    let r = t.ONE
      , i = e;
    for (; n > tn; )
        n & Dt && (r = t.mul(r, i)),
        i = t.sqr(i),
        n >>= Dt;
    return r
}
function x3(t, e) {
    let n = new Array(e.length)
      , r = e.reduce((o,s,a)=>t.is0(s) ? o : (n[a] = o,
    t.mul(o, s)), t.ONE)
      , i = t.inv(r);
    return e.reduceRight((o,s,a)=>t.is0(s) ? o : (n[a] = t.mul(o, n[a]),
    t.mul(o, s)), i),
    n
}
function ey(t, e) {
    let n = e !== void 0 ? e : t.toString(2).length
      , r = Math.ceil(n / 8);
    return {
        nBitLength: n,
        nByteLength: r
    }
}
function Sf(t, e, n=!1, r={}) {
    if (t <= tn)
        throw new Error(`Expected Field ORDER > 0, got ${t}`);
    let {nBitLength: i, nByteLength: o} = ey(t, e);
    if (o > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
    let s = m3(t)
      , a = Object.freeze({
        ORDER: t,
        BITS: i,
        BYTES: o,
        MASK: Bc(i),
        ZERO: tn,
        ONE: Dt,
        create: c=>mt(c, t),
        isValid: c=>{
            if (typeof c != "bigint")
                throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
            return tn <= c && c < t
        }
        ,
        is0: c=>c === tn,
        isOdd: c=>(c & Dt) === Dt,
        neg: c=>mt(-c, t),
        eql: (c,u)=>c === u,
        sqr: c=>mt(c * c, t),
        add: (c,u)=>mt(c + u, t),
        sub: (c,u)=>mt(c - u, t),
        mul: (c,u)=>mt(c * u, t),
        pow: (c,u)=>v3(a, c, u),
        div: (c,u)=>mt(c * _f(u, t), t),
        sqrN: c=>c * c,
        addN: (c,u)=>c + u,
        subN: (c,u)=>c - u,
        mulN: (c,u)=>c * u,
        inv: c=>_f(c, t),
        sqrt: r.sqrt || (c=>s(a, c)),
        invertBatch: c=>x3(a, c),
        cmov: (c,u,l)=>l ? u : c,
        toBytes: c=>n ? zo(c, o) : io(c, o),
        fromBytes: c=>{
            if (c.length !== o)
                throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);
            return n ? ro(c) : wi(c)
        }
    });
    return Object.freeze(a)
}
function wC(t) {
    if (typeof t != "bigint")
        throw new Error("field order must be bigint");
    let e = t.toString(2).length;
    return Math.ceil(e / 8)
}
function ty(t) {
    let e = wC(t);
    return e + Math.ceil(e / 2)
}
function bC(t, e, n=!1) {
    let r = t.length
      , i = wC(e)
      , o = ty(e);
    if (r < 16 || r < o || r > 1024)
        throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
    let s = n ? wi(t) : ro(t)
      , a = mt(s, e - Dt) + Dt;
    return n ? zo(a, i) : io(a, i)
}
var b3 = BigInt(0)
  , ny = BigInt(1);
function Mf(t, e) {
    let n = (i,o)=>{
        let s = o.negate();
        return i ? s : o
    }
      , r = i=>{
        let o = Math.ceil(e / i) + 1
          , s = 2 ** (i - 1);
        return {
            windows: o,
            windowSize: s
        }
    }
    ;
    return {
        constTimeNegate: n,
        unsafeLadder(i, o) {
            let s = t.ZERO
              , a = i;
            for (; o > b3; )
                o & ny && (s = s.add(a)),
                a = a.double(),
                o >>= ny;
            return s
        },
        precomputeWindow(i, o) {
            let {windows: s, windowSize: a} = r(o)
              , c = []
              , u = i
              , l = u;
            for (let d = 0; d < s; d++) {
                l = u,
                c.push(l);
                for (let y = 1; y < a; y++)
                    l = l.add(u),
                    c.push(l);
                u = l.double()
            }
            return c
        },
        wNAF(i, o, s) {
            let {windows: a, windowSize: c} = r(i)
              , u = t.ZERO
              , l = t.BASE
              , d = BigInt(2 ** i - 1)
              , y = 2 ** i
              , v = BigInt(i);
            for (let E = 0; E < a; E++) {
                let D = E * c
                  , S = Number(s & d);
                s >>= v,
                S > c && (S -= y,
                s += ny);
                let w = D
                  , M = D + Math.abs(S) - 1
                  , F = E % 2 !== 0
                  , N = S < 0;
                S === 0 ? l = l.add(n(F, o[w])) : u = u.add(n(N, o[M]))
            }
            return {
                p: u,
                f: l
            }
        },
        wNAFCached(i, o, s, a) {
            let c = i._WINDOW_SIZE || 1
              , u = o.get(i);
            return u || (u = this.precomputeWindow(i, c),
            c !== 1 && o.set(i, a(u))),
            this.wNAF(c, u, s)
        }
    }
}
function Rc(t) {
    return Jm(t.Fp),
    Xr(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze(me(ee(ee({}, ey(t.n, t.nBitLength)), t), {
        p: t.Fp.ORDER
    }))
}
var Tr = BigInt(0)
  , tr = BigInt(1)
  , kf = BigInt(2)
  , E3 = BigInt(8)
  , C3 = {
    zip215: !0
};
function D3(t) {
    let e = Rc(t);
    return Xr(t, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }),
    Object.freeze(ee({}, e))
}
function EC(t) {
    let e = D3(t)
      , {Fp: n, n: r, prehash: i, hash: o, randomBytes: s, nByteLength: a, h: c} = e
      , u = kf << BigInt(a * 8) - tr
      , l = n.create
      , d = e.uvRatio || ((A,C)=>{
        try {
            return {
                isValid: !0,
                value: n.sqrt(A * n.inv(C))
            }
        } catch {
            return {
                isValid: !1,
                value: Tr
            }
        }
    }
    )
      , y = e.adjustScalarBytes || (A=>A)
      , v = e.domain || ((A,C,k)=>{
        if (C.length || k)
            throw new Error("Contexts/pre-hash are not supported");
        return A
    }
    )
      , E = A=>typeof A == "bigint" && Tr < A
      , D = (A,C)=>E(A) && E(C) && A < C
      , S = A=>A === Tr || D(A, u);
    function w(A, C) {
        if (D(A, C))
            return A;
        throw new Error(`Expected valid scalar < ${C}, got ${typeof A} ${A}`)
    }
    function M(A) {
        return A === Tr ? A : w(A, r)
    }
    let F = new Map;
    function N(A) {
        if (!(A instanceof P))
            throw new Error("ExtendedPoint expected")
    }
    class P {
        constructor(C, k, b, h) {
            if (this.ex = C,
            this.ey = k,
            this.ez = b,
            this.et = h,
            !S(C))
                throw new Error("x required");
            if (!S(k))
                throw new Error("y required");
            if (!S(b))
                throw new Error("z required");
            if (!S(h))
                throw new Error("t required")
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(C) {
            if (C instanceof P)
                throw new Error("extended point not allowed");
            let {x: k, y: b} = C || {};
            if (!S(k) || !S(b))
                throw new Error("invalid affine point");
            return new P(k,b,tr,l(k * b))
        }
        static normalizeZ(C) {
            let k = n.invertBatch(C.map(b=>b.ez));
            return C.map((b,h)=>b.toAffine(k[h])).map(P.fromAffine)
        }
        _setWindowSize(C) {
            this._WINDOW_SIZE = C,
            F.delete(this)
        }
        assertValidity() {
            let {a: C, d: k} = e;
            if (this.is0())
                throw new Error("bad point: ZERO");
            let {ex: b, ey: h, ez: B, et: Y} = this
              , ne = l(b * b)
              , K = l(h * h)
              , se = l(B * B)
              , de = l(se * se)
              , xe = l(ne * C)
              , Ke = l(se * l(xe + K))
              , ye = l(de + l(k * l(ne * K)));
            if (Ke !== ye)
                throw new Error("bad point: equation left != right (1)");
            let pe = l(b * h)
              , ot = l(B * Y);
            if (pe !== ot)
                throw new Error("bad point: equation left != right (2)")
        }
        equals(C) {
            N(C);
            let {ex: k, ey: b, ez: h} = this
              , {ex: B, ey: Y, ez: ne} = C
              , K = l(k * ne)
              , se = l(B * h)
              , de = l(b * ne)
              , xe = l(Y * h);
            return K === se && de === xe
        }
        is0() {
            return this.equals(P.ZERO)
        }
        negate() {
            return new P(l(-this.ex),this.ey,this.ez,l(-this.et))
        }
        double() {
            let {a: C} = e
              , {ex: k, ey: b, ez: h} = this
              , B = l(k * k)
              , Y = l(b * b)
              , ne = l(kf * l(h * h))
              , K = l(C * B)
              , se = k + b
              , de = l(l(se * se) - B - Y)
              , xe = K + Y
              , Ke = xe - ne
              , ye = K - Y
              , pe = l(de * Ke)
              , ot = l(xe * ye)
              , Fe = l(de * ye)
              , Ye = l(Ke * xe);
            return new P(pe,ot,Ye,Fe)
        }
        add(C) {
            N(C);
            let {a: k, d: b} = e
              , {ex: h, ey: B, ez: Y, et: ne} = this
              , {ex: K, ey: se, ez: de, et: xe} = C;
            if (k === BigInt(-1)) {
                let jt = l((B - h) * (se + K))
                  , dt = l((B + h) * (se - K))
                  , nt = l(dt - jt);
                if (nt === Tr)
                    return this.double();
                let $t = l(Y * kf * xe)
                  , vt = l(ne * kf * de)
                  , _ = vt + $t
                  , p = dt + jt
                  , m = vt - $t
                  , R = l(_ * nt)
                  , U = l(p * m)
                  , j = l(_ * m)
                  , G = l(nt * p);
                return new P(R,U,G,j)
            }
            let Ke = l(h * K)
              , ye = l(B * se)
              , pe = l(ne * b * xe)
              , ot = l(Y * de)
              , Fe = l((h + B) * (K + se) - Ke - ye)
              , Ye = ot - pe
              , yn = ot + pe
              , st = l(ye - k * Ke)
              , ft = l(Fe * Ye)
              , on = l(yn * st)
              , je = l(Fe * st)
              , ze = l(Ye * yn);
            return new P(ft,on,ze,je)
        }
        subtract(C) {
            return this.add(C.negate())
        }
        wNAF(C) {
            return q.wNAFCached(this, F, C, P.normalizeZ)
        }
        multiply(C) {
            let {p: k, f: b} = this.wNAF(w(C, r));
            return P.normalizeZ([k, b])[0]
        }
        multiplyUnsafe(C) {
            let k = M(C);
            return k === Tr ? z : this.equals(z) || k === tr ? this : this.equals(O) ? this.wNAF(k).p : q.unsafeLadder(this, k)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(c).is0()
        }
        isTorsionFree() {
            return q.unsafeLadder(this, r).is0()
        }
        toAffine(C) {
            let {ex: k, ey: b, ez: h} = this
              , B = this.is0();
            C == null && (C = B ? E3 : n.inv(h));
            let Y = l(k * C)
              , ne = l(b * C)
              , K = l(h * C);
            if (B)
                return {
                    x: Tr,
                    y: tr
                };
            if (K !== tr)
                throw new Error("invZ was invalid");
            return {
                x: Y,
                y: ne
            }
        }
        clearCofactor() {
            let {h: C} = e;
            return C === tr ? this : this.multiplyUnsafe(C)
        }
        static fromHex(C, k=!1) {
            let {d: b, a: h} = e
              , B = n.BYTES;
            C = Ut("pointHex", C, B);
            let Y = C.slice()
              , ne = C[B - 1];
            Y[B - 1] = ne & -129;
            let K = ro(Y);
            K === Tr || (k ? w(K, u) : w(K, n.ORDER));
            let se = l(K * K)
              , de = l(se - tr)
              , xe = l(b * se - h)
              , {isValid: Ke, value: ye} = d(de, xe);
            if (!Ke)
                throw new Error("Point.fromHex: invalid y coordinate");
            let pe = (ye & tr) === tr
              , ot = (ne & 128) !== 0;
            if (!k && ye === Tr && ot)
                throw new Error("Point.fromHex: x=0 and x_0=1");
            return ot !== pe && (ye = l(-ye)),
            P.fromAffine({
                x: ye,
                y: K
            })
        }
        static fromPrivateKey(C) {
            return V(C).point
        }
        toRawBytes() {
            let {x: C, y: k} = this.toAffine()
              , b = zo(k, n.BYTES);
            return b[b.length - 1] |= C & tr ? 128 : 0,
            b
        }
        toHex() {
            return xi(this.toRawBytes())
        }
    }
    P.BASE = new P(e.Gx,e.Gy,tr,l(e.Gx * e.Gy)),
    P.ZERO = new P(Tr,tr,tr,Tr);
    let {BASE: O, ZERO: z} = P
      , q = Mf(P, a * 8);
    function J(A) {
        return mt(A, r)
    }
    function te(A) {
        return J(ro(A))
    }
    function V(A) {
        let C = a;
        A = Ut("private key", A, C);
        let k = Ut("hashed private key", o(A), 2 * C)
          , b = y(k.slice(0, C))
          , h = k.slice(C, 2 * C)
          , B = te(b)
          , Y = O.multiply(B)
          , ne = Y.toRawBytes();
        return {
            head: b,
            prefix: h,
            scalar: B,
            point: Y,
            pointBytes: ne
        }
    }
    function Q(A) {
        return V(A).pointBytes
    }
    function T(A=new Uint8Array, ...C) {
        let k = bi(...C);
        return te(o(v(k, Ut("context", A), !!i)))
    }
    function f(A, C, k={}) {
        A = Ut("message", A),
        i && (A = i(A));
        let {prefix: b, scalar: h, pointBytes: B} = V(C)
          , Y = T(k.context, b, A)
          , ne = O.multiply(Y).toRawBytes()
          , K = T(k.context, ne, B, A)
          , se = J(Y + K * h);
        M(se);
        let de = bi(ne, zo(se, n.BYTES));
        return Ut("result", de, a * 2)
    }
    let g = C3;
    function x(A, C, k, b=g) {
        let {context: h, zip215: B} = b
          , Y = n.BYTES;
        A = Ut("signature", A, 2 * Y),
        C = Ut("message", C),
        i && (C = i(C));
        let ne = ro(A.slice(Y, 2 * Y)), K, se, de;
        try {
            K = P.fromHex(k, B),
            se = P.fromHex(A.slice(0, Y), B),
            de = O.multiplyUnsafe(ne)
        } catch {
            return !1
        }
        if (!B && K.isSmallOrder())
            return !1;
        let xe = T(h, se.toRawBytes(), K.toRawBytes(), C);
        return se.add(K.multiplyUnsafe(xe)).subtract(de).clearCofactor().equals(P.ZERO)
    }
    return O._setWindowSize(8),
    {
        CURVE: e,
        getPublicKey: Q,
        sign: f,
        verify: x,
        ExtendedPoint: P,
        utils: {
            getExtendedPublicKey: V,
            randomPrivateKey: ()=>s(n.BYTES),
            precompute(A=8, C=P.BASE) {
                return C._setWindowSize(A),
                C.multiply(BigInt(3)),
                C
            }
        }
    }
}
var ry = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
  , CC = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752")
  , x$ = BigInt(0)
  , I3 = BigInt(1)
  , DC = BigInt(2)
  , w$ = BigInt(3)
  , A3 = BigInt(5)
  , _3 = BigInt(8);
function S3(t) {
    let e = BigInt(10)
      , n = BigInt(20)
      , r = BigInt(40)
      , i = BigInt(80)
      , o = ry
      , a = t * t % o * t % o
      , c = It(a, DC, o) * a % o
      , u = It(c, I3, o) * t % o
      , l = It(u, A3, o) * u % o
      , d = It(l, e, o) * l % o
      , y = It(d, n, o) * d % o
      , v = It(y, r, o) * y % o
      , E = It(v, i, o) * v % o
      , D = It(E, i, o) * v % o
      , S = It(D, e, o) * l % o;
    return {
        pow_p_5_8: It(S, DC, o) * t % o,
        b2: a
    }
}
function M3(t) {
    return t[0] &= 248,
    t[31] &= 127,
    t[31] |= 64,
    t
}
function k3(t, e) {
    let n = ry
      , r = mt(e * e * e, n)
      , i = mt(r * r * e, n)
      , o = S3(t * i).pow_p_5_8
      , s = mt(t * r * o, n)
      , a = mt(e * s * s, n)
      , c = s
      , u = mt(s * CC, n)
      , l = a === t
      , d = a === mt(-t, n)
      , y = a === mt(-t * CC, n);
    return l && (s = c),
    (d || y) && (s = u),
    xC(s, n) && (s = mt(-s, n)),
    {
        isValid: l || d,
        value: s
    }
}
var T3 = Sf(ry, void 0, !0)
  , B3 = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: T3,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: _3,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: dC,
    randomBytes: Cf,
    adjustScalarBytes: M3,
    uvRatio: k3
}
  , Wo = EC(B3);
var Gy = Gn(Rf())
  , fn = Gn(Pf());
var a4 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , so = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , ao = new Uint32Array(64)
  , py = class extends ia {
    constructor() {
        super(64, 32, 8, !1),
        this.A = so[0] | 0,
        this.B = so[1] | 0,
        this.C = so[2] | 0,
        this.D = so[3] | 0,
        this.E = so[4] | 0,
        this.F = so[5] | 0,
        this.G = so[6] | 0,
        this.H = so[7] | 0
    }
    get() {
        let {A: e, B: n, C: r, D: i, E: o, F: s, G: a, H: c} = this;
        return [e, n, r, i, o, s, a, c]
    }
    set(e, n, r, i, o, s, a, c) {
        this.A = e | 0,
        this.B = n | 0,
        this.C = r | 0,
        this.D = i | 0,
        this.E = o | 0,
        this.F = s | 0,
        this.G = a | 0,
        this.H = c | 0
    }
    process(e, n) {
        for (let d = 0; d < 16; d++,
        n += 4)
            ao[d] = e.getUint32(n, !1);
        for (let d = 16; d < 64; d++) {
            let y = ao[d - 15]
              , v = ao[d - 2]
              , E = kr(y, 7) ^ kr(y, 18) ^ y >>> 3
              , D = kr(v, 17) ^ kr(v, 19) ^ v >>> 10;
            ao[d] = D + ao[d - 7] + E + ao[d - 16] | 0
        }
        let {A: r, B: i, C: o, D: s, E: a, F: c, G: u, H: l} = this;
        for (let d = 0; d < 64; d++) {
            let y = kr(a, 6) ^ kr(a, 11) ^ kr(a, 25)
              , v = l + y + uC(a, c, u) + a4[d] + ao[d] | 0
              , D = (kr(r, 2) ^ kr(r, 13) ^ kr(r, 22)) + lC(r, i, o) | 0;
            l = u,
            u = c,
            c = a,
            a = s + v | 0,
            s = o,
            o = i,
            i = r,
            r = v + D | 0
        }
        r = r + this.A | 0,
        i = i + this.B | 0,
        o = o + this.C | 0,
        s = s + this.D | 0,
        a = a + this.E | 0,
        c = c + this.F | 0,
        u = u + this.G | 0,
        l = l + this.H | 0,
        this.set(r, i, o, s, a, c, u, l)
    }
    roundClean() {
        ao.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
;
var Nc = ra(()=>new py);
var wa = Gn(tD())
  , L = Gn(Ey())
  , uI = Gn(Ey())
  , nu = Gn(nD());
var Cy = class extends TypeError {
    constructor(e, n) {
        let r, u = e, {message: i, explanation: o} = u, s = Nr(u, ["message", "explanation"]), {path: a} = e, c = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
        super(o ?? c),
        o != null && (this.cause = c),
        Object.assign(this, s),
        this.name = this.constructor.name,
        this.failures = ()=>r ?? (r = [e, ...n()])
    }
}
;
function k4(t) {
    return Ii(t) && typeof t[Symbol.iterator] == "function"
}
function Ii(t) {
    return typeof t == "object" && t != null
}
function Br(t) {
    return typeof t == "symbol" ? t.toString() : typeof t == "string" ? JSON.stringify(t) : `${t}`
}
function T4(t) {
    let {done: e, value: n} = t.next();
    return e ? void 0 : n
}
function B4(t, e, n, r) {
    if (t === !0)
        return;
    t === !1 ? t = {} : typeof t == "string" && (t = {
        message: t
    });
    let {path: i, branch: o} = e
      , {type: s} = n
      , {refinement: a, message: c=`Expected a value of type \`${s}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${Br(r)}\``} = t;
    return me(ee({
        value: r,
        type: s,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: o
    }, t), {
        message: c
    })
}
function *rD(t, e, n, r) {
    k4(t) || (t = [t]);
    for (let i of t) {
        let o = B4(i, e, n, r);
        o && (yield o)
    }
}
function *Dy(t, e, n={}) {
    let {path: r=[], branch: i=[t], coerce: o=!1, mask: s=!1} = n
      , a = {
        path: r,
        branch: i
    };
    if (o && (t = e.coercer(t, a),
    s && e.type !== "type" && Ii(e.schema) && Ii(t) && !Array.isArray(t)))
        for (let u in t)
            e.schema[u] === void 0 && delete t[u];
    let c = "valid";
    for (let u of e.validator(t, a))
        u.explanation = n.message,
        c = "not_valid",
        yield[u, void 0];
    for (let[u,l,d] of e.entries(t, a)) {
        let y = Dy(l, d, {
            path: u === void 0 ? r : [...r, u],
            branch: u === void 0 ? i : [...i, l],
            coerce: o,
            mask: s,
            message: n.message
        });
        for (let v of y)
            v[0] ? (c = v[0].refinement != null ? "not_refined" : "not_valid",
            yield[v[0], void 0]) : o && (l = v[1],
            u === void 0 ? t = l : t instanceof Map ? t.set(u, l) : t instanceof Set ? t.add(l) : Ii(t) && (l !== void 0 || u in t) && (t[u] = l))
    }
    if (c !== "not_valid")
        for (let u of e.refiner(t, a))
            u.explanation = n.message,
            c = "not_refined",
            yield[u, void 0];
    c === "valid" && (yield[void 0, t])
}
var fr = class {
    constructor(e) {
        let {type: n, schema: r, validator: i, refiner: o, coercer: s=c=>c, entries: a=function*() {}
        } = e;
        this.type = n,
        this.schema = r,
        this.entries = a,
        this.coercer = s,
        i ? this.validator = (c,u)=>{
            let l = i(c, u);
            return rD(l, u, this, c)
        }
        : this.validator = ()=>[],
        o ? this.refiner = (c,u)=>{
            let l = o(c, u);
            return rD(l, u, this, c)
        }
        : this.refiner = ()=>[]
    }
    assert(e, n) {
        return iD(e, this, n)
    }
    create(e, n) {
        return ae(e, this, n)
    }
    is(e) {
        return oD(e, this)
    }
    mask(e, n) {
        return R4(e, this, n)
    }
    validate(e, n={}) {
        return jc(e, this, n)
    }
}
;
function iD(t, e, n) {
    let r = jc(t, e, {
        message: n
    });
    if (r[0])
        throw r[0]
}
function ae(t, e, n) {
    let r = jc(t, e, {
        coerce: !0,
        message: n
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function R4(t, e, n) {
    let r = jc(t, e, {
        coerce: !0,
        mask: !0,
        message: n
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function oD(t, e) {
    return !jc(t, e)[0]
}
function jc(t, e, n={}) {
    let r = Dy(t, e, n)
      , i = T4(r);
    return i[0] ? [new Cy(i[0],function*() {
        for (let s of r)
            s[0] && (yield s[0])
    }
    ), void 0] : [void 0, i[1]]
}
function Xo(t, e) {
    return new fr({
        type: t,
        schema: null,
        validator: e
    })
}
function sD() {
    return Xo("any", ()=>!0)
}
function ce(t) {
    return new fr({
        type: "array",
        schema: t,
        *entries(e) {
            if (t && Array.isArray(e))
                for (let[n,r] of e.entries())
                    yield[n, r, t]
        },
        coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        },
        validator(e) {
            return Array.isArray(e) || `Expected an array value, but received: ${Br(e)}`
        }
    })
}
function Rr() {
    return Xo("boolean", t=>typeof t == "boolean")
}
function ud(t) {
    return Xo("instance", e=>e instanceof t || `Expected a \`${t.name}\` instance, but received: ${Br(e)}`)
}
function At(t) {
    let e = Br(t)
      , n = typeof t;
    return new fr({
        type: "literal",
        schema: n === "string" || n === "number" || n === "boolean" ? t : null,
        validator(r) {
            return r === t || `Expected the literal \`${e}\`, but received: ${Br(r)}`
        }
    })
}
function F4() {
    return Xo("never", ()=>!1)
}
function ue(t) {
    return new fr(me(ee({}, t), {
        validator: (e,n)=>e === null || t.validator(e, n),
        refiner: (e,n)=>e === null || t.refiner(e, n)
    }))
}
function H() {
    return Xo("number", t=>typeof t == "number" && !isNaN(t) || `Expected a number, but received: ${Br(t)}`)
}
function De(t) {
    return new fr(me(ee({}, t), {
        validator: (e,n)=>e === void 0 || t.validator(e, n),
        refiner: (e,n)=>e === void 0 || t.refiner(e, n)
    }))
}
function Iy(t, e) {
    return new fr({
        type: "record",
        schema: null,
        *entries(n) {
            if (Ii(n))
                for (let r in n) {
                    let i = n[r];
                    yield[r, r, t],
                    yield[r, i, e]
                }
        },
        validator(n) {
            return Ii(n) || `Expected an object, but received: ${Br(n)}`
        }
    })
}
function oe() {
    return Xo("string", t=>typeof t == "string" || `Expected a string, but received: ${Br(t)}`)
}
function ld(t) {
    let e = F4();
    return new fr({
        type: "tuple",
        schema: null,
        *entries(n) {
            if (Array.isArray(n)) {
                let r = Math.max(t.length, n.length);
                for (let i = 0; i < r; i++)
                    yield[i, n[i], t[i] || e]
            }
        },
        validator(n) {
            return Array.isArray(n) || `Expected an array, but received: ${Br(n)}`
        }
    })
}
function re(t) {
    let e = Object.keys(t);
    return new fr({
        type: "type",
        schema: t,
        *entries(n) {
            if (Ii(n))
                for (let r of e)
                    yield[r, n[r], t[r]]
        },
        validator(n) {
            return Ii(n) || `Expected an object, but received: ${Br(n)}`
        },
        coercer(n) {
            return Ii(n) ? ee({}, n) : n
        }
    })
}
function An(t) {
    let e = t.map(n=>n.type).join(" | ");
    return new fr({
        type: "union",
        schema: null,
        coercer(n) {
            for (let r of t) {
                let[i,o] = r.validate(n, {
                    coerce: !0
                });
                if (!i)
                    return o
            }
            return n
        },
        validator(n, r) {
            let i = [];
            for (let o of t) {
                let[...s] = Dy(n, o, r)
                  , [a] = s;
                if (a[0])
                    for (let[c] of s)
                        c && i.push(c);
                else
                    return []
            }
            return [`Expected the value to satisfy a union of \`${e}\`, but received: ${Br(n)}`, ...i]
        }
    })
}
function Qo() {
    return Xo("unknown", ()=>!0)
}
function ga(t, e, n) {
    return new fr(me(ee({}, t), {
        coercer: (r,i)=>oD(r, e) ? t.coercer(n(r, i), i) : t.coercer(r, i)
    }))
}
var lI = Gn(kD());
var RD = Gn(kc(), 1);
var yd = Gn(BD(), 1);
var sN = class extends yd.default {
    socket;
    constructor(t, e, n) {
        super(),
        this.socket = new window.WebSocket(t,n),
        this.socket.onopen = ()=>this.emit("open"),
        this.socket.onmessage = r=>this.emit("message", r.data),
        this.socket.onerror = r=>this.emit("error", r),
        this.socket.onclose = r=>{
            this.emit("close", r.code, r.reason)
        }
    }
    send(t, e, n) {
        let r = n || e;
        try {
            this.socket.send(t),
            r()
        } catch (i) {
            r(i)
        }
    }
    close(t, e) {
        this.socket.close(t, e)
    }
    addEventListener(t, e, n) {
        this.socket.addEventListener(t, e, n)
    }
}
;
function FD(t, e) {
    return new sN(t,e)
}
var aN = class {
    encode(t) {
        return JSON.stringify(t)
    }
    decode(t) {
        return JSON.parse(t)
    }
}
  , ND = class extends yd.default {
    address;
    rpc_id;
    queue;
    options;
    autoconnect;
    ready;
    reconnect;
    reconnect_timer_id;
    reconnect_interval;
    max_reconnects;
    rest_options;
    current_reconnects;
    generate_request_id;
    socket;
    webSocketFactory;
    dataPack;
    constructor(t, e="ws://localhost:8080", u={}, a, c) {
        var l = u
          , {autoconnect: n=!0, reconnect: r=!0, reconnect_interval: i=1e3, max_reconnects: o=5} = l
          , s = Nr(l, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        super(),
        this.webSocketFactory = t,
        this.queue = {},
        this.rpc_id = 0,
        this.address = e,
        this.autoconnect = n,
        this.ready = !1,
        this.reconnect = r,
        this.reconnect_timer_id = void 0,
        this.reconnect_interval = i,
        this.max_reconnects = o,
        this.rest_options = s,
        this.current_reconnects = 0,
        this.generate_request_id = a || (()=>++this.rpc_id),
        c ? this.dataPack = c : this.dataPack = new aN,
        this.autoconnect && this._connect(this.address, ee({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
        }, this.rest_options))
    }
    connect() {
        this.socket || this._connect(this.address, ee({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
        }, this.rest_options))
    }
    call(t, e, n, r) {
        return !r && typeof n == "object" && (r = n,
        n = null),
        new Promise((i,o)=>{
            if (!this.ready)
                return o(new Error("socket not ready"));
            let s = this.generate_request_id(t, e)
              , a = {
                jsonrpc: "2.0",
                method: t,
                params: e || void 0,
                id: s
            };
            this.socket.send(this.dataPack.encode(a), r, c=>{
                if (c)
                    return o(c);
                this.queue[s] = {
                    promise: [i, o]
                },
                n && (this.queue[s].timeout = setTimeout(()=>{
                    delete this.queue[s],
                    o(new Error("reply timeout"))
                }
                , n))
            }
            )
        }
        )
    }
    login(t) {
        return $(this, null, function*() {
            let e = yield this.call("rpc.login", t);
            if (!e)
                throw new Error("authentication failed");
            return e
        })
    }
    listMethods() {
        return $(this, null, function*() {
            return yield this.call("__listMethods")
        })
    }
    notify(t, e) {
        return new Promise((n,r)=>{
            if (!this.ready)
                return r(new Error("socket not ready"));
            let i = {
                jsonrpc: "2.0",
                method: t,
                params: e
            };
            this.socket.send(this.dataPack.encode(i), o=>{
                if (o)
                    return r(o);
                n()
            }
            )
        }
        )
    }
    subscribe(t) {
        return $(this, null, function*() {
            typeof t == "string" && (t = [t]);
            let e = yield this.call("rpc.on", t);
            if (typeof t == "string" && e[t] !== "ok")
                throw new Error("Failed subscribing to an event '" + t + "' with: " + e[t]);
            return e
        })
    }
    unsubscribe(t) {
        return $(this, null, function*() {
            typeof t == "string" && (t = [t]);
            let e = yield this.call("rpc.off", t);
            if (typeof t == "string" && e[t] !== "ok")
                throw new Error("Failed unsubscribing from an event with: " + e);
            return e
        })
    }
    close(t, e) {
        this.socket.close(t || 1e3, e)
    }
    setAutoReconnect(t) {
        this.reconnect = t
    }
    setReconnectInterval(t) {
        this.reconnect_interval = t
    }
    setMaxReconnects(t) {
        this.max_reconnects = t
    }
    _connect(t, e) {
        clearTimeout(this.reconnect_timer_id),
        this.socket = this.webSocketFactory(t, e),
        this.socket.addEventListener("open", ()=>{
            this.ready = !0,
            this.emit("open"),
            this.current_reconnects = 0
        }
        ),
        this.socket.addEventListener("message", ({data: n})=>{
            n instanceof ArrayBuffer && (n = RD.Buffer.from(n).toString());
            try {
                n = this.dataPack.decode(n)
            } catch {
                return
            }
            if (n.notification && this.listeners(n.notification).length) {
                if (!Object.keys(n.params).length)
                    return this.emit(n.notification);
                let r = [n.notification];
                if (n.params.constructor === Object)
                    r.push(n.params);
                else
                    for (let i = 0; i < n.params.length; i++)
                        r.push(n.params[i]);
                return Promise.resolve().then(()=>{
                    this.emit.apply(this, r)
                }
                )
            }
            if (!this.queue[n.id])
                return n.method ? Promise.resolve().then(()=>{
                    this.emit(n.method, n?.params)
                }
                ) : void 0;
            "error"in n == "result"in n && this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),
            this.queue[n.id].timeout && clearTimeout(this.queue[n.id].timeout),
            n.error ? this.queue[n.id].promise[1](n.error) : this.queue[n.id].promise[0](n.result),
            delete this.queue[n.id]
        }
        ),
        this.socket.addEventListener("error", n=>this.emit("error", n)),
        this.socket.addEventListener("close", ({code: n, reason: r})=>{
            this.ready && setTimeout(()=>this.emit("close", n, r), 0),
            this.ready = !1,
            this.socket = void 0,
            n !== 1e3 && (this.current_reconnects++,
            this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout(()=>this._connect(t, e), this.reconnect_interval)))
        }
        )
    }
}
;
var LD = []
  , UD = []
  , VD = []
  , cN = BigInt(0)
  , Gc = BigInt(1)
  , uN = BigInt(2)
  , lN = BigInt(7)
  , fN = BigInt(256)
  , dN = BigInt(113);
for (let t = 0, e = Gc, n = 1, r = 0; t < 24; t++) {
    [n,r] = [r, (2 * n + 3 * r) % 5],
    LD.push(2 * (5 * r + n)),
    UD.push((t + 1) * (t + 2) / 2 % 64);
    let i = cN;
    for (let o = 0; o < 7; o++)
        e = (e << Gc ^ (e >> lN) * dN) % fN,
        e & uN && (i ^= Gc << (Gc << BigInt(o)) - Gc);
    VD.push(i)
}
var [hN,pN] = Hm(VD, !0)
  , PD = (t,e,n)=>n > 32 ? Wm(t, e, n) : zm(t, e, n)
  , OD = (t,e,n)=>n > 32 ? Gm(t, e, n) : qm(t, e, n);
function gN(t, e=24) {
    let n = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let s = 0; s < 10; s++)
            n[s] = t[s] ^ t[s + 10] ^ t[s + 20] ^ t[s + 30] ^ t[s + 40];
        for (let s = 0; s < 10; s += 2) {
            let a = (s + 8) % 10
              , c = (s + 2) % 10
              , u = n[c]
              , l = n[c + 1]
              , d = PD(u, l, 1) ^ n[a]
              , y = OD(u, l, 1) ^ n[a + 1];
            for (let v = 0; v < 50; v += 10)
                t[s + v] ^= d,
                t[s + v + 1] ^= y
        }
        let i = t[2]
          , o = t[3];
        for (let s = 0; s < 24; s++) {
            let a = UD[s]
              , c = PD(i, o, a)
              , u = OD(i, o, a)
              , l = LD[s];
            i = t[l],
            o = t[l + 1],
            t[l] = c,
            t[l + 1] = u
        }
        for (let s = 0; s < 50; s += 10) {
            for (let a = 0; a < 10; a++)
                n[a] = t[s + a];
            for (let a = 0; a < 10; a++)
                t[s + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
        }
        t[0] ^= hN[r],
        t[1] ^= pN[r]
    }
    n.fill(0)
}
var vd = class t extends Qi {
    constructor(e, n, r, i=!1, o=24) {
        if (super(),
        this.blockLen = e,
        this.suffix = n,
        this.outputLen = r,
        this.enableXOF = i,
        this.rounds = o,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        Tc(r),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = sC(this.state)
    }
    keccak() {
        Um || Vm(this.state32),
        gN(this.state32, this.rounds),
        Um || Vm(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        yi(this);
        let {blockLen: n, state: r} = this;
        e = Ji(e);
        let i = e.length;
        for (let o = 0; o < i; ) {
            let s = Math.min(n - this.pos, i - o);
            for (let a = 0; a < s; a++)
                r[this.pos++] ^= e[o++];
            this.pos === n && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        let {state: e, suffix: n, pos: r, blockLen: i} = this;
        e[r] ^= n,
        n & 128 && r === i - 1 && this.keccak(),
        e[i - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        yi(this, !1),
        Xi(e),
        this.finish();
        let n = this.state
          , {blockLen: r} = this;
        for (let i = 0, o = e.length; i < o; ) {
            this.posOut >= r && this.keccak();
            let s = Math.min(r - this.posOut, o - i);
            e.set(n.subarray(this.posOut, this.posOut + s), i),
            this.posOut += s,
            i += s
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return Tc(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (wf(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(e) {
        let {blockLen: n, suffix: r, outputLen: i, rounds: o, enableXOF: s} = this;
        return e || (e = new t(n,r,i,s,o)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = o,
        e.suffix = r,
        e.outputLen = i,
        e.enableXOF = s,
        e.destroyed = this.destroyed,
        e
    }
}
  , po = (t,e,n)=>ra(()=>new vd(e,t,n))
  , BH = po(6, 144, 224 / 8)
  , RH = po(6, 136, 256 / 8)
  , FH = po(6, 104, 384 / 8)
  , NH = po(6, 72, 512 / 8)
  , PH = po(1, 144, 224 / 8)
  , Py = po(1, 136, 256 / 8)
  , OH = po(1, 104, 384 / 8)
  , LH = po(1, 72, 512 / 8)
  , jD = (t,e,n)=>cC((r={})=>new vd(e,t,r.dkLen === void 0 ? n : r.dkLen,!0))
  , UH = jD(31, 168, 128 / 8)
  , VH = jD(31, 136, 256 / 8);
var xd = class extends Qi {
    constructor(e, n) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        oC(e);
        let r = Ji(n);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        let i = this.blockLen
          , o = new Uint8Array(i);
        o.set(r.length > i ? e.create().update(r).digest() : r);
        for (let s = 0; s < o.length; s++)
            o[s] ^= 54;
        this.iHash.update(o),
        this.oHash = e.create();
        for (let s = 0; s < o.length; s++)
            o[s] ^= 106;
        this.oHash.update(o),
        o.fill(0)
    }
    update(e) {
        return yi(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        yi(this),
        Xi(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        let e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        let {oHash: n, iHash: r, finished: i, destroyed: o, blockLen: s, outputLen: a} = this;
        return e = e,
        e.finished = i,
        e.destroyed = o,
        e.blockLen = s,
        e.outputLen = a,
        e.oHash = n._cloneInto(e.oHash),
        e.iHash = r._cloneInto(e.iHash),
        e
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
  , Oy = (t,e,n)=>new xd(t,e).update(n).digest();
Oy.create = (t,e)=>new xd(t,e);
function mN(t) {
    let e = Rc(t);
    Xr(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    let {endo: n, Fp: r, a: i} = e;
    if (n) {
        if (!r.eql(i, r.ZERO))
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze(ee({}, e))
}
var {bytesToNumberBE: yN, hexToBytes: vN} = Af
  , Jo = {
    Err: class extends Error {
        constructor(e="") {
            super(e)
        }
    }
    ,
    _parseInt(t) {
        let {Err: e} = Jo;
        if (t.length < 2 || t[0] !== 2)
            throw new e("Invalid signature integer tag");
        let n = t[1]
          , r = t.subarray(2, n + 2);
        if (!n || r.length !== n)
            throw new e("Invalid signature integer: wrong length");
        if (r[0] & 128)
            throw new e("Invalid signature integer: negative");
        if (r[0] === 0 && !(r[1] & 128))
            throw new e("Invalid signature integer: unnecessary leading zero");
        return {
            d: yN(r),
            l: t.subarray(n + 2)
        }
    },
    toSig(t) {
        let {Err: e} = Jo
          , n = typeof t == "string" ? vN(t) : t;
        oa(n);
        let r = n.length;
        if (r < 2 || n[0] != 48)
            throw new e("Invalid signature tag");
        if (n[1] !== r - 2)
            throw new e("Invalid signature: incorrect length");
        let {d: i, l: o} = Jo._parseInt(n.subarray(2))
          , {d: s, l: a} = Jo._parseInt(o);
        if (a.length)
            throw new e("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s
        }
    },
    hexFromSig(t) {
        let e = u=>Number.parseInt(u[0], 16) & 8 ? "00" + u : u
          , n = u=>{
            let l = u.toString(16);
            return l.length & 1 ? `0${l}` : l
        }
          , r = e(n(t.s))
          , i = e(n(t.r))
          , o = r.length / 2
          , s = i.length / 2
          , a = n(o)
          , c = n(s);
        return `30${n(s + o + 4)}02${c}${i}02${a}${r}`
    }
}
  , Ai = BigInt(0)
  , dr = BigInt(1)
  , KH = BigInt(2)
  , $D = BigInt(3)
  , YH = BigInt(4);
function xN(t) {
    let e = mN(t)
      , {Fp: n} = e
      , r = e.toBytes || ((E,D,S)=>{
        let w = D.toAffine();
        return bi(Uint8Array.from([4]), n.toBytes(w.x), n.toBytes(w.y))
    }
    )
      , i = e.fromBytes || (E=>{
        let D = E.subarray(1)
          , S = n.fromBytes(D.subarray(0, n.BYTES))
          , w = n.fromBytes(D.subarray(n.BYTES, 2 * n.BYTES));
        return {
            x: S,
            y: w
        }
    }
    );
    function o(E) {
        let {a: D, b: S} = e
          , w = n.sqr(E)
          , M = n.mul(w, E);
        return n.add(n.add(M, n.mul(E, D)), S)
    }
    if (!n.eql(n.sqr(e.Gy), o(e.Gx)))
        throw new Error("bad generator point: equation left != right");
    function s(E) {
        return typeof E == "bigint" && Ai < E && E < e.n
    }
    function a(E) {
        if (!s(E))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }
    function c(E) {
        let {allowedPrivateKeyLengths: D, nByteLength: S, wrapPrivateKey: w, n: M} = e;
        if (D && typeof E != "bigint") {
            if (no(E) && (E = xi(E)),
            typeof E != "string" || !D.includes(E.length))
                throw new Error("Invalid key");
            E = E.padStart(S * 2, "0")
        }
        let F;
        try {
            F = typeof E == "bigint" ? E : wi(Ut("private key", E, S))
        } catch {
            throw new Error(`private key must be ${S} bytes, hex or bigint, not ${typeof E}`)
        }
        return w && (F = mt(F, M)),
        a(F),
        F
    }
    let u = new Map;
    function l(E) {
        if (!(E instanceof d))
            throw new Error("ProjectivePoint expected")
    }
    class d {
        constructor(D, S, w) {
            if (this.px = D,
            this.py = S,
            this.pz = w,
            D == null || !n.isValid(D))
                throw new Error("x required");
            if (S == null || !n.isValid(S))
                throw new Error("y required");
            if (w == null || !n.isValid(w))
                throw new Error("z required")
        }
        static fromAffine(D) {
            let {x: S, y: w} = D || {};
            if (!D || !n.isValid(S) || !n.isValid(w))
                throw new Error("invalid affine point");
            if (D instanceof d)
                throw new Error("projective point not allowed");
            let M = F=>n.eql(F, n.ZERO);
            return M(S) && M(w) ? d.ZERO : new d(S,w,n.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(D) {
            let S = n.invertBatch(D.map(w=>w.pz));
            return D.map((w,M)=>w.toAffine(S[M])).map(d.fromAffine)
        }
        static fromHex(D) {
            let S = d.fromAffine(i(Ut("pointHex", D)));
            return S.assertValidity(),
            S
        }
        static fromPrivateKey(D) {
            return d.BASE.multiply(c(D))
        }
        _setWindowSize(D) {
            this._WINDOW_SIZE = D,
            u.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (e.allowInfinityPoint && !n.is0(this.py))
                    return;
                throw new Error("bad point: ZERO")
            }
            let {x: D, y: S} = this.toAffine();
            if (!n.isValid(D) || !n.isValid(S))
                throw new Error("bad point: x or y not FE");
            let w = n.sqr(S)
              , M = o(D);
            if (!n.eql(w, M))
                throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            let {y: D} = this.toAffine();
            if (n.isOdd)
                return !n.isOdd(D);
            throw new Error("Field doesn't support isOdd")
        }
        equals(D) {
            l(D);
            let {px: S, py: w, pz: M} = this
              , {px: F, py: N, pz: P} = D
              , O = n.eql(n.mul(S, P), n.mul(F, M))
              , z = n.eql(n.mul(w, P), n.mul(N, M));
            return O && z
        }
        negate() {
            return new d(this.px,n.neg(this.py),this.pz)
        }
        double() {
            let {a: D, b: S} = e
              , w = n.mul(S, $D)
              , {px: M, py: F, pz: N} = this
              , P = n.ZERO
              , O = n.ZERO
              , z = n.ZERO
              , q = n.mul(M, M)
              , J = n.mul(F, F)
              , te = n.mul(N, N)
              , V = n.mul(M, F);
            return V = n.add(V, V),
            z = n.mul(M, N),
            z = n.add(z, z),
            P = n.mul(D, z),
            O = n.mul(w, te),
            O = n.add(P, O),
            P = n.sub(J, O),
            O = n.add(J, O),
            O = n.mul(P, O),
            P = n.mul(V, P),
            z = n.mul(w, z),
            te = n.mul(D, te),
            V = n.sub(q, te),
            V = n.mul(D, V),
            V = n.add(V, z),
            z = n.add(q, q),
            q = n.add(z, q),
            q = n.add(q, te),
            q = n.mul(q, V),
            O = n.add(O, q),
            te = n.mul(F, N),
            te = n.add(te, te),
            q = n.mul(te, V),
            P = n.sub(P, q),
            z = n.mul(te, J),
            z = n.add(z, z),
            z = n.add(z, z),
            new d(P,O,z)
        }
        add(D) {
            l(D);
            let {px: S, py: w, pz: M} = this
              , {px: F, py: N, pz: P} = D
              , O = n.ZERO
              , z = n.ZERO
              , q = n.ZERO
              , J = e.a
              , te = n.mul(e.b, $D)
              , V = n.mul(S, F)
              , Q = n.mul(w, N)
              , T = n.mul(M, P)
              , f = n.add(S, w)
              , g = n.add(F, N);
            f = n.mul(f, g),
            g = n.add(V, Q),
            f = n.sub(f, g),
            g = n.add(S, M);
            let x = n.add(F, P);
            return g = n.mul(g, x),
            x = n.add(V, T),
            g = n.sub(g, x),
            x = n.add(w, M),
            O = n.add(N, P),
            x = n.mul(x, O),
            O = n.add(Q, T),
            x = n.sub(x, O),
            q = n.mul(J, g),
            O = n.mul(te, T),
            q = n.add(O, q),
            O = n.sub(Q, q),
            q = n.add(Q, q),
            z = n.mul(O, q),
            Q = n.add(V, V),
            Q = n.add(Q, V),
            T = n.mul(J, T),
            g = n.mul(te, g),
            Q = n.add(Q, T),
            T = n.sub(V, T),
            T = n.mul(J, T),
            g = n.add(g, T),
            V = n.mul(Q, g),
            z = n.add(z, V),
            V = n.mul(x, g),
            O = n.mul(f, O),
            O = n.sub(O, V),
            V = n.mul(f, Q),
            q = n.mul(x, q),
            q = n.add(q, V),
            new d(O,z,q)
        }
        subtract(D) {
            return this.add(D.negate())
        }
        is0() {
            return this.equals(d.ZERO)
        }
        wNAF(D) {
            return v.wNAFCached(this, u, D, S=>{
                let w = n.invertBatch(S.map(M=>M.pz));
                return S.map((M,F)=>M.toAffine(w[F])).map(d.fromAffine)
            }
            )
        }
        multiplyUnsafe(D) {
            let S = d.ZERO;
            if (D === Ai)
                return S;
            if (a(D),
            D === dr)
                return this;
            let {endo: w} = e;
            if (!w)
                return v.unsafeLadder(this, D);
            let {k1neg: M, k1: F, k2neg: N, k2: P} = w.splitScalar(D)
              , O = S
              , z = S
              , q = this;
            for (; F > Ai || P > Ai; )
                F & dr && (O = O.add(q)),
                P & dr && (z = z.add(q)),
                q = q.double(),
                F >>= dr,
                P >>= dr;
            return M && (O = O.negate()),
            N && (z = z.negate()),
            z = new d(n.mul(z.px, w.beta),z.py,z.pz),
            O.add(z)
        }
        multiply(D) {
            a(D);
            let S = D, w, M, {endo: F} = e;
            if (F) {
                let {k1neg: N, k1: P, k2neg: O, k2: z} = F.splitScalar(S)
                  , {p: q, f: J} = this.wNAF(P)
                  , {p: te, f: V} = this.wNAF(z);
                q = v.constTimeNegate(N, q),
                te = v.constTimeNegate(O, te),
                te = new d(n.mul(te.px, F.beta),te.py,te.pz),
                w = q.add(te),
                M = J.add(V)
            } else {
                let {p: N, f: P} = this.wNAF(S);
                w = N,
                M = P
            }
            return d.normalizeZ([w, M])[0]
        }
        multiplyAndAddUnsafe(D, S, w) {
            let M = d.BASE
              , F = (P,O)=>O === Ai || O === dr || !P.equals(M) ? P.multiplyUnsafe(O) : P.multiply(O)
              , N = F(this, S).add(F(D, w));
            return N.is0() ? void 0 : N
        }
        toAffine(D) {
            let {px: S, py: w, pz: M} = this
              , F = this.is0();
            D == null && (D = F ? n.ONE : n.inv(M));
            let N = n.mul(S, D)
              , P = n.mul(w, D)
              , O = n.mul(M, D);
            if (F)
                return {
                    x: n.ZERO,
                    y: n.ZERO
                };
            if (!n.eql(O, n.ONE))
                throw new Error("invZ was invalid");
            return {
                x: N,
                y: P
            }
        }
        isTorsionFree() {
            let {h: D, isTorsionFree: S} = e;
            if (D === dr)
                return !0;
            if (S)
                return S(d, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            let {h: D, clearCofactor: S} = e;
            return D === dr ? this : S ? S(d, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(D=!0) {
            return this.assertValidity(),
            r(d, this, D)
        }
        toHex(D=!0) {
            return xi(this.toRawBytes(D))
        }
    }
    d.BASE = new d(e.Gx,e.Gy,n.ONE),
    d.ZERO = new d(n.ZERO,n.ONE,n.ZERO);
    let y = e.nBitLength
      , v = Mf(d, e.endo ? Math.ceil(y / 2) : y);
    return {
        CURVE: e,
        ProjectivePoint: d,
        normPrivateKeyToScalar: c,
        weierstrassEquation: o,
        isWithinCurveOrder: s
    }
}
function wN(t) {
    let e = Rc(t);
    return Xr(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze(ee({
        lowS: !0
    }, e))
}
function HD(t) {
    let e = wN(t)
      , {Fp: n, n: r} = e
      , i = n.BYTES + 1
      , o = 2 * n.BYTES + 1;
    function s(g) {
        return Ai < g && g < n.ORDER
    }
    function a(g) {
        return mt(g, r)
    }
    function c(g) {
        return _f(g, r)
    }
    let {ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: d, isWithinCurveOrder: y} = xN(me(ee({}, e), {
        toBytes(g, x, I) {
            let A = x.toAffine()
              , C = n.toBytes(A.x)
              , k = bi;
            return I ? k(Uint8Array.from([x.hasEvenY() ? 2 : 3]), C) : k(Uint8Array.from([4]), C, n.toBytes(A.y))
        },
        fromBytes(g) {
            let x = g.length
              , I = g[0]
              , A = g.subarray(1);
            if (x === i && (I === 2 || I === 3)) {
                let C = wi(A);
                if (!s(C))
                    throw new Error("Point is not on curve");
                let k = d(C), b;
                try {
                    b = n.sqrt(k)
                } catch (Y) {
                    let ne = Y instanceof Error ? ": " + Y.message : "";
                    throw new Error("Point is not on curve" + ne)
                }
                let h = (b & dr) === dr;
                return (I & 1) === 1 !== h && (b = n.neg(b)),
                {
                    x: C,
                    y: b
                }
            } else if (x === o && I === 4) {
                let C = n.fromBytes(A.subarray(0, n.BYTES))
                  , k = n.fromBytes(A.subarray(n.BYTES, 2 * n.BYTES));
                return {
                    x: C,
                    y: k
                }
            } else
                throw new Error(`Point of length ${x} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)
        }
    }))
      , v = g=>xi(io(g, e.nByteLength));
    function E(g) {
        let x = r >> dr;
        return g > x
    }
    function D(g) {
        return E(g) ? a(-g) : g
    }
    let S = (g,x,I)=>wi(g.slice(x, I));
    class w {
        constructor(x, I, A) {
            this.r = x,
            this.s = I,
            this.recovery = A,
            this.assertValidity()
        }
        static fromCompact(x) {
            let I = e.nByteLength;
            return x = Ut("compactSignature", x, I * 2),
            new w(S(x, 0, I),S(x, I, 2 * I))
        }
        static fromDER(x) {
            let {r: I, s: A} = Jo.toSig(Ut("DER", x));
            return new w(I,A)
        }
        assertValidity() {
            if (!y(this.r))
                throw new Error("r must be 0 < r < CURVE.n");
            if (!y(this.s))
                throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(x) {
            return new w(this.r,this.s,x)
        }
        recoverPublicKey(x) {
            let {r: I, s: A, recovery: C} = this
              , k = z(Ut("msgHash", x));
            if (C == null || ![0, 1, 2, 3].includes(C))
                throw new Error("recovery id invalid");
            let b = C === 2 || C === 3 ? I + e.n : I;
            if (b >= n.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            let h = C & 1 ? "03" : "02"
              , B = u.fromHex(h + v(b))
              , Y = c(b)
              , ne = a(-k * Y)
              , K = a(A * Y)
              , se = u.BASE.multiplyAndAddUnsafe(B, ne, K);
            if (!se)
                throw new Error("point at infinify");
            return se.assertValidity(),
            se
        }
        hasHighS() {
            return E(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new w(this.r,a(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return Ho(this.toDERHex())
        }
        toDERHex() {
            return Jo.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return Ho(this.toCompactHex())
        }
        toCompactHex() {
            return v(this.r) + v(this.s)
        }
    }
    let M = {
        isValidPrivateKey(g) {
            try {
                return l(g),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: l,
        randomPrivateKey: ()=>{
            let g = ty(e.n);
            return bC(e.randomBytes(g), e.n)
        }
        ,
        precompute(g=8, x=u.BASE) {
            return x._setWindowSize(g),
            x.multiply(BigInt(3)),
            x
        }
    };
    function F(g, x=!0) {
        return u.fromPrivateKey(g).toRawBytes(x)
    }
    function N(g) {
        let x = no(g)
          , I = typeof g == "string"
          , A = (x || I) && g.length;
        return x ? A === i || A === o : I ? A === 2 * i || A === 2 * o : g instanceof u
    }
    function P(g, x, I=!0) {
        if (N(g))
            throw new Error("first arg must be private key");
        if (!N(x))
            throw new Error("second arg must be public key");
        return u.fromHex(x).multiply(l(g)).toRawBytes(I)
    }
    let O = e.bits2int || function(g) {
        let x = wi(g)
          , I = g.length * 8 - e.nBitLength;
        return I > 0 ? x >> BigInt(I) : x
    }
      , z = e.bits2int_modN || function(g) {
        return a(O(g))
    }
      , q = Bc(e.nBitLength);
    function J(g) {
        if (typeof g != "bigint")
            throw new Error("bigint expected");
        if (!(Ai <= g && g < q))
            throw new Error(`bigint expected < 2^${e.nBitLength}`);
        return io(g, e.nByteLength)
    }
    function te(g, x, I=V) {
        if (["recovered", "canonical"].some(xe=>xe in I))
            throw new Error("sign() legacy options not supported");
        let {hash: A, randomBytes: C} = e
          , {lowS: k, prehash: b, extraEntropy: h} = I;
        k == null && (k = !0),
        g = Ut("msgHash", g),
        b && (g = Ut("prehashed msgHash", A(g)));
        let B = z(g)
          , Y = l(x)
          , ne = [J(Y), J(B)];
        if (h != null && h !== !1) {
            let xe = h === !0 ? C(n.BYTES) : h;
            ne.push(Ut("extraEntropy", xe))
        }
        let K = bi(...ne)
          , se = B;
        function de(xe) {
            let Ke = O(xe);
            if (!y(Ke))
                return;
            let ye = c(Ke)
              , pe = u.BASE.multiply(Ke).toAffine()
              , ot = a(pe.x);
            if (ot === Ai)
                return;
            let Fe = a(ye * a(se + ot * Y));
            if (Fe === Ai)
                return;
            let Ye = (pe.x === ot ? 0 : 2) | Number(pe.y & dr)
              , yn = Fe;
            return k && E(Fe) && (yn = D(Fe),
            Ye ^= 1),
            new w(ot,yn,Ye)
        }
        return {
            seed: K,
            k2sig: de
        }
    }
    let V = {
        lowS: e.lowS,
        prehash: !1
    }
      , Q = {
        lowS: e.lowS,
        prehash: !1
    };
    function T(g, x, I=V) {
        let {seed: A, k2sig: C} = te(g, x, I)
          , k = e;
        return Xm(k.hash.outputLen, k.nByteLength, k.hmac)(A, C)
    }
    u.BASE._setWindowSize(8);
    function f(g, x, I, A=Q) {
        let C = g;
        if (x = Ut("msgHash", x),
        I = Ut("publicKey", I),
        "strict"in A)
            throw new Error("options.strict was renamed to lowS");
        let {lowS: k, prehash: b} = A, h, B;
        try {
            if (typeof C == "string" || no(C))
                try {
                    h = w.fromDER(C)
                } catch (pe) {
                    if (!(pe instanceof Jo.Err))
                        throw pe;
                    h = w.fromCompact(C)
                }
            else if (typeof C == "object" && typeof C.r == "bigint" && typeof C.s == "bigint") {
                let {r: pe, s: ot} = C;
                h = new w(pe,ot)
            } else
                throw new Error("PARSE");
            B = u.fromHex(I)
        } catch (pe) {
            if (pe.message === "PARSE")
                throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (k && h.hasHighS())
            return !1;
        b && (x = e.hash(x));
        let {r: Y, s: ne} = h
          , K = z(x)
          , se = c(ne)
          , de = a(K * se)
          , xe = a(Y * se)
          , Ke = u.BASE.multiplyAndAddUnsafe(B, de, xe)?.toAffine();
        return Ke ? a(Ke.x) === Y : !1
    }
    return {
        CURVE: e,
        getPublicKey: F,
        getSharedSecret: P,
        sign: T,
        verify: f,
        ProjectivePoint: u,
        Signature: w,
        utils: M
    }
}
function bN(t) {
    return {
        hash: t,
        hmac: (e,...n)=>Oy(t, e, jm(...n)),
        randomBytes: Cf
    }
}
function zD(t, e) {
    let n = r=>HD(ee(ee({}, t), bN(r)));
    return Object.freeze(me(ee({}, n(e)), {
        create: n
    }))
}
var GD = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , qD = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , EN = BigInt(1)
  , Ly = BigInt(2)
  , WD = (t,e)=>(t + e / Ly) / e;
function CN(t) {
    let e = GD
      , n = BigInt(3)
      , r = BigInt(6)
      , i = BigInt(11)
      , o = BigInt(22)
      , s = BigInt(23)
      , a = BigInt(44)
      , c = BigInt(88)
      , u = t * t * t % e
      , l = u * u * t % e
      , d = It(l, n, e) * l % e
      , y = It(d, n, e) * l % e
      , v = It(y, Ly, e) * u % e
      , E = It(v, i, e) * v % e
      , D = It(E, o, e) * E % e
      , S = It(D, a, e) * D % e
      , w = It(S, c, e) * S % e
      , M = It(w, a, e) * D % e
      , F = It(M, n, e) * l % e
      , N = It(F, s, e) * E % e
      , P = It(N, r, e) * u % e
      , O = It(P, Ly, e);
    if (!Uy.eql(Uy.sqr(O), t))
        throw new Error("Cannot find square root");
    return O
}
var Uy = Sf(GD, void 0, void 0, {
    sqrt: CN
})
  , Kc = zD({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Uy,
    n: qD,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: t=>{
            let e = qD
              , n = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , r = -EN * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , o = n
              , s = BigInt("0x100000000000000000000000000000000")
              , a = WD(o * t, e)
              , c = WD(-r * t, e)
              , u = mt(t - a * n - c * i, e)
              , l = mt(-a * r - c * o, e)
              , d = u > s
              , y = l > s;
            if (d && (u = e - u),
            y && (l = e - l),
            u > s || l > s)
                throw new Error("splitScalar: Endomorphism failed, k=" + t);
            return {
                k1neg: d,
                k1: u,
                k2neg: y,
                k2: l
            }
        }
    }
}, Nc)
  , sz = BigInt(0);
var az = Kc.ProjectivePoint;
var gz = Wo.utils.randomPrivateKey
  , KD = ()=>{
    let t = Wo.utils.randomPrivateKey()
      , e = Ky(t)
      , n = new Uint8Array(64);
    return n.set(t),
    n.set(e, 32),
    {
        publicKey: e,
        secretKey: n
    }
}
  , Ky = Wo.getPublicKey;
function YD(t) {
    try {
        return Wo.ExtendedPoint.fromHex(t),
        !0
    } catch {
        return !1
    }
}
var fI = (t,e)=>Wo.sign(t, e.slice(0, 32))
  , DN = Wo.verify
  , Ze = t=>_e.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? _e.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : _e.Buffer.from(t)
  , Yy = class {
    constructor(e) {
        Object.assign(this, e)
    }
    encode() {
        return _e.Buffer.from((0,
        wa.serialize)(Ed, this))
    }
    static decode(e) {
        return (0,
        wa.deserialize)(Ed, this, e)
    }
    static decodeUnchecked(e) {
        return (0,
        wa.deserializeUnchecked)(Ed, this, e)
    }
}
;
var Ed = new Map, dI, IN = 32, yo = 32;
function AN(t) {
    return t._bn !== void 0
}
var ZD = 1
  , le = class t extends Yy {
    constructor(e) {
        if (super({}),
        this._bn = void 0,
        AN(e))
            this._bn = e._bn;
        else {
            if (typeof e == "string") {
                let n = fn.default.decode(e);
                if (n.length != yo)
                    throw new Error("Invalid public key input");
                this._bn = new Gy.default(n)
            } else
                this._bn = new Gy.default(e);
            if (this._bn.byteLength() > yo)
                throw new Error("Invalid public key input")
        }
    }
    static unique() {
        let e = new t(ZD);
        return ZD += 1,
        new t(e.toBuffer())
    }
    equals(e) {
        return this._bn.eq(e._bn)
    }
    toBase58() {
        return fn.default.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        let e = this.toBuffer();
        return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)
    }
    toBuffer() {
        let e = this._bn.toArrayLike(_e.Buffer);
        if (e.length === yo)
            return e;
        let n = _e.Buffer.alloc(32);
        return e.copy(n, 32 - e.length),
        n
    }
    get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
    }
    toString() {
        return this.toBase58()
    }
    static createWithSeed(e, n, r) {
        return $(this, null, function*() {
            let i = _e.Buffer.concat([e.toBuffer(), _e.Buffer.from(n), r.toBuffer()])
              , o = Nc(i);
            return new t(o)
        })
    }
    static createProgramAddressSync(e, n) {
        let r = _e.Buffer.alloc(0);
        e.forEach(function(o) {
            if (o.length > IN)
                throw new TypeError("Max seed length exceeded");
            r = _e.Buffer.concat([r, Ze(o)])
        }),
        r = _e.Buffer.concat([r, n.toBuffer(), _e.Buffer.from("ProgramDerivedAddress")]);
        let i = Nc(r);
        if (YD(i))
            throw new Error("Invalid seeds, address must fall off the curve");
        return new t(i)
    }
    static createProgramAddress(e, n) {
        return $(this, null, function*() {
            return this.createProgramAddressSync(e, n)
        })
    }
    static findProgramAddressSync(e, n) {
        let r = 255, i;
        for (; r != 0; ) {
            try {
                let o = e.concat(_e.Buffer.from([r]));
                i = this.createProgramAddressSync(o, n)
            } catch (o) {
                if (o instanceof TypeError)
                    throw o;
                r--;
                continue
            }
            return [i, r]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static findProgramAddress(e, n) {
        return $(this, null, function*() {
            return this.findProgramAddressSync(e, n)
        })
    }
    static isOnCurve(e) {
        let n = new t(e);
        return YD(n.toBytes())
    }
}
;
dI = le;
le.default = new dI("11111111111111111111111111111111");
Ed.set(le, {
    kind: "struct",
    fields: [["_bn", "u256"]]
});
var mz = new le("BPFLoader1111111111111111111111111111111111")
  , ts = 1232
  , hI = 127
  , pI = 64
  , Cd = class extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: block height exceeded.`),
        this.signature = void 0,
        this.signature = e
    }
}
;
Object.defineProperty(Cd.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
var Dd = class extends Error {
    constructor(e, n) {
        super(`Transaction was not confirmed in ${n.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),
        this.signature = void 0,
        this.signature = e
    }
}
;
Object.defineProperty(Dd.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
var es = class extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: the nonce is no longer valid.`),
        this.signature = void 0,
        this.signature = e
    }
}
;
Object.defineProperty(es.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
var va = class {
    constructor(e, n) {
        this.staticAccountKeys = void 0,
        this.accountKeysFromLookups = void 0,
        this.staticAccountKeys = e,
        this.accountKeysFromLookups = n
    }
    keySegments() {
        let e = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable),
        e.push(this.accountKeysFromLookups.readonly)),
        e
    }
    get(e) {
        for (let n of this.keySegments()) {
            if (e < n.length)
                return n[e];
            e -= n.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions(e) {
        if (this.length > 256)
            throw new Error("Account index overflow encountered during compilation");
        let r = new Map;
        this.keySegments().flat().forEach((o,s)=>{
            r.set(o.toBase58(), s)
        }
        );
        let i = o=>{
            let s = r.get(o.toBase58());
            if (s === void 0)
                throw new Error("Encountered an unknown instruction account key during compilation");
            return s
        }
        ;
        return e.map(o=>({
            programIdIndex: i(o.programId),
            accountKeyIndexes: o.keys.map(s=>i(s.pubkey)),
            data: o.data
        }))
    }
}
  , He = (t="publicKey")=>L.blob(32, t);
var ya = (t="string")=>{
    let e = L.struct([L.u32("length"), L.u32("lengthPadding"), L.blob(L.offset(L.u32(), -8), "chars")], t)
      , n = e.decode.bind(e)
      , r = e.encode.bind(e)
      , i = e;
    return i.decode = (o,s)=>n(o, s).chars.toString(),
    i.encode = (o,s,a)=>{
        let c = {
            chars: _e.Buffer.from(o, "utf8")
        };
        return r(c, s, a)
    }
    ,
    i.alloc = o=>L.u32().span + L.u32().span + _e.Buffer.from(o, "utf8").length,
    i
}
  , _N = (t="authorized")=>L.struct([He("staker"), He("withdrawer")], t)
  , SN = (t="lockup")=>L.struct([L.ns64("unixTimestamp"), L.ns64("epoch"), He("custodian")], t)
  , MN = (t="voteInit")=>L.struct([He("nodePubkey"), He("authorizedVoter"), He("authorizedWithdrawer"), L.u8("commission")], t)
  , kN = (t="voteAuthorizeWithSeedArgs")=>L.struct([L.u32("voteAuthorizationType"), He("currentAuthorityDerivedKeyOwnerPubkey"), ya("currentAuthorityDerivedKeySeed"), He("newAuthorized")], t);
function gI(t, e) {
    let n = i=>{
        if (i.span >= 0)
            return i.span;
        if (typeof i.alloc == "function")
            return i.alloc(e[i.property]);
        if ("count"in i && "elementLayout"in i) {
            let o = e[i.property];
            if (Array.isArray(o))
                return o.length * n(i.elementLayout)
        } else if ("fields"in i)
            return gI({
                layout: i
            }, e[i.property]);
        return 0
    }
      , r = 0;
    return t.layout.fields.forEach(i=>{
        r += n(i)
    }
    ),
    r
}
function pr(t) {
    let e = 0
      , n = 0;
    for (; ; ) {
        let r = t.shift();
        if (e |= (r & 127) << n * 7,
        n += 1,
        !(r & 128))
            break
    }
    return e
}
function gr(t, e) {
    let n = e;
    for (; ; ) {
        let r = n & 127;
        if (n >>= 7,
        n == 0) {
            t.push(r);
            break
        } else
            r |= 128,
            t.push(r)
    }
}
function Ct(t, e) {
    if (!t)
        throw new Error(e || "Assertion failed")
}
var Id = class t {
    constructor(e, n) {
        this.payer = void 0,
        this.keyMetaMap = void 0,
        this.payer = e,
        this.keyMetaMap = n
    }
    static compile(e, n) {
        let r = new Map
          , i = s=>{
            let a = s.toBase58()
              , c = r.get(a);
            return c === void 0 && (c = {
                isSigner: !1,
                isWritable: !1,
                isInvoked: !1
            },
            r.set(a, c)),
            c
        }
          , o = i(n);
        o.isSigner = !0,
        o.isWritable = !0;
        for (let s of e) {
            i(s.programId).isInvoked = !0;
            for (let a of s.keys) {
                let c = i(a.pubkey);
                c.isSigner ||= a.isSigner,
                c.isWritable ||= a.isWritable
            }
        }
        return new t(n,r)
    }
    getMessageComponents() {
        let e = [...this.keyMetaMap.entries()];
        Ct(e.length <= 256, "Max static account keys length exceeded");
        let n = e.filter(([,c])=>c.isSigner && c.isWritable)
          , r = e.filter(([,c])=>c.isSigner && !c.isWritable)
          , i = e.filter(([,c])=>!c.isSigner && c.isWritable)
          , o = e.filter(([,c])=>!c.isSigner && !c.isWritable)
          , s = {
            numRequiredSignatures: n.length + r.length,
            numReadonlySignedAccounts: r.length,
            numReadonlyUnsignedAccounts: o.length
        };
        {
            Ct(n.length > 0, "Expected at least one writable signer key");
            let[c] = n[0];
            Ct(c === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        let a = [...n.map(([c])=>new le(c)), ...r.map(([c])=>new le(c)), ...i.map(([c])=>new le(c)), ...o.map(([c])=>new le(c))];
        return [s, a]
    }
    extractTableLookup(e) {
        let[n,r] = this.drainKeysFoundInLookupTable(e.state.addresses, s=>!s.isSigner && !s.isInvoked && s.isWritable)
          , [i,o] = this.drainKeysFoundInLookupTable(e.state.addresses, s=>!s.isSigner && !s.isInvoked && !s.isWritable);
        if (!(n.length === 0 && i.length === 0))
            return [{
                accountKey: e.key,
                writableIndexes: n,
                readonlyIndexes: i
            }, {
                writable: r,
                readonly: o
            }]
    }
    drainKeysFoundInLookupTable(e, n) {
        let r = new Array
          , i = new Array;
        for (let[o,s] of this.keyMetaMap.entries())
            if (n(s)) {
                let a = new le(o)
                  , c = e.findIndex(u=>u.equals(a));
                c >= 0 && (Ct(c < 256, "Max lookup table index exceeded"),
                r.push(c),
                i.push(a),
                this.keyMetaMap.delete(o))
            }
        return [r, i]
    }
}
  , mI = "Reached end of buffer unexpectedly";
function Si(t) {
    if (t.length === 0)
        throw new Error(mI);
    return t.shift()
}
function mr(t, ...e) {
    let[n] = e;
    if (e.length === 2 ? n + (e[1] ?? 0) > t.length : n >= t.length)
        throw new Error(mI);
    return t.splice(...e)
}
var ns = class t {
    constructor(e) {
        this.header = void 0,
        this.accountKeys = void 0,
        this.recentBlockhash = void 0,
        this.instructions = void 0,
        this.indexToProgramIds = new Map,
        this.header = e.header,
        this.accountKeys = e.accountKeys.map(n=>new le(n)),
        this.recentBlockhash = e.recentBlockhash,
        this.instructions = e.instructions,
        this.instructions.forEach(n=>this.indexToProgramIds.set(n.programIdIndex, this.accountKeys[n.programIdIndex]))
    }
    get version() {
        return "legacy"
    }
    get staticAccountKeys() {
        return this.accountKeys
    }
    get compiledInstructions() {
        return this.instructions.map(e=>({
            programIdIndex: e.programIdIndex,
            accountKeyIndexes: e.accounts,
            data: fn.default.decode(e.data)
        }))
    }
    get addressTableLookups() {
        return []
    }
    getAccountKeys() {
        return new va(this.staticAccountKeys)
    }
    static compile(e) {
        let n = Id.compile(e.instructions, e.payerKey)
          , [r,i] = n.getMessageComponents()
          , s = new va(i).compileInstructions(e.instructions).map(a=>({
            programIdIndex: a.programIdIndex,
            accounts: a.accountKeyIndexes,
            data: fn.default.encode(a.data)
        }));
        return new t({
            header: r,
            accountKeys: i,
            recentBlockhash: e.recentBlockhash,
            instructions: s
        })
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        let n = this.header.numRequiredSignatures;
        if (e >= this.header.numRequiredSignatures) {
            let r = e - n
              , o = this.accountKeys.length - n - this.header.numReadonlyUnsignedAccounts;
            return r < o
        } else {
            let r = n - this.header.numReadonlySignedAccounts;
            return e < r
        }
    }
    isProgramId(e) {
        return this.indexToProgramIds.has(e)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter((e,n)=>!this.isProgramId(n))
    }
    serialize() {
        let e = this.accountKeys.length
          , n = [];
        gr(n, e);
        let r = this.instructions.map(d=>{
            let {accounts: y, programIdIndex: v} = d
              , E = Array.from(fn.default.decode(d.data))
              , D = [];
            gr(D, y.length);
            let S = [];
            return gr(S, E.length),
            {
                programIdIndex: v,
                keyIndicesCount: _e.Buffer.from(D),
                keyIndices: y,
                dataLength: _e.Buffer.from(S),
                data: E
            }
        }
        )
          , i = [];
        gr(i, r.length);
        let o = _e.Buffer.alloc(ts);
        _e.Buffer.from(i).copy(o);
        let s = i.length;
        r.forEach(d=>{
            let v = L.struct([L.u8("programIdIndex"), L.blob(d.keyIndicesCount.length, "keyIndicesCount"), L.seq(L.u8("keyIndex"), d.keyIndices.length, "keyIndices"), L.blob(d.dataLength.length, "dataLength"), L.seq(L.u8("userdatum"), d.data.length, "data")]).encode(d, o, s);
            s += v
        }
        ),
        o = o.slice(0, s);
        let a = L.struct([L.blob(1, "numRequiredSignatures"), L.blob(1, "numReadonlySignedAccounts"), L.blob(1, "numReadonlyUnsignedAccounts"), L.blob(n.length, "keyCount"), L.seq(He("key"), e, "keys"), He("recentBlockhash")])
          , c = {
            numRequiredSignatures: _e.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: _e.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: _e.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: _e.Buffer.from(n),
            keys: this.accountKeys.map(d=>Ze(d.toBytes())),
            recentBlockhash: fn.default.decode(this.recentBlockhash)
        }
          , u = _e.Buffer.alloc(2048)
          , l = a.encode(c, u);
        return o.copy(u, l),
        u.slice(0, l + o.length)
    }
    static from(e) {
        let n = [...e]
          , r = Si(n);
        if (r !== (r & hI))
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        let i = Si(n)
          , o = Si(n)
          , s = pr(n)
          , a = [];
        for (let y = 0; y < s; y++) {
            let v = mr(n, 0, yo);
            a.push(new le(_e.Buffer.from(v)))
        }
        let c = mr(n, 0, yo)
          , u = pr(n)
          , l = [];
        for (let y = 0; y < u; y++) {
            let v = Si(n)
              , E = pr(n)
              , D = mr(n, 0, E)
              , S = pr(n)
              , w = mr(n, 0, S)
              , M = fn.default.encode(_e.Buffer.from(w));
            l.push({
                programIdIndex: v,
                accounts: D,
                data: M
            })
        }
        let d = {
            header: {
                numRequiredSignatures: r,
                numReadonlySignedAccounts: i,
                numReadonlyUnsignedAccounts: o
            },
            recentBlockhash: fn.default.encode(_e.Buffer.from(c)),
            accountKeys: a,
            instructions: l
        };
        return new t(d)
    }
}
  , Zy = class t {
    constructor(e) {
        this.header = void 0,
        this.staticAccountKeys = void 0,
        this.recentBlockhash = void 0,
        this.compiledInstructions = void 0,
        this.addressTableLookups = void 0,
        this.header = e.header,
        this.staticAccountKeys = e.staticAccountKeys,
        this.recentBlockhash = e.recentBlockhash,
        this.compiledInstructions = e.compiledInstructions,
        this.addressTableLookups = e.addressTableLookups
    }
    get version() {
        return 0
    }
    get numAccountKeysFromLookups() {
        let e = 0;
        for (let n of this.addressTableLookups)
            e += n.readonlyIndexes.length + n.writableIndexes.length;
        return e
    }
    getAccountKeys(e) {
        let n;
        if (e && "accountKeysFromLookups"in e && e.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length)
                throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            n = e.accountKeysFromLookups
        } else if (e && "addressLookupTableAccounts"in e && e.addressLookupTableAccounts)
            n = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0)
            throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new va(this.staticAccountKeys,n)
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        let n = this.header.numRequiredSignatures
          , r = this.staticAccountKeys.length;
        if (e >= r) {
            let i = e - r
              , o = this.addressTableLookups.reduce((s,a)=>s + a.writableIndexes.length, 0);
            return i < o
        } else if (e >= this.header.numRequiredSignatures) {
            let i = e - n
              , s = r - n - this.header.numReadonlyUnsignedAccounts;
            return i < s
        } else {
            let i = n - this.header.numReadonlySignedAccounts;
            return e < i
        }
    }
    resolveAddressTableLookups(e) {
        let n = {
            writable: [],
            readonly: []
        };
        for (let r of this.addressTableLookups) {
            let i = e.find(o=>o.key.equals(r.accountKey));
            if (!i)
                throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);
            for (let o of r.writableIndexes)
                if (o < i.state.addresses.length)
                    n.writable.push(i.state.addresses[o]);
                else
                    throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);
            for (let o of r.readonlyIndexes)
                if (o < i.state.addresses.length)
                    n.readonly.push(i.state.addresses[o]);
                else
                    throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)
        }
        return n
    }
    static compile(e) {
        let n = Id.compile(e.instructions, e.payerKey)
          , r = new Array
          , i = {
            writable: new Array,
            readonly: new Array
        }
          , o = e.addressLookupTableAccounts || [];
        for (let l of o) {
            let d = n.extractTableLookup(l);
            if (d !== void 0) {
                let[y,{writable: v, readonly: E}] = d;
                r.push(y),
                i.writable.push(...v),
                i.readonly.push(...E)
            }
        }
        let[s,a] = n.getMessageComponents()
          , u = new va(a,i).compileInstructions(e.instructions);
        return new t({
            header: s,
            staticAccountKeys: a,
            recentBlockhash: e.recentBlockhash,
            compiledInstructions: u,
            addressTableLookups: r
        })
    }
    serialize() {
        let e = Array();
        gr(e, this.staticAccountKeys.length);
        let n = this.serializeInstructions()
          , r = Array();
        gr(r, this.compiledInstructions.length);
        let i = this.serializeAddressTableLookups()
          , o = Array();
        gr(o, this.addressTableLookups.length);
        let s = L.struct([L.u8("prefix"), L.struct([L.u8("numRequiredSignatures"), L.u8("numReadonlySignedAccounts"), L.u8("numReadonlyUnsignedAccounts")], "header"), L.blob(e.length, "staticAccountKeysLength"), L.seq(He(), this.staticAccountKeys.length, "staticAccountKeys"), He("recentBlockhash"), L.blob(r.length, "instructionsLength"), L.blob(n.length, "serializedInstructions"), L.blob(o.length, "addressTableLookupsLength"), L.blob(i.length, "serializedAddressTableLookups")])
          , a = new Uint8Array(ts)
          , u = s.encode({
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(e),
            staticAccountKeys: this.staticAccountKeys.map(l=>l.toBytes()),
            recentBlockhash: fn.default.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(r),
            serializedInstructions: n,
            addressTableLookupsLength: new Uint8Array(o),
            serializedAddressTableLookups: i
        }, a);
        return a.slice(0, u)
    }
    serializeInstructions() {
        let e = 0
          , n = new Uint8Array(ts);
        for (let r of this.compiledInstructions) {
            let i = Array();
            gr(i, r.accountKeyIndexes.length);
            let o = Array();
            gr(o, r.data.length);
            let s = L.struct([L.u8("programIdIndex"), L.blob(i.length, "encodedAccountKeyIndexesLength"), L.seq(L.u8(), r.accountKeyIndexes.length, "accountKeyIndexes"), L.blob(o.length, "encodedDataLength"), L.blob(r.data.length, "data")]);
            e += s.encode({
                programIdIndex: r.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(i),
                accountKeyIndexes: r.accountKeyIndexes,
                encodedDataLength: new Uint8Array(o),
                data: r.data
            }, n, e)
        }
        return n.slice(0, e)
    }
    serializeAddressTableLookups() {
        let e = 0
          , n = new Uint8Array(ts);
        for (let r of this.addressTableLookups) {
            let i = Array();
            gr(i, r.writableIndexes.length);
            let o = Array();
            gr(o, r.readonlyIndexes.length);
            let s = L.struct([He("accountKey"), L.blob(i.length, "encodedWritableIndexesLength"), L.seq(L.u8(), r.writableIndexes.length, "writableIndexes"), L.blob(o.length, "encodedReadonlyIndexesLength"), L.seq(L.u8(), r.readonlyIndexes.length, "readonlyIndexes")]);
            e += s.encode({
                accountKey: r.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(i),
                writableIndexes: r.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(o),
                readonlyIndexes: r.readonlyIndexes
            }, n, e)
        }
        return n.slice(0, e)
    }
    static deserialize(e) {
        let n = [...e]
          , r = Si(n)
          , i = r & hI;
        Ct(r !== i, "Expected versioned message but received legacy message");
        let o = i;
        Ct(o === 0, `Expected versioned message with version 0 but found version ${o}`);
        let s = {
            numRequiredSignatures: Si(n),
            numReadonlySignedAccounts: Si(n),
            numReadonlyUnsignedAccounts: Si(n)
        }
          , a = []
          , c = pr(n);
        for (let E = 0; E < c; E++)
            a.push(new le(mr(n, 0, yo)));
        let u = fn.default.encode(mr(n, 0, yo))
          , l = pr(n)
          , d = [];
        for (let E = 0; E < l; E++) {
            let D = Si(n)
              , S = pr(n)
              , w = mr(n, 0, S)
              , M = pr(n)
              , F = new Uint8Array(mr(n, 0, M));
            d.push({
                programIdIndex: D,
                accountKeyIndexes: w,
                data: F
            })
        }
        let y = pr(n)
          , v = [];
        for (let E = 0; E < y; E++) {
            let D = new le(mr(n, 0, yo))
              , S = pr(n)
              , w = mr(n, 0, S)
              , M = pr(n)
              , F = mr(n, 0, M);
            v.push({
                accountKey: D,
                writableIndexes: w,
                readonlyIndexes: F
            })
        }
        return new t({
            header: s,
            staticAccountKeys: a,
            recentBlockhash: u,
            compiledInstructions: d,
            addressTableLookups: v
        })
    }
}
;
var go = function(t) {
    return t[t.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED",
    t[t.PROCESSED = 1] = "PROCESSED",
    t[t.TIMED_OUT = 2] = "TIMED_OUT",
    t[t.NONCE_INVALID = 3] = "NONCE_INVALID",
    t
}({})
  , TN = _e.Buffer.alloc(pI).fill(0)
  , Te = class {
    constructor(e) {
        this.keys = void 0,
        this.programId = void 0,
        this.data = _e.Buffer.alloc(0),
        this.programId = e.programId,
        this.keys = e.keys,
        e.data && (this.data = e.data)
    }
    toJSON() {
        return {
            keys: this.keys.map(({pubkey: e, isSigner: n, isWritable: r})=>({
                pubkey: e.toJSON(),
                isSigner: n,
                isWritable: r
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
  , Se = class t {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor(e) {
        if (this.signatures = [],
        this.feePayer = void 0,
        this.instructions = [],
        this.recentBlockhash = void 0,
        this.lastValidBlockHeight = void 0,
        this.nonceInfo = void 0,
        this.minNonceContextSlot = void 0,
        this._message = void 0,
        this._json = void 0,
        !!e)
            if (e.feePayer && (this.feePayer = e.feePayer),
            e.signatures && (this.signatures = e.signatures),
            Object.prototype.hasOwnProperty.call(e, "nonceInfo")) {
                let {minContextSlot: n, nonceInfo: r} = e;
                this.minNonceContextSlot = n,
                this.nonceInfo = r
            } else if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                let {blockhash: n, lastValidBlockHeight: r} = e;
                this.recentBlockhash = n,
                this.lastValidBlockHeight = r
            } else {
                let {recentBlockhash: n, nonceInfo: r} = e;
                r && (this.nonceInfo = r),
                this.recentBlockhash = n
            }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(e=>e.toJSON()),
            signers: this.signatures.map(({publicKey: e})=>e.toJSON())
        }
    }
    add(...e) {
        if (e.length === 0)
            throw new Error("No instructions");
        return e.forEach(n=>{
            "instructions"in n ? this.instructions = this.instructions.concat(n.instructions) : "data"in n && "programId"in n && "keys"in n ? this.instructions.push(n) : this.instructions.push(new Te(n))
        }
        ),
        this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
            return this._message;
        let e, n;
        if (this.nonceInfo ? (e = this.nonceInfo.nonce,
        this.instructions[0] != this.nonceInfo.nonceInstruction ? n = [this.nonceInfo.nonceInstruction, ...this.instructions] : n = this.instructions) : (e = this.recentBlockhash,
        n = this.instructions),
        !e)
            throw new Error("Transaction recentBlockhash required");
        n.length < 1 && console.warn("No instructions provided");
        let r;
        if (this.feePayer)
            r = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey)
            r = this.signatures[0].publicKey;
        else
            throw new Error("Transaction fee payer required");
        for (let D = 0; D < n.length; D++)
            if (n[D].programId === void 0)
                throw new Error(`Transaction instruction index ${D} has undefined program id`);
        let i = []
          , o = [];
        n.forEach(D=>{
            D.keys.forEach(w=>{
                o.push(ee({}, w))
            }
            );
            let S = D.programId.toString();
            i.includes(S) || i.push(S)
        }
        ),
        i.forEach(D=>{
            o.push({
                pubkey: new le(D),
                isSigner: !1,
                isWritable: !1
            })
        }
        );
        let s = [];
        o.forEach(D=>{
            let S = D.pubkey.toString()
              , w = s.findIndex(M=>M.pubkey.toString() === S);
            w > -1 ? (s[w].isWritable = s[w].isWritable || D.isWritable,
            s[w].isSigner = s[w].isSigner || D.isSigner) : s.push(D)
        }
        ),
        s.sort(function(D, S) {
            if (D.isSigner !== S.isSigner)
                return D.isSigner ? -1 : 1;
            if (D.isWritable !== S.isWritable)
                return D.isWritable ? -1 : 1;
            let w = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return D.pubkey.toBase58().localeCompare(S.pubkey.toBase58(), "en", w)
        });
        let a = s.findIndex(D=>D.pubkey.equals(r));
        if (a > -1) {
            let[D] = s.splice(a, 1);
            D.isSigner = !0,
            D.isWritable = !0,
            s.unshift(D)
        } else
            s.unshift({
                pubkey: r,
                isSigner: !0,
                isWritable: !0
            });
        for (let D of this.signatures) {
            let S = s.findIndex(w=>w.pubkey.equals(D.publicKey));
            if (S > -1)
                s[S].isSigner || (s[S].isSigner = !0,
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else
                throw new Error(`unknown signer: ${D.publicKey.toString()}`)
        }
        let c = 0
          , u = 0
          , l = 0
          , d = []
          , y = [];
        s.forEach(({pubkey: D, isSigner: S, isWritable: w})=>{
            S ? (d.push(D.toString()),
            c += 1,
            w || (u += 1)) : (y.push(D.toString()),
            w || (l += 1))
        }
        );
        let v = d.concat(y)
          , E = n.map(D=>{
            let {data: S, programId: w} = D;
            return {
                programIdIndex: v.indexOf(w.toString()),
                accounts: D.keys.map(M=>v.indexOf(M.pubkey.toString())),
                data: fn.default.encode(S)
            }
        }
        );
        return E.forEach(D=>{
            Ct(D.programIdIndex >= 0),
            D.accounts.forEach(S=>Ct(S >= 0))
        }
        ),
        new ns({
            header: {
                numRequiredSignatures: c,
                numReadonlySignedAccounts: u,
                numReadonlyUnsignedAccounts: l
            },
            accountKeys: v,
            recentBlockhash: e,
            instructions: E
        })
    }
    _compile() {
        let e = this.compileMessage()
          , n = e.accountKeys.slice(0, e.header.numRequiredSignatures);
        return this.signatures.length === n.length && this.signatures.every((i,o)=>n[o].equals(i.publicKey)) || (this.signatures = n.map(r=>({
            signature: null,
            publicKey: r
        }))),
        e
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    getEstimatedFee(e) {
        return $(this, null, function*() {
            return (yield e.getFeeForMessage(this.compileMessage())).value
        })
    }
    setSigners(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        let n = new Set;
        this.signatures = e.filter(r=>{
            let i = r.toString();
            return n.has(i) ? !1 : (n.add(i),
            !0)
        }
        ).map(r=>({
            signature: null,
            publicKey: r
        }))
    }
    sign(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        let n = new Set
          , r = [];
        for (let o of e) {
            let s = o.publicKey.toString();
            n.has(s) || (n.add(s),
            r.push(o))
        }
        this.signatures = r.map(o=>({
            signature: null,
            publicKey: o.publicKey
        }));
        let i = this._compile();
        this._partialSign(i, ...r)
    }
    partialSign(...e) {
        if (e.length === 0)
            throw new Error("No signers");
        let n = new Set
          , r = [];
        for (let o of e) {
            let s = o.publicKey.toString();
            n.has(s) || (n.add(s),
            r.push(o))
        }
        let i = this._compile();
        this._partialSign(i, ...r)
    }
    _partialSign(e, ...n) {
        let r = e.serialize();
        n.forEach(i=>{
            let o = fI(r, i.secretKey);
            this._addSignature(i.publicKey, Ze(o))
        }
        )
    }
    addSignature(e, n) {
        this._compile(),
        this._addSignature(e, n)
    }
    _addSignature(e, n) {
        Ct(n.length === 64);
        let r = this.signatures.findIndex(i=>e.equals(i.publicKey));
        if (r < 0)
            throw new Error(`unknown signer: ${e.toString()}`);
        this.signatures[r].signature = _e.Buffer.from(n)
    }
    verifySignatures(e=!0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), e)
    }
    _getMessageSignednessErrors(e, n) {
        let r = {};
        for (let {signature: i, publicKey: o} of this.signatures)
            i === null ? n && (r.missing ||= []).push(o) : DN(i, e, o.toBytes()) || (r.invalid ||= []).push(o);
        return r.invalid || r.missing ? r : void 0
    }
    serialize(e) {
        let {requireAllSignatures: n, verifySignatures: r} = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, e)
          , i = this.serializeMessage();
        if (r) {
            let o = this._getMessageSignednessErrors(i, n);
            if (o) {
                let s = "Signature verification failed.";
                throw o.invalid && (s += `
Invalid signature for public key${o.invalid.length === 1 ? "" : "(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),
                o.missing && (s += `
Missing signature for public key${o.missing.length === 1 ? "" : "(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),
                new Error(s)
            }
        }
        return this._serialize(i)
    }
    _serialize(e) {
        let {signatures: n} = this
          , r = [];
        gr(r, n.length);
        let i = r.length + n.length * 64 + e.length
          , o = _e.Buffer.alloc(i);
        return Ct(n.length < 256),
        _e.Buffer.from(r).copy(o, 0),
        n.forEach(({signature: s},a)=>{
            s !== null && (Ct(s.length === 64, "signature has invalid length"),
            _e.Buffer.from(s).copy(o, r.length + a * 64))
        }
        ),
        e.copy(o, r.length + n.length * 64),
        Ct(o.length <= ts, `Transaction too large: ${o.length} > ${ts}`),
        o
    }
    get keys() {
        return Ct(this.instructions.length === 1),
        this.instructions[0].keys.map(e=>e.pubkey)
    }
    get programId() {
        return Ct(this.instructions.length === 1),
        this.instructions[0].programId
    }
    get data() {
        return Ct(this.instructions.length === 1),
        this.instructions[0].data
    }
    static from(e) {
        let n = [...e]
          , r = pr(n)
          , i = [];
        for (let o = 0; o < r; o++) {
            let s = mr(n, 0, pI);
            i.push(fn.default.encode(_e.Buffer.from(s)))
        }
        return t.populate(ns.from(n), i)
    }
    static populate(e, n=[]) {
        let r = new t;
        return r.recentBlockhash = e.recentBlockhash,
        e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]),
        n.forEach((i,o)=>{
            let s = {
                signature: i == fn.default.encode(TN) ? null : fn.default.decode(i),
                publicKey: e.accountKeys[o]
            };
            r.signatures.push(s)
        }
        ),
        e.instructions.forEach(i=>{
            let o = i.accounts.map(s=>{
                let a = e.accountKeys[s];
                return {
                    pubkey: a,
                    isSigner: r.signatures.some(c=>c.publicKey.toString() === a.toString()) || e.isAccountSigner(s),
                    isWritable: e.isAccountWritable(s)
                }
            }
            );
            r.instructions.push(new Te({
                keys: o,
                programId: e.accountKeys[i.programIdIndex],
                data: fn.default.decode(i.data)
            }))
        }
        ),
        r._message = e,
        r._json = r.toJSON(),
        r
    }
}
;
var BN = 160
  , RN = 64
  , FN = BN / RN
  , NN = 1e3 / FN
  , _i = new le("SysvarC1ock11111111111111111111111111111111")
  , yz = new le("SysvarEpochSchedu1e111111111111111111111111")
  , vz = new le("Sysvar1nstructions1111111111111111111111111")
  , Vy = new le("SysvarRecentB1ockHashes11111111111111111111")
  , Mi = new le("SysvarRent111111111111111111111111111111111")
  , xz = new le("SysvarRewards111111111111111111111111111111")
  , wz = new le("SysvarS1otHashes111111111111111111111111111")
  , bz = new le("SysvarS1otHistory11111111111111111111111111")
  , jy = new le("SysvarStakeHistory1111111111111111111111111")
  , Jc = class extends Error {
    constructor({action: e, signature: n, transactionMessage: r, logs: i}) {
        let o = i ? `Logs: 
${JSON.stringify(i.slice(-10), null, 2)}. ` : "", s = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.", a;
        switch (e) {
        case "send":
            a = `Transaction ${n} resulted in an error. 
${r}. ` + o + s;
            break;
        case "simulate":
            a = `Simulation failed. 
Message: ${r}. 
` + o + s;
            break;
        default:
            a = `Unknown action '${(c=>c)(e)}'`
        }
        super(a),
        this.signature = void 0,
        this.transactionMessage = void 0,
        this.transactionLogs = void 0,
        this.signature = n,
        this.transactionMessage = r,
        this.transactionLogs = i || void 0
    }
    get transactionError() {
        return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        }
    }
    get logs() {
        let e = this.transactionLogs;
        if (!(e != null && typeof e == "object" && "then"in e))
            return e
    }
    getLogs(e) {
        return $(this, null, function*() {
            return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise((n,r)=>{
                e.getTransaction(this.signature).then(i=>{
                    if (i && i.meta && i.meta.logMessages) {
                        let o = i.meta.logMessages;
                        this.transactionLogs = o,
                        n(o)
                    } else
                        r(new Error("Log messages not found"))
                }
                ).catch(r)
            }
            )),
            yield this.transactionLogs
        })
    }
}
;
var ge = class extends Error {
    constructor({code: e, message: n, data: r}, i) {
        super(i != null ? `${i}: ${n}` : n),
        this.code = void 0,
        this.data = void 0,
        this.code = e,
        this.data = r,
        this.name = "SolanaJSONRPCError"
    }
}
;
function yI(t, e, n, r) {
    return $(this, null, function*() {
        let i = r && {
            skipPreflight: r.skipPreflight,
            preflightCommitment: r.preflightCommitment || r.commitment,
            maxRetries: r.maxRetries,
            minContextSlot: r.minContextSlot
        }, o = yield t.sendTransaction(e, n, i), s;
        if (e.recentBlockhash != null && e.lastValidBlockHeight != null)
            s = (yield t.confirmTransaction({
                abortSignal: r?.abortSignal,
                signature: o,
                blockhash: e.recentBlockhash,
                lastValidBlockHeight: e.lastValidBlockHeight
            }, r && r.commitment)).value;
        else if (e.minNonceContextSlot != null && e.nonceInfo != null) {
            let {nonceInstruction: a} = e.nonceInfo
              , c = a.keys[0].pubkey;
            s = (yield t.confirmTransaction({
                abortSignal: r?.abortSignal,
                minContextSlot: e.minNonceContextSlot,
                nonceAccountPubkey: c,
                nonceValue: e.nonceInfo.nonce,
                signature: o
            }, r && r.commitment)).value
        } else
            r?.abortSignal != null && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),
            s = (yield t.confirmTransaction(o, r && r.commitment)).value;
        if (s.err)
            throw o != null ? new Jc({
                action: "send",
                signature: o,
                transactionMessage: `Status: (${JSON.stringify(s)})`
            }) : new Error(`Transaction ${o} failed (${JSON.stringify(s)})`);
        return o
    })
}
function ma(t) {
    return new Promise(e=>setTimeout(e, t))
}
function tt(t, e) {
    let n = t.layout.span >= 0 ? t.layout.span : gI(t, e)
      , r = _e.Buffer.alloc(n)
      , i = Object.assign({
        instruction: t.index
    }, e);
    return t.layout.encode(i, r),
    r
}
var PN = L.nu64("lamportsPerSignature")
  , vI = L.struct([L.u32("version"), L.u32("state"), He("authorizedPubkey"), He("nonce"), L.struct([PN], "feeCalculator")])
  , XD = vI.span
  , Xy = class t {
    constructor(e) {
        this.authorizedPubkey = void 0,
        this.nonce = void 0,
        this.feeCalculator = void 0,
        this.authorizedPubkey = e.authorizedPubkey,
        this.nonce = e.nonce,
        this.feeCalculator = e.feeCalculator
    }
    static fromAccountData(e) {
        let n = vI.decode(Ze(e), 0);
        return new t({
            authorizedPubkey: new le(n.authorizedPubkey),
            nonce: new le(n.nonce).toString(),
            feeCalculator: n.feeCalculator
        })
    }
}
  , ON = t=>{
    let e = t.decode.bind(t)
      , n = t.encode.bind(t);
    return {
        decode: e,
        encode: n
    }
}
  , LN = t=>e=>{
    let n = (0,
    uI.blob)(t, e)
      , {encode: r, decode: i} = ON(n)
      , o = n;
    return o.decode = (s,a)=>{
        let c = i(s, a);
        return (0,
        nu.toBigIntLE)(_e.Buffer.from(c))
    }
    ,
    o.encode = (s,a,c)=>{
        let u = (0,
        nu.toBufferLE)(s, t);
        return r(u, a, c)
    }
    ,
    o
}
  , xa = LN(8);
var hr = Object.freeze({
    Create: {
        index: 0,
        layout: L.struct([L.u32("instruction"), L.ns64("lamports"), L.ns64("space"), He("programId")])
    },
    Assign: {
        index: 1,
        layout: L.struct([L.u32("instruction"), He("programId")])
    },
    Transfer: {
        index: 2,
        layout: L.struct([L.u32("instruction"), xa("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: L.struct([L.u32("instruction"), He("base"), ya("seed"), L.ns64("lamports"), L.ns64("space"), He("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: L.struct([L.u32("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: L.struct([L.u32("instruction"), L.ns64("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: L.struct([L.u32("instruction"), He("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: L.struct([L.u32("instruction"), He("authorized")])
    },
    Allocate: {
        index: 8,
        layout: L.struct([L.u32("instruction"), L.ns64("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: L.struct([L.u32("instruction"), He("base"), ya("seed"), L.ns64("space"), He("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: L.struct([L.u32("instruction"), He("base"), ya("seed"), He("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: L.struct([L.u32("instruction"), xa("lamports"), ya("seed"), He("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: L.struct([L.u32("instruction")])
    }
})
  , Xt = class t {
    constructor() {}
    static createAccount(e) {
        let n = hr.Create
          , r = tt(n, {
            lamports: e.lamports,
            space: e.space,
            programId: Ze(e.programId.toBuffer())
        });
        return new Te({
            keys: [{
                pubkey: e.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: e.newAccountPubkey,
                isSigner: !0,
                isWritable: !0
            }],
            programId: this.programId,
            data: r
        })
    }
    static transfer(e) {
        let n, r;
        if ("basePubkey"in e) {
            let i = hr.TransferWithSeed;
            n = tt(i, {
                lamports: BigInt(e.lamports),
                seed: e.seed,
                programId: Ze(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.fromPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        } else {
            let i = hr.Transfer;
            n = tt(i, {
                lamports: BigInt(e.lamports)
            }),
            r = [{
                pubkey: e.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        }
        return new Te({
            keys: r,
            programId: this.programId,
            data: n
        })
    }
    static assign(e) {
        let n, r;
        if ("basePubkey"in e) {
            let i = hr.AssignWithSeed;
            n = tt(i, {
                base: Ze(e.basePubkey.toBuffer()),
                seed: e.seed,
                programId: Ze(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            let i = hr.Assign;
            n = tt(i, {
                programId: Ze(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new Te({
            keys: r,
            programId: this.programId,
            data: n
        })
    }
    static createAccountWithSeed(e) {
        let n = hr.CreateWithSeed
          , r = tt(n, {
            base: Ze(e.basePubkey.toBuffer()),
            seed: e.seed,
            lamports: e.lamports,
            space: e.space,
            programId: Ze(e.programId.toBuffer())
        })
          , i = [{
            pubkey: e.fromPubkey,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: e.newAccountPubkey,
            isSigner: !1,
            isWritable: !0
        }];
        return e.basePubkey != e.fromPubkey && i.push({
            pubkey: e.basePubkey,
            isSigner: !0,
            isWritable: !1
        }),
        new Te({
            keys: i,
            programId: this.programId,
            data: r
        })
    }
    static createNonceAccount(e) {
        let n = new Se;
        "basePubkey"in e && "seed"in e ? n.add(t.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: XD,
            programId: this.programId
        })) : n.add(t.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.noncePubkey,
            lamports: e.lamports,
            space: XD,
            programId: this.programId
        }));
        let r = {
            noncePubkey: e.noncePubkey,
            authorizedPubkey: e.authorizedPubkey
        };
        return n.add(this.nonceInitialize(r)),
        n
    }
    static nonceInitialize(e) {
        let n = hr.InitializeNonceAccount
          , r = tt(n, {
            authorized: Ze(e.authorizedPubkey.toBuffer())
        })
          , i = {
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Vy,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: Mi,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        };
        return new Te(i)
    }
    static nonceAdvance(e) {
        let n = hr.AdvanceNonceAccount
          , r = tt(n)
          , i = {
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Vy,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        };
        return new Te(i)
    }
    static nonceWithdraw(e) {
        let n = hr.WithdrawNonceAccount
          , r = tt(n, {
            lamports: e.lamports
        });
        return new Te({
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.toPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Vy,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: Mi,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        })
    }
    static nonceAuthorize(e) {
        let n = hr.AuthorizeNonceAccount
          , r = tt(n, {
            authorized: Ze(e.newAuthorizedPubkey.toBuffer())
        });
        return new Te({
            keys: [{
                pubkey: e.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: r
        })
    }
    static allocate(e) {
        let n, r;
        if ("basePubkey"in e) {
            let i = hr.AllocateWithSeed;
            n = tt(i, {
                base: Ze(e.basePubkey.toBuffer()),
                seed: e.seed,
                space: e.space,
                programId: Ze(e.programId.toBuffer())
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            let i = hr.Allocate;
            n = tt(i, {
                space: e.space
            }),
            r = [{
                pubkey: e.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new Te({
            keys: r,
            programId: this.programId,
            data: n
        })
    }
}
;
Xt.programId = new le("11111111111111111111111111111111");
var Ez = ts - 300;
var Cz = new le("BPFLoader2111111111111111111111111111111111");
function UN(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var VN = Object.prototype.toString
  , jN = Object.keys || function(t) {
    var e = [];
    for (var n in t)
        e.push(n);
    return e
}
;
function Qc(t, e) {
    var n, r, i, o, s, a, c;
    if (t === !0)
        return "true";
    if (t === !1)
        return "false";
    switch (typeof t) {
    case "object":
        if (t === null)
            return null;
        if (t.toJSON && typeof t.toJSON == "function")
            return Qc(t.toJSON(), e);
        if (c = VN.call(t),
        c === "[object Array]") {
            for (i = "[",
            r = t.length - 1,
            n = 0; n < r; n++)
                i += Qc(t[n], !0) + ",";
            return r > -1 && (i += Qc(t[n], !0)),
            i + "]"
        } else if (c === "[object Object]") {
            for (o = jN(t).sort(),
            r = o.length,
            i = "",
            n = 0; n < r; )
                s = o[n],
                a = Qc(t[s], !1),
                a !== void 0 && (i && (i += ","),
                i += JSON.stringify(s) + ":" + a),
                n++;
            return "{" + i + "}"
        } else
            return JSON.stringify(t);
    case "function":
    case "undefined":
        return e ? null : void 0;
    case "string":
        return JSON.stringify(t);
    default:
        return isFinite(t) ? t : null
    }
}
var $N = function(t) {
    var e = Qc(t, !1);
    if (e !== void 0)
        return "" + e
}
  , QD = UN($N)
  , Yc = 32;
function $y(t) {
    let e = 0;
    for (; t > 1; )
        t /= 2,
        e++;
    return e
}
function HN(t) {
    return t === 0 ? 1 : (t--,
    t |= t >> 1,
    t |= t >> 2,
    t |= t >> 4,
    t |= t >> 8,
    t |= t >> 16,
    t |= t >> 32,
    t + 1)
}
var Qy = class {
    constructor(e, n, r, i, o) {
        this.slotsPerEpoch = void 0,
        this.leaderScheduleSlotOffset = void 0,
        this.warmup = void 0,
        this.firstNormalEpoch = void 0,
        this.firstNormalSlot = void 0,
        this.slotsPerEpoch = e,
        this.leaderScheduleSlotOffset = n,
        this.warmup = r,
        this.firstNormalEpoch = i,
        this.firstNormalSlot = o
    }
    getEpoch(e) {
        return this.getEpochAndSlotIndex(e)[0]
    }
    getEpochAndSlotIndex(e) {
        if (e < this.firstNormalSlot) {
            let n = $y(HN(e + Yc + 1)) - $y(Yc) - 1
              , r = this.getSlotsInEpoch(n)
              , i = e - (r - Yc);
            return [n, i]
        } else {
            let n = e - this.firstNormalSlot
              , r = Math.floor(n / this.slotsPerEpoch)
              , i = this.firstNormalEpoch + r
              , o = n % this.slotsPerEpoch;
            return [i, o]
        }
    }
    getFirstSlotInEpoch(e) {
        return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * Yc : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch(e) {
        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
    }
    getSlotsInEpoch(e) {
        return e < this.firstNormalEpoch ? Math.pow(2, e + $y(Yc)) : this.slotsPerEpoch
    }
}
  , zN = globalThis.fetch
  , Jy = class extends ND {
    constructor(e, n, r) {
        let i = o=>{
            let s = FD(o, ee({
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3
            }, n));
            return "socket"in s ? this.underlyingSocket = s.socket : this.underlyingSocket = s,
            s
        }
        ;
        super(i, e, n, r),
        this.underlyingSocket = void 0
    }
    call(...e) {
        let n = this.underlyingSocket?.readyState;
        return n === 1 ? super.call(...e) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + n + ")"))
    }
    notify(...e) {
        let n = this.underlyingSocket?.readyState;
        return n === 1 ? super.notify(...e) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + n + ")"))
    }
}
;
function qN(t, e) {
    let n;
    try {
        n = t.layout.decode(e)
    } catch (r) {
        throw new Error("invalid instruction; " + r)
    }
    if (n.typeIndex !== t.index)
        throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`);
    return n
}
var JD = 56
  , Ad = class {
    constructor(e) {
        this.key = void 0,
        this.state = void 0,
        this.key = e.key,
        this.state = e.state
    }
    isActive() {
        let e = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === e
    }
    static deserialize(e) {
        let n = qN(WN, e)
          , r = e.length - JD;
        Ct(r >= 0, "lookup table is invalid"),
        Ct(r % 32 === 0, "lookup table is invalid");
        let i = r / 32
          , {addresses: o} = L.struct([L.seq(He(), i, "addresses")]).decode(e.slice(JD));
        return {
            deactivationSlot: n.deactivationSlot,
            lastExtendedSlot: n.lastExtendedSlot,
            lastExtendedSlotStartIndex: n.lastExtendedStartIndex,
            authority: n.authority.length !== 0 ? new le(n.authority[0]) : void 0,
            addresses: o.map(s=>new le(s))
        }
    }
}
  , WN = {
    index: 1,
    layout: L.struct([L.u32("typeIndex"), xa("deactivationSlot"), L.nu64("lastExtendedSlot"), L.u8("lastExtendedStartIndex"), L.u8(), L.seq(He(), L.offset(L.u8(), -1), "authority")])
}
  , GN = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function KN(t) {
    let e = t.match(GN);
    if (e == null)
        throw TypeError(`Failed to validate endpoint URL \`${t}\``);
    let[n,r,i,o] = e
      , s = t.startsWith("https:") ? "wss:" : "ws:"
      , a = i == null ? null : parseInt(i.slice(1), 10)
      , c = a == null ? "" : `:${a + 1}`;
    return `${s}//${r}${c}${o}`
}
var Tt = ga(ud(le), oe(), t=>new le(t))
  , xI = ld([oe(), At("base64")])
  , av = ga(ud(_e.Buffer), xI, t=>_e.Buffer.from(t[0], "base64"))
  , YN = 30 * 1e3;
function ZN(t) {
    if (/^https?:/.test(t) === !1)
        throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return t
}
function Et(t) {
    let e, n;
    if (typeof t == "string")
        e = t;
    else if (t) {
        let r = t
          , {commitment: i} = r
          , o = Nr(r, ["commitment"]);
        e = i,
        n = o
    }
    return {
        commitment: e,
        config: n
    }
}
function wI(t) {
    return An([re({
        jsonrpc: At("2.0"),
        id: oe(),
        result: t
    }), re({
        jsonrpc: At("2.0"),
        id: oe(),
        error: re({
            code: Qo(),
            message: oe(),
            data: De(sD())
        })
    })])
}
var XN = wI(Qo());
function Le(t) {
    return ga(wI(t), XN, e=>"error"in e ? e : me(ee({}, e), {
        result: ae(e.result, t)
    }))
}
function Vt(t) {
    return Le(re({
        context: re({
            slot: H()
        }),
        value: t
    }))
}
function Td(t) {
    return re({
        context: re({
            slot: H()
        }),
        value: t
    })
}
function Hy(t, e) {
    return t === 0 ? new Zy({
        header: e.header,
        staticAccountKeys: e.accountKeys.map(n=>new le(n)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map(n=>({
            programIdIndex: n.programIdIndex,
            accountKeyIndexes: n.accounts,
            data: fn.default.decode(n.data)
        })),
        addressTableLookups: e.addressTableLookups
    }) : new ns(e)
}
var QN = re({
    foundation: H(),
    foundationTerm: H(),
    initial: H(),
    taper: H(),
    terminal: H()
})
  , JN = Le(ce(ue(re({
    epoch: H(),
    effectiveSlot: H(),
    amount: H(),
    postBalance: H(),
    commission: De(ue(H()))
}))))
  , eP = ce(re({
    slot: H(),
    prioritizationFee: H()
}))
  , tP = re({
    total: H(),
    validator: H(),
    foundation: H(),
    epoch: H()
})
  , nP = re({
    epoch: H(),
    slotIndex: H(),
    slotsInEpoch: H(),
    absoluteSlot: H(),
    blockHeight: De(H()),
    transactionCount: De(H())
})
  , rP = re({
    slotsPerEpoch: H(),
    leaderScheduleSlotOffset: H(),
    warmup: Rr(),
    firstNormalEpoch: H(),
    firstNormalSlot: H()
})
  , iP = Iy(oe(), ce(H()))
  , rs = ue(An([re({}), oe()]))
  , oP = re({
    err: rs
})
  , sP = At("receivedSignature")
  , aP = re({
    "solana-core": oe(),
    "feature-set": De(H())
})
  , cP = re({
    program: oe(),
    programId: Tt,
    parsed: Qo()
})
  , uP = re({
    programId: Tt,
    accounts: ce(Tt),
    data: oe()
})
  , eI = Vt(re({
    err: ue(An([re({}), oe()])),
    logs: ue(ce(oe())),
    accounts: De(ue(ce(ue(re({
        executable: Rr(),
        owner: oe(),
        lamports: H(),
        data: ce(oe()),
        rentEpoch: De(H())
    }))))),
    unitsConsumed: De(H()),
    returnData: De(ue(re({
        programId: oe(),
        data: ld([oe(), At("base64")])
    }))),
    innerInstructions: De(ue(ce(re({
        index: H(),
        instructions: ce(An([cP, uP]))
    }))))
}))
  , lP = Vt(re({
    byIdentity: Iy(oe(), ce(H())),
    range: re({
        firstSlot: H(),
        lastSlot: H()
    })
}));
function fP(t, e, n, r, i, o) {
    let s = n || zN, a;
    o != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let c;
    return r && (c = (l,d)=>$(this, null, function*() {
        let y = yield new Promise((v,E)=>{
            try {
                r(l, d, (D,S)=>v([D, S]))
            } catch (D) {
                E(D)
            }
        }
        );
        return yield s(...y)
    })),
    new lI.default((l,d)=>$(this, null, function*() {
        let y = {
            method: "POST",
            body: l,
            agent: a,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, e || {}, dO)
        };
        try {
            let v = 5, E, D = 500;
            for (; c ? E = yield c(t, y) : E = yield s(t, y),
            !(E.status !== 429 || i === !0 || (v -= 1,
            v === 0)); )
                console.error(`Server responded with ${E.status} ${E.statusText}.  Retrying after ${D}ms delay...`),
                yield ma(D),
                D *= 2;
            let S = yield E.text();
            E.ok ? d(null, S) : d(new Error(`${E.status} ${E.statusText}: ${S}`))
        } catch (v) {
            v instanceof Error && d(v)
        }
    }),{})
}
function dP(t) {
    return (e,n)=>new Promise((r,i)=>{
        t.request(e, n, (o,s)=>{
            if (o) {
                i(o);
                return
            }
            r(s)
        }
        )
    }
    )
}
function hP(t) {
    return e=>new Promise((n,r)=>{
        e.length === 0 && n([]);
        let i = e.map(o=>t.request(o.methodName, o.args));
        t.request(i, (o,s)=>{
            if (o) {
                r(o);
                return
            }
            n(s)
        }
        )
    }
    )
}
var pP = Le(QN)
  , gP = Le(tP)
  , mP = Le(eP)
  , yP = Le(nP)
  , vP = Le(rP)
  , xP = Le(iP)
  , wP = Le(H())
  , bP = Vt(re({
    total: H(),
    circulating: H(),
    nonCirculating: H(),
    nonCirculatingAccounts: ce(Tt)
}))
  , ev = re({
    amount: oe(),
    uiAmount: ue(H()),
    decimals: H(),
    uiAmountString: De(oe())
})
  , EP = Vt(ce(re({
    address: Tt,
    amount: oe(),
    uiAmount: ue(H()),
    decimals: H(),
    uiAmountString: De(oe())
})))
  , CP = Vt(ce(re({
    pubkey: Tt,
    account: re({
        executable: Rr(),
        owner: Tt,
        lamports: H(),
        data: av,
        rentEpoch: H()
    })
})))
  , tv = re({
    program: oe(),
    parsed: Qo(),
    space: H()
})
  , DP = Vt(ce(re({
    pubkey: Tt,
    account: re({
        executable: Rr(),
        owner: Tt,
        lamports: H(),
        data: tv,
        rentEpoch: H()
    })
})))
  , IP = Vt(ce(re({
    lamports: H(),
    address: Tt
})))
  , eu = re({
    executable: Rr(),
    owner: Tt,
    lamports: H(),
    data: av,
    rentEpoch: H()
})
  , AP = re({
    pubkey: Tt,
    account: eu
})
  , _P = ga(An([ud(_e.Buffer), tv]), An([xI, tv]), t=>Array.isArray(t) ? ae(t, av) : t)
  , nv = re({
    executable: Rr(),
    owner: Tt,
    lamports: H(),
    data: _P,
    rentEpoch: H()
})
  , SP = re({
    pubkey: Tt,
    account: nv
})
  , MP = re({
    state: An([At("active"), At("inactive"), At("activating"), At("deactivating")]),
    active: H(),
    inactive: H()
})
  , kP = Le(ce(re({
    signature: oe(),
    slot: H(),
    err: rs,
    memo: ue(oe()),
    blockTime: De(ue(H()))
})))
  , TP = Le(ce(re({
    signature: oe(),
    slot: H(),
    err: rs,
    memo: ue(oe()),
    blockTime: De(ue(H()))
})))
  , BP = re({
    subscription: H(),
    result: Td(eu)
})
  , RP = re({
    pubkey: Tt,
    account: eu
})
  , FP = re({
    subscription: H(),
    result: Td(RP)
})
  , NP = re({
    parent: H(),
    slot: H(),
    root: H()
})
  , PP = re({
    subscription: H(),
    result: NP
})
  , OP = An([re({
    type: An([At("firstShredReceived"), At("completed"), At("optimisticConfirmation"), At("root")]),
    slot: H(),
    timestamp: H()
}), re({
    type: At("createdBank"),
    parent: H(),
    slot: H(),
    timestamp: H()
}), re({
    type: At("frozen"),
    slot: H(),
    timestamp: H(),
    stats: re({
        numTransactionEntries: H(),
        numSuccessfulTransactions: H(),
        numFailedTransactions: H(),
        maxTransactionsPerEntry: H()
    })
}), re({
    type: At("dead"),
    slot: H(),
    timestamp: H(),
    err: oe()
})])
  , LP = re({
    subscription: H(),
    result: OP
})
  , UP = re({
    subscription: H(),
    result: Td(An([oP, sP]))
})
  , VP = re({
    subscription: H(),
    result: H()
})
  , jP = re({
    pubkey: oe(),
    gossip: ue(oe()),
    tpu: ue(oe()),
    rpc: ue(oe()),
    version: ue(oe())
})
  , tI = re({
    votePubkey: oe(),
    nodePubkey: oe(),
    activatedStake: H(),
    epochVoteAccount: Rr(),
    epochCredits: ce(ld([H(), H(), H()])),
    commission: H(),
    lastVote: H(),
    rootSlot: ue(H())
})
  , $P = Le(re({
    current: ce(tI),
    delinquent: ce(tI)
}))
  , HP = An([At("processed"), At("confirmed"), At("finalized")])
  , zP = re({
    slot: H(),
    confirmations: ue(H()),
    err: rs,
    confirmationStatus: De(HP)
})
  , qP = Vt(ce(ue(zP)))
  , WP = Le(H())
  , bI = re({
    accountKey: Tt,
    writableIndexes: ce(H()),
    readonlyIndexes: ce(H())
})
  , cv = re({
    signatures: ce(oe()),
    message: re({
        accountKeys: ce(oe()),
        header: re({
            numRequiredSignatures: H(),
            numReadonlySignedAccounts: H(),
            numReadonlyUnsignedAccounts: H()
        }),
        instructions: ce(re({
            accounts: ce(H()),
            data: oe(),
            programIdIndex: H()
        })),
        recentBlockhash: oe(),
        addressTableLookups: De(ce(bI))
    })
})
  , EI = re({
    pubkey: Tt,
    signer: Rr(),
    writable: Rr(),
    source: De(An([At("transaction"), At("lookupTable")]))
})
  , CI = re({
    accountKeys: ce(EI),
    signatures: ce(oe())
})
  , DI = re({
    parsed: Qo(),
    program: oe(),
    programId: Tt
})
  , II = re({
    accounts: ce(Tt),
    data: oe(),
    programId: Tt
})
  , GP = An([II, DI])
  , KP = An([re({
    parsed: Qo(),
    program: oe(),
    programId: oe()
}), re({
    accounts: ce(oe()),
    data: oe(),
    programId: oe()
})])
  , AI = ga(GP, KP, t=>"accounts"in t ? ae(t, II) : ae(t, DI))
  , _I = re({
    signatures: ce(oe()),
    message: re({
        accountKeys: ce(EI),
        instructions: ce(AI),
        recentBlockhash: oe(),
        addressTableLookups: De(ue(ce(bI)))
    })
})
  , _d = re({
    accountIndex: H(),
    mint: oe(),
    owner: De(oe()),
    uiTokenAmount: ev
})
  , SI = re({
    writable: ce(Tt),
    readonly: ce(Tt)
})
  , Bd = re({
    err: rs,
    fee: H(),
    innerInstructions: De(ue(ce(re({
        index: H(),
        instructions: ce(re({
            accounts: ce(H()),
            data: oe(),
            programIdIndex: H()
        }))
    })))),
    preBalances: ce(H()),
    postBalances: ce(H()),
    logMessages: De(ue(ce(oe()))),
    preTokenBalances: De(ue(ce(_d))),
    postTokenBalances: De(ue(ce(_d))),
    loadedAddresses: De(SI),
    computeUnitsConsumed: De(H())
})
  , uv = re({
    err: rs,
    fee: H(),
    innerInstructions: De(ue(ce(re({
        index: H(),
        instructions: ce(AI)
    })))),
    preBalances: ce(H()),
    postBalances: ce(H()),
    logMessages: De(ue(ce(oe()))),
    preTokenBalances: De(ue(ce(_d))),
    postTokenBalances: De(ue(ce(_d))),
    loadedAddresses: De(SI),
    computeUnitsConsumed: De(H())
})
  , ba = An([At(0), At("legacy")])
  , is = re({
    pubkey: oe(),
    lamports: H(),
    postBalance: ue(H()),
    rewardType: ue(oe()),
    commission: De(ue(H()))
})
  , YP = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    transactions: ce(re({
        transaction: cv,
        meta: ue(Bd),
        version: De(ba)
    })),
    rewards: De(ce(is)),
    blockTime: ue(H()),
    blockHeight: ue(H())
})))
  , ZP = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    rewards: De(ce(is)),
    blockTime: ue(H()),
    blockHeight: ue(H())
})))
  , XP = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    transactions: ce(re({
        transaction: CI,
        meta: ue(Bd),
        version: De(ba)
    })),
    rewards: De(ce(is)),
    blockTime: ue(H()),
    blockHeight: ue(H())
})))
  , QP = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    transactions: ce(re({
        transaction: _I,
        meta: ue(uv),
        version: De(ba)
    })),
    rewards: De(ce(is)),
    blockTime: ue(H()),
    blockHeight: ue(H())
})))
  , JP = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    transactions: ce(re({
        transaction: CI,
        meta: ue(uv),
        version: De(ba)
    })),
    rewards: De(ce(is)),
    blockTime: ue(H()),
    blockHeight: ue(H())
})))
  , eO = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    rewards: De(ce(is)),
    blockTime: ue(H()),
    blockHeight: ue(H())
})))
  , tO = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    transactions: ce(re({
        transaction: cv,
        meta: ue(Bd)
    })),
    rewards: De(ce(is)),
    blockTime: ue(H())
})))
  , nI = Le(ue(re({
    blockhash: oe(),
    previousBlockhash: oe(),
    parentSlot: H(),
    signatures: ce(oe()),
    blockTime: ue(H())
})))
  , zy = Le(ue(re({
    slot: H(),
    meta: ue(Bd),
    blockTime: De(ue(H())),
    transaction: cv,
    version: De(ba)
})))
  , wd = Le(ue(re({
    slot: H(),
    transaction: _I,
    meta: ue(uv),
    blockTime: De(ue(H())),
    version: De(ba)
})))
  , nO = Vt(re({
    blockhash: oe(),
    feeCalculator: re({
        lamportsPerSignature: H()
    })
}))
  , rO = Vt(re({
    blockhash: oe(),
    lastValidBlockHeight: H()
}))
  , iO = Vt(Rr())
  , oO = re({
    slot: H(),
    numTransactions: H(),
    numSlots: H(),
    samplePeriodSecs: H()
})
  , sO = Le(ce(oO))
  , aO = Vt(ue(re({
    feeCalculator: re({
        lamportsPerSignature: H()
    })
})))
  , cO = Le(oe())
  , uO = Le(oe())
  , lO = re({
    err: rs,
    logs: ce(oe()),
    signature: oe()
})
  , fO = re({
    result: Td(lO),
    subscription: H()
})
  , dO = {
    "solana-client": "js/0.0.0-development"
}
  , Sd = class {
    constructor(e, n) {
        this._commitment = void 0,
        this._confirmTransactionInitialTimeout = void 0,
        this._rpcEndpoint = void 0,
        this._rpcWsEndpoint = void 0,
        this._rpcClient = void 0,
        this._rpcRequest = void 0,
        this._rpcBatchRequest = void 0,
        this._rpcWebSocket = void 0,
        this._rpcWebSocketConnected = !1,
        this._rpcWebSocketHeartbeat = null,
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketGeneration = 0,
        this._disableBlockhashCaching = !1,
        this._pollingBlockhash = !1,
        this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        },
        this._nextClientSubscriptionId = 0,
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {},
        this._subscriptionHashByClientSubscriptionId = {},
        this._subscriptionStateChangeCallbacksByHash = {},
        this._subscriptionCallbacksByServerSubscriptionId = {},
        this._subscriptionsByHash = {},
        this._subscriptionsAutoDisposedByRpc = new Set,
        this.getBlockHeight = (()=>{
            let u = {};
            return l=>$(this, null, function*() {
                let {commitment: d, config: y} = Et(l)
                  , v = this._buildArgs([], d, void 0, y)
                  , E = QD(v);
                return u[E] = u[E] ?? $(this, null, function*() {
                    try {
                        let D = yield this._rpcRequest("getBlockHeight", v)
                          , S = ae(D, Le(H()));
                        if ("error"in S)
                            throw new ge(S.error,"failed to get block height information");
                        return S.result
                    } finally {
                        delete u[E]
                    }
                }),
                yield u[E]
            })
        }
        )();
        let r, i, o, s, a, c;
        n && typeof n == "string" ? this._commitment = n : n && (this._commitment = n.commitment,
        this._confirmTransactionInitialTimeout = n.confirmTransactionInitialTimeout,
        r = n.wsEndpoint,
        i = n.httpHeaders,
        o = n.fetch,
        s = n.fetchMiddleware,
        a = n.disableRetryOnRateLimit,
        c = n.httpAgent),
        this._rpcEndpoint = ZN(e),
        this._rpcWsEndpoint = r || KN(e),
        this._rpcClient = fP(e, i, o, s, a, c),
        this._rpcRequest = dP(this._rpcClient),
        this._rpcBatchRequest = hP(this._rpcClient),
        this._rpcWebSocket = new Jy(this._rpcWsEndpoint,{
            autoconnect: !1,
            max_reconnects: 1 / 0
        }),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)),
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)),
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)),
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)),
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)),
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)),
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    getBalanceAndContext(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgs([e.toBase58()], r, void 0, i)
              , s = yield this._rpcRequest("getBalance", o)
              , a = ae(s, Vt(H()));
            if ("error"in a)
                throw new ge(a.error,`failed to get balance for ${e.toBase58()}`);
            return a.result
        })
    }
    getBalance(e, n) {
        return $(this, null, function*() {
            return yield this.getBalanceAndContext(e, n).then(r=>r.value).catch(r=>{
                throw new Error("failed to get balance of account " + e.toBase58() + ": " + r)
            }
            )
        })
    }
    getBlockTime(e) {
        return $(this, null, function*() {
            let n = yield this._rpcRequest("getBlockTime", [e])
              , r = ae(n, Le(ue(H())));
            if ("error"in r)
                throw new ge(r.error,`failed to get block time for slot ${e}`);
            return r.result
        })
    }
    getMinimumLedgerSlot() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("minimumLedgerSlot", [])
              , n = ae(e, Le(H()));
            if ("error"in n)
                throw new ge(n.error,"failed to get minimum ledger slot");
            return n.result
        })
    }
    getFirstAvailableBlock() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getFirstAvailableBlock", [])
              , n = ae(e, wP);
            if ("error"in n)
                throw new ge(n.error,"failed to get first available block");
            return n.result
        })
    }
    getSupply(e) {
        return $(this, null, function*() {
            let n = {};
            typeof e == "string" ? n = {
                commitment: e
            } : e ? n = me(ee({}, e), {
                commitment: e && e.commitment || this.commitment
            }) : n = {
                commitment: this.commitment
            };
            let r = yield this._rpcRequest("getSupply", [n])
              , i = ae(r, bP);
            if ("error"in i)
                throw new ge(i.error,"failed to get supply");
            return i.result
        })
    }
    getTokenSupply(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgs([e.toBase58()], n)
              , i = yield this._rpcRequest("getTokenSupply", r)
              , o = ae(i, Vt(ev));
            if ("error"in o)
                throw new ge(o.error,"failed to get token supply");
            return o.result
        })
    }
    getTokenAccountBalance(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgs([e.toBase58()], n)
              , i = yield this._rpcRequest("getTokenAccountBalance", r)
              , o = ae(i, Vt(ev));
            if ("error"in o)
                throw new ge(o.error,"failed to get token account balance");
            return o.result
        })
    }
    getTokenAccountsByOwner(e, n, r) {
        return $(this, null, function*() {
            let {commitment: i, config: o} = Et(r)
              , s = [e.toBase58()];
            "mint"in n ? s.push({
                mint: n.mint.toBase58()
            }) : s.push({
                programId: n.programId.toBase58()
            });
            let a = this._buildArgs(s, i, "base64", o)
              , c = yield this._rpcRequest("getTokenAccountsByOwner", a)
              , u = ae(c, CP);
            if ("error"in u)
                throw new ge(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);
            return u.result
        })
    }
    getParsedTokenAccountsByOwner(e, n, r) {
        return $(this, null, function*() {
            let i = [e.toBase58()];
            "mint"in n ? i.push({
                mint: n.mint.toBase58()
            }) : i.push({
                programId: n.programId.toBase58()
            });
            let o = this._buildArgs(i, r, "jsonParsed")
              , s = yield this._rpcRequest("getTokenAccountsByOwner", o)
              , a = ae(s, DP);
            if ("error"in a)
                throw new ge(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);
            return a.result
        })
    }
    getLargestAccounts(e) {
        return $(this, null, function*() {
            let n = me(ee({}, e), {
                commitment: e && e.commitment || this.commitment
            })
              , r = n.filter || n.commitment ? [n] : []
              , i = yield this._rpcRequest("getLargestAccounts", r)
              , o = ae(i, IP);
            if ("error"in o)
                throw new ge(o.error,"failed to get largest accounts");
            return o.result
        })
    }
    getTokenLargestAccounts(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgs([e.toBase58()], n)
              , i = yield this._rpcRequest("getTokenLargestAccounts", r)
              , o = ae(i, EP);
            if ("error"in o)
                throw new ge(o.error,"failed to get token largest accounts");
            return o.result
        })
    }
    getAccountInfoAndContext(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgs([e.toBase58()], r, "base64", i)
              , s = yield this._rpcRequest("getAccountInfo", o)
              , a = ae(s, Vt(ue(eu)));
            if ("error"in a)
                throw new ge(a.error,`failed to get info about account ${e.toBase58()}`);
            return a.result
        })
    }
    getParsedAccountInfo(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgs([e.toBase58()], r, "jsonParsed", i)
              , s = yield this._rpcRequest("getAccountInfo", o)
              , a = ae(s, Vt(ue(nv)));
            if ("error"in a)
                throw new ge(a.error,`failed to get info about account ${e.toBase58()}`);
            return a.result
        })
    }
    getAccountInfo(e, n) {
        return $(this, null, function*() {
            try {
                return (yield this.getAccountInfoAndContext(e, n)).value
            } catch (r) {
                throw new Error("failed to get info about account " + e.toBase58() + ": " + r)
            }
        })
    }
    getMultipleParsedAccounts(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = e.map(u=>u.toBase58())
              , s = this._buildArgs([o], r, "jsonParsed", i)
              , a = yield this._rpcRequest("getMultipleAccounts", s)
              , c = ae(a, Vt(ce(ue(nv))));
            if ("error"in c)
                throw new ge(c.error,`failed to get info for accounts ${o}`);
            return c.result
        })
    }
    getMultipleAccountsInfoAndContext(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = e.map(u=>u.toBase58())
              , s = this._buildArgs([o], r, "base64", i)
              , a = yield this._rpcRequest("getMultipleAccounts", s)
              , c = ae(a, Vt(ce(ue(eu))));
            if ("error"in c)
                throw new ge(c.error,`failed to get info for accounts ${o}`);
            return c.result
        })
    }
    getMultipleAccountsInfo(e, n) {
        return $(this, null, function*() {
            return (yield this.getMultipleAccountsInfoAndContext(e, n)).value
        })
    }
    getStakeActivation(e, n, r) {
        return $(this, null, function*() {
            let {commitment: i, config: o} = Et(n)
              , s = this._buildArgs([e.toBase58()], i, void 0, me(ee({}, o), {
                epoch: r ?? o?.epoch
            }))
              , a = yield this._rpcRequest("getStakeActivation", s)
              , c = ae(a, Le(MP));
            if ("error"in c)
                throw new ge(c.error,`failed to get Stake Activation ${e.toBase58()}`);
            return c.result
        })
    }
    getProgramAccounts(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , d = i || {}
              , {encoding: o} = d
              , s = Nr(d, ["encoding"])
              , a = this._buildArgs([e.toBase58()], r, o || "base64", s)
              , c = yield this._rpcRequest("getProgramAccounts", a)
              , u = ce(AP)
              , l = s.withContext === !0 ? ae(c, Vt(u)) : ae(c, Le(u));
            if ("error"in l)
                throw new ge(l.error,`failed to get accounts owned by program ${e.toBase58()}`);
            return l.result
        })
    }
    getParsedProgramAccounts(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgs([e.toBase58()], r, "jsonParsed", i)
              , s = yield this._rpcRequest("getProgramAccounts", o)
              , a = ae(s, Le(ce(SP)));
            if ("error"in a)
                throw new ge(a.error,`failed to get accounts owned by program ${e.toBase58()}`);
            return a.result
        })
    }
    confirmTransaction(e, n) {
        return $(this, null, function*() {
            let r;
            if (typeof e == "string")
                r = e;
            else {
                let o = e;
                if (o.abortSignal?.aborted)
                    return Promise.reject(o.abortSignal.reason);
                r = o.signature
            }
            let i;
            try {
                i = fn.default.decode(r)
            } catch {
                throw new Error("signature must be base58 encoded: " + r)
            }
            return Ct(i.length === 64, "signature has invalid length"),
            typeof e == "string" ? yield this.confirmTransactionUsingLegacyTimeoutStrategy({
                commitment: n || this.commitment,
                signature: r
            }) : "lastValidBlockHeight"in e ? yield this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                commitment: n || this.commitment,
                strategy: e
            }) : yield this.confirmTransactionUsingDurableNonceStrategy({
                commitment: n || this.commitment,
                strategy: e
            })
        })
    }
    getCancellationPromise(e) {
        return new Promise((n,r)=>{
            e != null && (e.aborted ? r(e.reason) : e.addEventListener("abort", ()=>{
                r(e.reason)
            }
            ))
        }
        )
    }
    getTransactionConfirmationPromise({commitment: e, signature: n}) {
        let r, i, o = !1, s = new Promise((c,u)=>{
            try {
                r = this.onSignature(n, (d,y)=>{
                    r = void 0;
                    let v = {
                        context: y,
                        value: d
                    };
                    c({
                        __type: go.PROCESSED,
                        response: v
                    })
                }
                , e);
                let l = new Promise(d=>{
                    r == null ? d() : i = this._onSubscriptionStateChange(r, y=>{
                        y === "subscribed" && d()
                    }
                    )
                }
                );
                $(this, null, function*() {
                    if (yield l,
                    o)
                        return;
                    let d = yield this.getSignatureStatus(n);
                    if (o || d == null)
                        return;
                    let {context: y, value: v} = d;
                    if (v != null)
                        if (v?.err)
                            u(v.err);
                        else {
                            switch (e) {
                            case "confirmed":
                            case "single":
                            case "singleGossip":
                                {
                                    if (v.confirmationStatus === "processed")
                                        return;
                                    break
                                }
                            case "finalized":
                            case "max":
                            case "root":
                                {
                                    if (v.confirmationStatus === "processed" || v.confirmationStatus === "confirmed")
                                        return;
                                    break
                                }
                            case "processed":
                            case "recent":
                            }
                            o = !0,
                            c({
                                __type: go.PROCESSED,
                                response: {
                                    context: y,
                                    value: v
                                }
                            })
                        }
                })
            } catch (l) {
                u(l)
            }
        }
        );
        return {
            abortConfirmation: ()=>{
                i && (i(),
                i = void 0),
                r != null && (this.removeSignatureListener(r),
                r = void 0)
            }
            ,
            confirmationPromise: s
        }
    }
    confirmTransactionUsingBlockHeightExceedanceStrategy(o) {
        return $(this, arguments, function*({commitment: e, strategy: {abortSignal: n, lastValidBlockHeight: r, signature: i}}) {
            let s = !1, a = new Promise(y=>{
                let v = ()=>$(this, null, function*() {
                    try {
                        return yield this.getBlockHeight(e)
                    } catch {
                        return -1
                    }
                });
                $(this, null, function*() {
                    let E = yield v();
                    if (!s) {
                        for (; E <= r; )
                            if (yield ma(1e3),
                            s || (E = yield v(),
                            s))
                                return;
                        y({
                            __type: go.BLOCKHEIGHT_EXCEEDED
                        })
                    }
                })
            }
            ), {abortConfirmation: c, confirmationPromise: u} = this.getTransactionConfirmationPromise({
                commitment: e,
                signature: i
            }), l = this.getCancellationPromise(n), d;
            try {
                let y = yield Promise.race([l, u, a]);
                if (y.__type === go.PROCESSED)
                    d = y.response;
                else
                    throw new Cd(i)
            } finally {
                s = !0,
                c()
            }
            return d
        })
    }
    confirmTransactionUsingDurableNonceStrategy(a) {
        return $(this, arguments, function*({commitment: e, strategy: {abortSignal: n, minContextSlot: r, nonceAccountPubkey: i, nonceValue: o, signature: s}}) {
            let c = !1, u = new Promise(E=>{
                let D = o
                  , S = null
                  , w = ()=>$(this, null, function*() {
                    try {
                        let {context: M, value: F} = yield this.getNonceAndContext(i, {
                            commitment: e,
                            minContextSlot: r
                        });
                        return S = M.slot,
                        F?.nonce
                    } catch {
                        return D
                    }
                });
                $(this, null, function*() {
                    if (D = yield w(),
                    !c)
                        for (; ; ) {
                            if (o !== D) {
                                E({
                                    __type: go.NONCE_INVALID,
                                    slotInWhichNonceDidAdvance: S
                                });
                                return
                            }
                            if (yield ma(2e3),
                            c || (D = yield w(),
                            c))
                                return
                        }
                })
            }
            ), {abortConfirmation: l, confirmationPromise: d} = this.getTransactionConfirmationPromise({
                commitment: e,
                signature: s
            }), y = this.getCancellationPromise(n), v;
            try {
                let E = yield Promise.race([y, d, u]);
                if (E.__type === go.PROCESSED)
                    v = E.response;
                else {
                    let D;
                    for (; ; ) {
                        let S = yield this.getSignatureStatus(s);
                        if (S == null)
                            break;
                        if (S.context.slot < (E.slotInWhichNonceDidAdvance ?? r)) {
                            yield ma(400);
                            continue
                        }
                        D = S;
                        break
                    }
                    if (D?.value) {
                        let S = e || "finalized"
                          , {confirmationStatus: w} = D.value;
                        switch (S) {
                        case "processed":
                        case "recent":
                            if (w !== "processed" && w !== "confirmed" && w !== "finalized")
                                throw new es(s);
                            break;
                        case "confirmed":
                        case "single":
                        case "singleGossip":
                            if (w !== "confirmed" && w !== "finalized")
                                throw new es(s);
                            break;
                        case "finalized":
                        case "max":
                        case "root":
                            if (w !== "finalized")
                                throw new es(s);
                            break;
                        default:
                        }
                        v = {
                            context: D.context,
                            value: {
                                err: D.value.err
                            }
                        }
                    } else
                        throw new es(s)
                }
            } finally {
                c = !0,
                l()
            }
            return v
        })
    }
    confirmTransactionUsingLegacyTimeoutStrategy(r) {
        return $(this, arguments, function*({commitment: e, signature: n}) {
            let i, o = new Promise(u=>{
                let l = this._confirmTransactionInitialTimeout || 6e4;
                switch (e) {
                case "processed":
                case "recent":
                case "single":
                case "confirmed":
                case "singleGossip":
                    {
                        l = this._confirmTransactionInitialTimeout || 3e4;
                        break
                    }
                }
                i = setTimeout(()=>u({
                    __type: go.TIMED_OUT,
                    timeoutMs: l
                }), l)
            }
            ), {abortConfirmation: s, confirmationPromise: a} = this.getTransactionConfirmationPromise({
                commitment: e,
                signature: n
            }), c;
            try {
                let u = yield Promise.race([a, o]);
                if (u.__type === go.PROCESSED)
                    c = u.response;
                else
                    throw new Dd(n,u.timeoutMs / 1e3)
            } finally {
                clearTimeout(i),
                s()
            }
            return c
        })
    }
    getClusterNodes() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getClusterNodes", [])
              , n = ae(e, Le(ce(jP)));
            if ("error"in n)
                throw new ge(n.error,"failed to get cluster nodes");
            return n.result
        })
    }
    getVoteAccounts(e) {
        return $(this, null, function*() {
            let n = this._buildArgs([], e)
              , r = yield this._rpcRequest("getVoteAccounts", n)
              , i = ae(r, $P);
            if ("error"in i)
                throw new ge(i.error,"failed to get vote accounts");
            return i.result
        })
    }
    getSlot(e) {
        return $(this, null, function*() {
            let {commitment: n, config: r} = Et(e)
              , i = this._buildArgs([], n, void 0, r)
              , o = yield this._rpcRequest("getSlot", i)
              , s = ae(o, Le(H()));
            if ("error"in s)
                throw new ge(s.error,"failed to get slot");
            return s.result
        })
    }
    getSlotLeader(e) {
        return $(this, null, function*() {
            let {commitment: n, config: r} = Et(e)
              , i = this._buildArgs([], n, void 0, r)
              , o = yield this._rpcRequest("getSlotLeader", i)
              , s = ae(o, Le(oe()));
            if ("error"in s)
                throw new ge(s.error,"failed to get slot leader");
            return s.result
        })
    }
    getSlotLeaders(e, n) {
        return $(this, null, function*() {
            let r = [e, n]
              , i = yield this._rpcRequest("getSlotLeaders", r)
              , o = ae(i, Le(ce(Tt)));
            if ("error"in o)
                throw new ge(o.error,"failed to get slot leaders");
            return o.result
        })
    }
    getSignatureStatus(e, n) {
        return $(this, null, function*() {
            let {context: r, value: i} = yield this.getSignatureStatuses([e], n);
            Ct(i.length === 1);
            let o = i[0];
            return {
                context: r,
                value: o
            }
        })
    }
    getSignatureStatuses(e, n) {
        return $(this, null, function*() {
            let r = [e];
            n && r.push(n);
            let i = yield this._rpcRequest("getSignatureStatuses", r)
              , o = ae(i, qP);
            if ("error"in o)
                throw new ge(o.error,"failed to get signature status");
            return o.result
        })
    }
    getTransactionCount(e) {
        return $(this, null, function*() {
            let {commitment: n, config: r} = Et(e)
              , i = this._buildArgs([], n, void 0, r)
              , o = yield this._rpcRequest("getTransactionCount", i)
              , s = ae(o, Le(H()));
            if ("error"in s)
                throw new ge(s.error,"failed to get transaction count");
            return s.result
        })
    }
    getTotalSupply(e) {
        return $(this, null, function*() {
            return (yield this.getSupply({
                commitment: e,
                excludeNonCirculatingAccountsList: !0
            })).value.total
        })
    }
    getInflationGovernor(e) {
        return $(this, null, function*() {
            let n = this._buildArgs([], e)
              , r = yield this._rpcRequest("getInflationGovernor", n)
              , i = ae(r, pP);
            if ("error"in i)
                throw new ge(i.error,"failed to get inflation");
            return i.result
        })
    }
    getInflationReward(e, n, r) {
        return $(this, null, function*() {
            let {commitment: i, config: o} = Et(r)
              , s = this._buildArgs([e.map(u=>u.toBase58())], i, void 0, me(ee({}, o), {
                epoch: n ?? o?.epoch
            }))
              , a = yield this._rpcRequest("getInflationReward", s)
              , c = ae(a, JN);
            if ("error"in c)
                throw new ge(c.error,"failed to get inflation reward");
            return c.result
        })
    }
    getInflationRate() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getInflationRate", [])
              , n = ae(e, gP);
            if ("error"in n)
                throw new ge(n.error,"failed to get inflation rate");
            return n.result
        })
    }
    getEpochInfo(e) {
        return $(this, null, function*() {
            let {commitment: n, config: r} = Et(e)
              , i = this._buildArgs([], n, void 0, r)
              , o = yield this._rpcRequest("getEpochInfo", i)
              , s = ae(o, yP);
            if ("error"in s)
                throw new ge(s.error,"failed to get epoch info");
            return s.result
        })
    }
    getEpochSchedule() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getEpochSchedule", [])
              , n = ae(e, vP);
            if ("error"in n)
                throw new ge(n.error,"failed to get epoch schedule");
            let r = n.result;
            return new Qy(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)
        })
    }
    getLeaderSchedule() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getLeaderSchedule", [])
              , n = ae(e, xP);
            if ("error"in n)
                throw new ge(n.error,"failed to get leader schedule");
            return n.result
        })
    }
    getMinimumBalanceForRentExemption(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgs([e], n)
              , i = yield this._rpcRequest("getMinimumBalanceForRentExemption", r)
              , o = ae(i, WP);
            return "error"in o ? (console.warn("Unable to fetch minimum balance for rent exemption"),
            0) : o.result
        })
    }
    getRecentBlockhashAndContext(e) {
        return $(this, null, function*() {
            let n = this._buildArgs([], e)
              , r = yield this._rpcRequest("getRecentBlockhash", n)
              , i = ae(r, nO);
            if ("error"in i)
                throw new ge(i.error,"failed to get recent blockhash");
            return i.result
        })
    }
    getRecentPerformanceSamples(e) {
        return $(this, null, function*() {
            let n = yield this._rpcRequest("getRecentPerformanceSamples", e ? [e] : [])
              , r = ae(n, sO);
            if ("error"in r)
                throw new ge(r.error,"failed to get recent performance samples");
            return r.result
        })
    }
    getFeeCalculatorForBlockhash(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgs([e], n)
              , i = yield this._rpcRequest("getFeeCalculatorForBlockhash", r)
              , o = ae(i, aO);
            if ("error"in o)
                throw new ge(o.error,"failed to get fee calculator");
            let {context: s, value: a} = o.result;
            return {
                context: s,
                value: a !== null ? a.feeCalculator : null
            }
        })
    }
    getFeeForMessage(e, n) {
        return $(this, null, function*() {
            let r = Ze(e.serialize()).toString("base64")
              , i = this._buildArgs([r], n)
              , o = yield this._rpcRequest("getFeeForMessage", i)
              , s = ae(o, Vt(ue(H())));
            if ("error"in s)
                throw new ge(s.error,"failed to get fee for message");
            if (s.result === null)
                throw new Error("invalid blockhash");
            return s.result
        })
    }
    getRecentPrioritizationFees(e) {
        return $(this, null, function*() {
            let n = e?.lockedWritableAccounts?.map(s=>s.toBase58())
              , r = n?.length ? [n] : []
              , i = yield this._rpcRequest("getRecentPrioritizationFees", r)
              , o = ae(i, mP);
            if ("error"in o)
                throw new ge(o.error,"failed to get recent prioritization fees");
            return o.result
        })
    }
    getRecentBlockhash(e) {
        return $(this, null, function*() {
            try {
                return (yield this.getRecentBlockhashAndContext(e)).value
            } catch (n) {
                throw new Error("failed to get recent blockhash: " + n)
            }
        })
    }
    getLatestBlockhash(e) {
        return $(this, null, function*() {
            try {
                return (yield this.getLatestBlockhashAndContext(e)).value
            } catch (n) {
                throw new Error("failed to get recent blockhash: " + n)
            }
        })
    }
    getLatestBlockhashAndContext(e) {
        return $(this, null, function*() {
            let {commitment: n, config: r} = Et(e)
              , i = this._buildArgs([], n, void 0, r)
              , o = yield this._rpcRequest("getLatestBlockhash", i)
              , s = ae(o, rO);
            if ("error"in s)
                throw new ge(s.error,"failed to get latest blockhash");
            return s.result
        })
    }
    isBlockhashValid(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgs([e], r, void 0, i)
              , s = yield this._rpcRequest("isBlockhashValid", o)
              , a = ae(s, iO);
            if ("error"in a)
                throw new ge(a.error,"failed to determine if the blockhash `" + e + "`is valid");
            return a.result
        })
    }
    getVersion() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getVersion", [])
              , n = ae(e, Le(aP));
            if ("error"in n)
                throw new ge(n.error,"failed to get version");
            return n.result
        })
    }
    getGenesisHash() {
        return $(this, null, function*() {
            let e = yield this._rpcRequest("getGenesisHash", [])
              , n = ae(e, Le(oe()));
            if ("error"in n)
                throw new ge(n.error,"failed to get genesis hash");
            return n.result
        })
    }
    getBlock(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgsAtLeastConfirmed([e], r, void 0, i)
              , s = yield this._rpcRequest("getBlock", o);
            try {
                switch (i?.transactionDetails) {
                case "accounts":
                    {
                        let a = ae(s, XP);
                        if ("error"in a)
                            throw a.error;
                        return a.result
                    }
                case "none":
                    {
                        let a = ae(s, ZP);
                        if ("error"in a)
                            throw a.error;
                        return a.result
                    }
                default:
                    {
                        let a = ae(s, YP);
                        if ("error"in a)
                            throw a.error;
                        let {result: c} = a;
                        return c ? me(ee({}, c), {
                            transactions: c.transactions.map(({transaction: u, meta: l, version: d})=>({
                                meta: l,
                                transaction: me(ee({}, u), {
                                    message: Hy(d, u.message)
                                }),
                                version: d
                            }))
                        }) : null
                    }
                }
            } catch (a) {
                throw new ge(a,"failed to get confirmed block")
            }
        })
    }
    getParsedBlock(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", i)
              , s = yield this._rpcRequest("getBlock", o);
            try {
                switch (i?.transactionDetails) {
                case "accounts":
                    {
                        let a = ae(s, JP);
                        if ("error"in a)
                            throw a.error;
                        return a.result
                    }
                case "none":
                    {
                        let a = ae(s, eO);
                        if ("error"in a)
                            throw a.error;
                        return a.result
                    }
                default:
                    {
                        let a = ae(s, QP);
                        if ("error"in a)
                            throw a.error;
                        return a.result
                    }
                }
            } catch (a) {
                throw new ge(a,"failed to get block")
            }
        })
    }
    getBlockProduction(e) {
        return $(this, null, function*() {
            let n, r;
            if (typeof e == "string")
                r = e;
            else if (e) {
                let a = e
                  , {commitment: c} = a
                  , u = Nr(a, ["commitment"]);
                r = c,
                n = u
            }
            let i = this._buildArgs([], r, "base64", n)
              , o = yield this._rpcRequest("getBlockProduction", i)
              , s = ae(o, lP);
            if ("error"in s)
                throw new ge(s.error,"failed to get block production information");
            return s.result
        })
    }
    getTransaction(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgsAtLeastConfirmed([e], r, void 0, i)
              , s = yield this._rpcRequest("getTransaction", o)
              , a = ae(s, zy);
            if ("error"in a)
                throw new ge(a.error,"failed to get transaction");
            let c = a.result;
            return c && me(ee({}, c), {
                transaction: me(ee({}, c.transaction), {
                    message: Hy(c.version, c.transaction.message)
                })
            })
        })
    }
    getParsedTransaction(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", i)
              , s = yield this._rpcRequest("getTransaction", o)
              , a = ae(s, wd);
            if ("error"in a)
                throw new ge(a.error,"failed to get transaction");
            return a.result
        })
    }
    getParsedTransactions(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = e.map(c=>({
                methodName: "getTransaction",
                args: this._buildArgsAtLeastConfirmed([c], r, "jsonParsed", i)
            }));
            return (yield this._rpcBatchRequest(o)).map(c=>{
                let u = ae(c, wd);
                if ("error"in u)
                    throw new ge(u.error,"failed to get transactions");
                return u.result
            }
            )
        })
    }
    getTransactions(e, n) {
        return $(this, null, function*() {
            let {commitment: r, config: i} = Et(n)
              , o = e.map(c=>({
                methodName: "getTransaction",
                args: this._buildArgsAtLeastConfirmed([c], r, void 0, i)
            }));
            return (yield this._rpcBatchRequest(o)).map(c=>{
                let u = ae(c, zy);
                if ("error"in u)
                    throw new ge(u.error,"failed to get transactions");
                let l = u.result;
                return l && me(ee({}, l), {
                    transaction: me(ee({}, l.transaction), {
                        message: Hy(l.version, l.transaction.message)
                    })
                })
            }
            )
        })
    }
    getConfirmedBlock(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgsAtLeastConfirmed([e], n)
              , i = yield this._rpcRequest("getConfirmedBlock", r)
              , o = ae(i, tO);
            if ("error"in o)
                throw new ge(o.error,"failed to get confirmed block");
            let s = o.result;
            if (!s)
                throw new Error("Confirmed block " + e + " not found");
            let a = me(ee({}, s), {
                transactions: s.transactions.map(({transaction: c, meta: u})=>{
                    let l = new ns(c.message);
                    return {
                        meta: u,
                        transaction: me(ee({}, c), {
                            message: l
                        })
                    }
                }
                )
            });
            return me(ee({}, a), {
                transactions: a.transactions.map(({transaction: c, meta: u})=>({
                    meta: u,
                    transaction: Se.populate(c.message, c.signatures)
                }))
            })
        })
    }
    getBlocks(e, n, r) {
        return $(this, null, function*() {
            let i = this._buildArgsAtLeastConfirmed(n !== void 0 ? [e, n] : [e], r)
              , o = yield this._rpcRequest("getBlocks", i)
              , s = ae(o, Le(ce(H())));
            if ("error"in s)
                throw new ge(s.error,"failed to get blocks");
            return s.result
        })
    }
    getBlockSignatures(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgsAtLeastConfirmed([e], n, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            })
              , i = yield this._rpcRequest("getBlock", r)
              , o = ae(i, nI);
            if ("error"in o)
                throw new ge(o.error,"failed to get block");
            let s = o.result;
            if (!s)
                throw new Error("Block " + e + " not found");
            return s
        })
    }
    getConfirmedBlockSignatures(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgsAtLeastConfirmed([e], n, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            })
              , i = yield this._rpcRequest("getConfirmedBlock", r)
              , o = ae(i, nI);
            if ("error"in o)
                throw new ge(o.error,"failed to get confirmed block");
            let s = o.result;
            if (!s)
                throw new Error("Confirmed block " + e + " not found");
            return s
        })
    }
    getConfirmedTransaction(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgsAtLeastConfirmed([e], n)
              , i = yield this._rpcRequest("getConfirmedTransaction", r)
              , o = ae(i, zy);
            if ("error"in o)
                throw new ge(o.error,"failed to get transaction");
            let s = o.result;
            if (!s)
                return s;
            let a = new ns(s.transaction.message)
              , c = s.transaction.signatures;
            return me(ee({}, s), {
                transaction: Se.populate(a, c)
            })
        })
    }
    getParsedConfirmedTransaction(e, n) {
        return $(this, null, function*() {
            let r = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed")
              , i = yield this._rpcRequest("getConfirmedTransaction", r)
              , o = ae(i, wd);
            if ("error"in o)
                throw new ge(o.error,"failed to get confirmed transaction");
            return o.result
        })
    }
    getParsedConfirmedTransactions(e, n) {
        return $(this, null, function*() {
            let r = e.map(s=>({
                methodName: "getConfirmedTransaction",
                args: this._buildArgsAtLeastConfirmed([s], n, "jsonParsed")
            }));
            return (yield this._rpcBatchRequest(r)).map(s=>{
                let a = ae(s, wd);
                if ("error"in a)
                    throw new ge(a.error,"failed to get confirmed transactions");
                return a.result
            }
            )
        })
    }
    getConfirmedSignaturesForAddress(e, n, r) {
        return $(this, null, function*() {
            let i = {}
              , o = yield this.getFirstAvailableBlock();
            for (; !("until"in i) && (n--,
            !(n <= 0 || n < o)); )
                try {
                    let c = yield this.getConfirmedBlockSignatures(n, "finalized");
                    c.signatures.length > 0 && (i.until = c.signatures[c.signatures.length - 1].toString())
                } catch (c) {
                    if (c instanceof Error && c.message.includes("skipped"))
                        continue;
                    throw c
                }
            let s = yield this.getSlot("finalized");
            for (; !("before"in i) && (r++,
            !(r > s)); )
                try {
                    let c = yield this.getConfirmedBlockSignatures(r);
                    c.signatures.length > 0 && (i.before = c.signatures[c.signatures.length - 1].toString())
                } catch (c) {
                    if (c instanceof Error && c.message.includes("skipped"))
                        continue;
                    throw c
                }
            return (yield this.getConfirmedSignaturesForAddress2(e, i)).map(c=>c.signature)
        })
    }
    getConfirmedSignaturesForAddress2(e, n, r) {
        return $(this, null, function*() {
            let i = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, n)
              , o = yield this._rpcRequest("getConfirmedSignaturesForAddress2", i)
              , s = ae(o, kP);
            if ("error"in s)
                throw new ge(s.error,"failed to get confirmed signatures for address");
            return s.result
        })
    }
    getSignaturesForAddress(e, n, r) {
        return $(this, null, function*() {
            let i = this._buildArgsAtLeastConfirmed([e.toBase58()], r, void 0, n)
              , o = yield this._rpcRequest("getSignaturesForAddress", i)
              , s = ae(o, TP);
            if ("error"in s)
                throw new ge(s.error,"failed to get signatures for address");
            return s.result
        })
    }
    getAddressLookupTable(e, n) {
        return $(this, null, function*() {
            let {context: r, value: i} = yield this.getAccountInfoAndContext(e, n)
              , o = null;
            return i !== null && (o = new Ad({
                key: e,
                state: Ad.deserialize(i.data)
            })),
            {
                context: r,
                value: o
            }
        })
    }
    getNonceAndContext(e, n) {
        return $(this, null, function*() {
            let {context: r, value: i} = yield this.getAccountInfoAndContext(e, n)
              , o = null;
            return i !== null && (o = Xy.fromAccountData(i.data)),
            {
                context: r,
                value: o
            }
        })
    }
    getNonce(e, n) {
        return $(this, null, function*() {
            return yield this.getNonceAndContext(e, n).then(r=>r.value).catch(r=>{
                throw new Error("failed to get nonce for account " + e.toBase58() + ": " + r)
            }
            )
        })
    }
    requestAirdrop(e, n) {
        return $(this, null, function*() {
            let r = yield this._rpcRequest("requestAirdrop", [e.toBase58(), n])
              , i = ae(r, cO);
            if ("error"in i)
                throw new ge(i.error,`airdrop to ${e.toBase58()} failed`);
            return i.result
        })
    }
    _blockhashWithExpiryBlockHeight(e) {
        return $(this, null, function*() {
            if (!e) {
                for (; this._pollingBlockhash; )
                    yield ma(100);
                let r = Date.now() - this._blockhashInfo.lastFetch >= YN;
                if (this._blockhashInfo.latestBlockhash !== null && !r)
                    return this._blockhashInfo.latestBlockhash
            }
            return yield this._pollNewBlockhash()
        })
    }
    _pollNewBlockhash() {
        return $(this, null, function*() {
            this._pollingBlockhash = !0;
            try {
                let e = Date.now()
                  , n = this._blockhashInfo.latestBlockhash
                  , r = n ? n.blockhash : null;
                for (let i = 0; i < 50; i++) {
                    let o = yield this.getLatestBlockhash("finalized");
                    if (r !== o.blockhash)
                        return this._blockhashInfo = {
                            latestBlockhash: o,
                            lastFetch: Date.now(),
                            transactionSignatures: [],
                            simulatedSignatures: []
                        },
                        o;
                    yield ma(NN / 2)
                }
                throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`)
            } finally {
                this._pollingBlockhash = !1
            }
        })
    }
    getStakeMinimumDelegation(e) {
        return $(this, null, function*() {
            let {commitment: n, config: r} = Et(e)
              , i = this._buildArgs([], n, "base64", r)
              , o = yield this._rpcRequest("getStakeMinimumDelegation", i)
              , s = ae(o, Vt(H()));
            if ("error"in s)
                throw new ge(s.error,"failed to get stake minimum delegation");
            return s.result
        })
    }
    simulateTransaction(e, n, r) {
        return $(this, null, function*() {
            if ("message"in e) {
                let D = e.serialize()
                  , S = _e.Buffer.from(D).toString("base64");
                if (Array.isArray(n) || r !== void 0)
                    throw new Error("Invalid arguments");
                let w = n || {};
                w.encoding = "base64",
                "commitment"in w || (w.commitment = this.commitment),
                n && typeof n == "object" && "innerInstructions"in n && (w.innerInstructions = n.innerInstructions);
                let M = [S, w]
                  , F = yield this._rpcRequest("simulateTransaction", M)
                  , N = ae(F, eI);
                if ("error"in N)
                    throw new Error("failed to simulate transaction: " + N.error.message);
                return N.result
            }
            let i;
            if (e instanceof Se) {
                let E = e;
                i = new Se,
                i.feePayer = E.feePayer,
                i.instructions = e.instructions,
                i.nonceInfo = E.nonceInfo,
                i.signatures = E.signatures
            } else
                i = Se.populate(e),
                i._message = i._json = void 0;
            if (n !== void 0 && !Array.isArray(n))
                throw new Error("Invalid arguments");
            let o = n;
            if (i.nonceInfo && o)
                i.sign(...o);
            else {
                let E = this._disableBlockhashCaching;
                for (; ; ) {
                    let D = yield this._blockhashWithExpiryBlockHeight(E);
                    if (i.lastValidBlockHeight = D.lastValidBlockHeight,
                    i.recentBlockhash = D.blockhash,
                    !o)
                        break;
                    if (i.sign(...o),
                    !i.signature)
                        throw new Error("!signature");
                    let S = i.signature.toString("base64");
                    if (!this._blockhashInfo.simulatedSignatures.includes(S) && !this._blockhashInfo.transactionSignatures.includes(S)) {
                        this._blockhashInfo.simulatedSignatures.push(S);
                        break
                    } else
                        E = !0
                }
            }
            let s = i._compile()
              , a = s.serialize()
              , u = i._serialize(a).toString("base64")
              , l = {
                encoding: "base64",
                commitment: this.commitment
            };
            if (r) {
                let E = (Array.isArray(r) ? r : s.nonProgramIds()).map(D=>D.toBase58());
                l.accounts = {
                    encoding: "base64",
                    addresses: E
                }
            }
            o && (l.sigVerify = !0),
            n && typeof n == "object" && "innerInstructions"in n && (l.innerInstructions = n.innerInstructions);
            let d = [u, l]
              , y = yield this._rpcRequest("simulateTransaction", d)
              , v = ae(y, eI);
            if ("error"in v) {
                let E;
                if ("data"in v.error && (E = v.error.data.logs,
                E && Array.isArray(E))) {
                    let D = `
    `
                      , S = D + E.join(D);
                    console.error(v.error.message, S)
                }
                throw new Jc({
                    action: "simulate",
                    signature: "",
                    transactionMessage: v.error.message,
                    logs: E
                })
            }
            return v.result
        })
    }
    sendTransaction(e, n, r) {
        return $(this, null, function*() {
            if ("version"in e) {
                if (n && Array.isArray(n))
                    throw new Error("Invalid arguments");
                let s = e.serialize();
                return yield this.sendRawTransaction(s, n)
            }
            if (n === void 0 || !Array.isArray(n))
                throw new Error("Invalid arguments");
            let i = n;
            if (e.nonceInfo)
                e.sign(...i);
            else {
                let s = this._disableBlockhashCaching;
                for (; ; ) {
                    let a = yield this._blockhashWithExpiryBlockHeight(s);
                    if (e.lastValidBlockHeight = a.lastValidBlockHeight,
                    e.recentBlockhash = a.blockhash,
                    e.sign(...i),
                    !e.signature)
                        throw new Error("!signature");
                    let c = e.signature.toString("base64");
                    if (this._blockhashInfo.transactionSignatures.includes(c))
                        s = !0;
                    else {
                        this._blockhashInfo.transactionSignatures.push(c);
                        break
                    }
                }
            }
            let o = e.serialize();
            return yield this.sendRawTransaction(o, r)
        })
    }
    sendRawTransaction(e, n) {
        return $(this, null, function*() {
            let r = Ze(e).toString("base64");
            return yield this.sendEncodedTransaction(r, n)
        })
    }
    sendEncodedTransaction(e, n) {
        return $(this, null, function*() {
            let r = {
                encoding: "base64"
            }
              , i = n && n.skipPreflight
              , o = i === !0 ? "processed" : n && n.preflightCommitment || this.commitment;
            n && n.maxRetries != null && (r.maxRetries = n.maxRetries),
            n && n.minContextSlot != null && (r.minContextSlot = n.minContextSlot),
            i && (r.skipPreflight = i),
            o && (r.preflightCommitment = o);
            let s = [e, r]
              , a = yield this._rpcRequest("sendTransaction", s)
              , c = ae(a, uO);
            if ("error"in c) {
                let u;
                throw "data"in c.error && (u = c.error.data.logs),
                new Jc({
                    action: i ? "send" : "simulate",
                    signature: "",
                    transactionMessage: c.error.message,
                    logs: u
                })
            }
            return c.result
        })
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0,
        this._rpcWebSocketHeartbeat = setInterval(()=>{
            $(this, null, function*() {
                try {
                    yield this._rpcWebSocket.notify("ping")
                } catch {}
            })
        }
        , 5e3),
        this._updateSubscriptions()
    }
    _wsOnError(e) {
        this._rpcWebSocketConnected = !1,
        console.error("ws error:", e.message)
    }
    _wsOnClose(e) {
        if (this._rpcWebSocketConnected = !1,
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER,
        this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null),
        this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat),
        this._rpcWebSocketHeartbeat = null),
        e === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {},
        Object.entries(this._subscriptionsByHash).forEach(([n,r])=>{
            this._setSubscription(n, me(ee({}, r), {
                state: "pending"
            }))
        }
        )
    }
    _setSubscription(e, n) {
        let r = this._subscriptionsByHash[e]?.state;
        if (this._subscriptionsByHash[e] = n,
        r !== n.state) {
            let i = this._subscriptionStateChangeCallbacksByHash[e];
            i && i.forEach(o=>{
                try {
                    o(n.state)
                } catch {}
            }
            )
        }
    }
    _onSubscriptionStateChange(e, n) {
        let r = this._subscriptionHashByClientSubscriptionId[e];
        if (r == null)
            return ()=>{}
            ;
        let i = this._subscriptionStateChangeCallbacksByHash[r] ||= new Set;
        return i.add(n),
        ()=>{
            i.delete(n),
            i.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[r]
        }
    }
    _updateSubscriptions() {
        return $(this, null, function*() {
            if (Object.keys(this._subscriptionsByHash).length === 0) {
                this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1,
                this._rpcWebSocketIdleTimeout = setTimeout(()=>{
                    this._rpcWebSocketIdleTimeout = null;
                    try {
                        this._rpcWebSocket.close()
                    } catch (r) {
                        r instanceof Error && console.log(`Error when closing socket connection: ${r.message}`)
                    }
                }
                , 500));
                return
            }
            if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout),
            this._rpcWebSocketIdleTimeout = null,
            this._rpcWebSocketConnected = !0),
            !this._rpcWebSocketConnected) {
                this._rpcWebSocket.connect();
                return
            }
            let e = this._rpcWebSocketGeneration
              , n = ()=>e === this._rpcWebSocketGeneration;
            yield Promise.all(Object.keys(this._subscriptionsByHash).map(r=>$(this, null, function*() {
                let i = this._subscriptionsByHash[r];
                if (i !== void 0)
                    switch (i.state) {
                    case "pending":
                    case "unsubscribed":
                        if (i.callbacks.size === 0) {
                            delete this._subscriptionsByHash[r],
                            i.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[i.serverSubscriptionId],
                            yield this._updateSubscriptions();
                            return
                        }
                        yield $(this, null, function*() {
                            let {args: o, method: s} = i;
                            try {
                                this._setSubscription(r, me(ee({}, i), {
                                    state: "subscribing"
                                }));
                                let a = yield this._rpcWebSocket.call(s, o);
                                this._setSubscription(r, me(ee({}, i), {
                                    serverSubscriptionId: a,
                                    state: "subscribed"
                                })),
                                this._subscriptionCallbacksByServerSubscriptionId[a] = i.callbacks,
                                yield this._updateSubscriptions()
                            } catch (a) {
                                if (a instanceof Error && console.error(`${s} error for argument`, o, a.message),
                                !n())
                                    return;
                                this._setSubscription(r, me(ee({}, i), {
                                    state: "pending"
                                })),
                                yield this._updateSubscriptions()
                            }
                        });
                        break;
                    case "subscribed":
                        i.callbacks.size === 0 && (yield $(this, null, function*() {
                            let {serverSubscriptionId: o, unsubscribeMethod: s} = i;
                            if (this._subscriptionsAutoDisposedByRpc.has(o))
                                this._subscriptionsAutoDisposedByRpc.delete(o);
                            else {
                                this._setSubscription(r, me(ee({}, i), {
                                    state: "unsubscribing"
                                })),
                                this._setSubscription(r, me(ee({}, i), {
                                    state: "unsubscribing"
                                }));
                                try {
                                    yield this._rpcWebSocket.call(s, [o])
                                } catch (a) {
                                    if (a instanceof Error && console.error(`${s} error:`, a.message),
                                    !n())
                                        return;
                                    this._setSubscription(r, me(ee({}, i), {
                                        state: "subscribed"
                                    })),
                                    yield this._updateSubscriptions();
                                    return
                                }
                            }
                            this._setSubscription(r, me(ee({}, i), {
                                state: "unsubscribed"
                            })),
                            yield this._updateSubscriptions()
                        }));
                        break
                    }
            })))
        })
    }
    _handleServerNotification(e, n) {
        let r = this._subscriptionCallbacksByServerSubscriptionId[e];
        r !== void 0 && r.forEach(i=>{
            try {
                i(...n)
            } catch (o) {
                console.error(o)
            }
        }
        )
    }
    _wsOnAccountNotification(e) {
        let {result: n, subscription: r} = ae(e, BP);
        this._handleServerNotification(r, [n.value, n.context])
    }
    _makeSubscription(e, n) {
        let r = this._nextClientSubscriptionId++
          , i = QD([e.method, n])
          , o = this._subscriptionsByHash[i];
        return o === void 0 ? this._subscriptionsByHash[i] = me(ee({}, e), {
            args: n,
            callbacks: new Set([e.callback]),
            state: "pending"
        }) : o.callbacks.add(e.callback),
        this._subscriptionHashByClientSubscriptionId[r] = i,
        this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = ()=>$(this, null, function*() {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
            delete this._subscriptionHashByClientSubscriptionId[r];
            let s = this._subscriptionsByHash[i];
            Ct(s !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${r}`),
            s.callbacks.delete(e.callback),
            yield this._updateSubscriptions()
        }),
        this._updateSubscriptions(),
        r
    }
    onAccountChange(e, n, r) {
        let {commitment: i, config: o} = Et(r)
          , s = this._buildArgs([e.toBase58()], i || this._commitment || "finalized", "base64", o);
        return this._makeSubscription({
            callback: n,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, s)
    }
    removeAccountChangeListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "account change")
        })
    }
    _wsOnProgramAccountNotification(e) {
        let {result: n, subscription: r} = ae(e, FP);
        this._handleServerNotification(r, [{
            accountId: n.value.pubkey,
            accountInfo: n.value.account
        }, n.context])
    }
    onProgramAccountChange(e, n, r, i) {
        let {commitment: o, config: s} = Et(r)
          , a = this._buildArgs([e.toBase58()], o || this._commitment || "finalized", "base64", s || (i ? {
            filters: i
        } : void 0));
        return this._makeSubscription({
            callback: n,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, a)
    }
    removeProgramAccountChangeListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "program account change")
        })
    }
    onLogs(e, n, r) {
        let i = this._buildArgs([typeof e == "object" ? {
            mentions: [e.toString()]
        } : e], r || this._commitment || "finalized");
        return this._makeSubscription({
            callback: n,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, i)
    }
    removeOnLogsListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "logs")
        })
    }
    _wsOnLogsNotification(e) {
        let {result: n, subscription: r} = ae(e, fO);
        this._handleServerNotification(r, [n.value, n.context])
    }
    _wsOnSlotNotification(e) {
        let {result: n, subscription: r} = ae(e, PP);
        this._handleServerNotification(r, [n])
    }
    onSlotChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    removeSlotChangeListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "slot change")
        })
    }
    _wsOnSlotUpdatesNotification(e) {
        let {result: n, subscription: r} = ae(e, LP);
        this._handleServerNotification(r, [n])
    }
    onSlotUpdate(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    removeSlotUpdateListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "slot update")
        })
    }
    _unsubscribeClientSubscription(e, n) {
        return $(this, null, function*() {
            let r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
            r ? yield r() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${n}' events could not be found.`)
        })
    }
    _buildArgs(e, n, r, i) {
        let o = n || this._commitment;
        if (o || r || i) {
            let s = {};
            r && (s.encoding = r),
            o && (s.commitment = o),
            i && (s = Object.assign(s, i)),
            e.push(s)
        }
        return e
    }
    _buildArgsAtLeastConfirmed(e, n, r, i) {
        let o = n || this._commitment;
        if (o && !["confirmed", "finalized"].includes(o))
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(e, n, r, i)
    }
    _wsOnSignatureNotification(e) {
        let {result: n, subscription: r} = ae(e, UP);
        n.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(r),
        this._handleServerNotification(r, n.value === "receivedSignature" ? [{
            type: "received"
        }, n.context] : [{
            type: "status",
            result: n.value
        }, n.context])
    }
    onSignature(e, n, r) {
        let i = this._buildArgs([e], r || this._commitment || "finalized")
          , o = this._makeSubscription({
            callback: (s,a)=>{
                if (s.type === "status") {
                    n(s.result, a);
                    try {
                        this.removeSignatureListener(o)
                    } catch {}
                }
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, i);
        return o
    }
    onSignatureWithOptions(e, n, r) {
        let c = me(ee({}, r), {
            commitment: r && r.commitment || this._commitment || "finalized"
        })
          , {commitment: i} = c
          , o = Nr(c, ["commitment"])
          , s = this._buildArgs([e], i, void 0, o)
          , a = this._makeSubscription({
            callback: (u,l)=>{
                n(u, l);
                try {
                    this.removeSignatureListener(a)
                } catch {}
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, s);
        return a
    }
    removeSignatureListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "signature result")
        })
    }
    _wsOnRootNotification(e) {
        let {result: n, subscription: r} = ae(e, VP);
        this._handleServerNotification(r, [n])
    }
    onRootChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    removeRootChangeListener(e) {
        return $(this, null, function*() {
            yield this._unsubscribeClientSubscription(e, "root change")
        })
    }
}
  , ni = class t {
    constructor(e) {
        this._keypair = void 0,
        this._keypair = e ?? KD()
    }
    static generate() {
        return new t(KD())
    }
    static fromSecretKey(e, n) {
        if (e.byteLength !== 64)
            throw new Error("bad secret key size");
        let r = e.slice(32, 64);
        if (!n || !n.skipValidation) {
            let i = e.slice(0, 32)
              , o = Ky(i);
            for (let s = 0; s < 32; s++)
                if (r[s] !== o[s])
                    throw new Error("provided secretKey is invalid")
        }
        return new t({
            publicKey: r,
            secretKey: e
        })
    }
    static fromSeed(e) {
        let n = Ky(e)
          , r = new Uint8Array(64);
        return r.set(e),
        r.set(n, 32),
        new t({
            publicKey: n,
            secretKey: r
        })
    }
    get publicKey() {
        return new le(this._keypair.publicKey)
    }
    get secretKey() {
        return new Uint8Array(this._keypair.secretKey)
    }
}
  , Zc = Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: L.struct([L.u32("instruction"), xa("recentSlot"), L.u8("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: L.struct([L.u32("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: L.struct([L.u32("instruction"), xa(), L.seq(He(), L.offset(L.u32(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: L.struct([L.u32("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: L.struct([L.u32("instruction")])
    }
});
var rv = class {
    constructor() {}
    static createLookupTable(e) {
        let[n,r] = le.findProgramAddressSync([e.authority.toBuffer(), (0,
        nu.toBufferLE)(BigInt(e.recentSlot), 8)], this.programId)
          , i = Zc.CreateLookupTable
          , o = tt(i, {
            recentSlot: BigInt(e.recentSlot),
            bumpSeed: r
        })
          , s = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: e.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: Xt.programId,
            isSigner: !1,
            isWritable: !1
        }];
        return [new Te({
            programId: this.programId,
            keys: s,
            data: o
        }), n]
    }
    static freezeLookupTable(e) {
        let n = Zc.FreezeLookupTable
          , r = tt(n)
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return new Te({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
    static extendLookupTable(e) {
        let n = Zc.ExtendLookupTable
          , r = tt(n, {
            addresses: e.addresses.map(o=>o.toBytes())
        })
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return e.payer && i.push({
            pubkey: e.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: Xt.programId,
            isSigner: !1,
            isWritable: !1
        }),
        new Te({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
    static deactivateLookupTable(e) {
        let n = Zc.DeactivateLookupTable
          , r = tt(n)
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return new Te({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
    static closeLookupTable(e) {
        let n = Zc.CloseLookupTable
          , r = tt(n)
          , i = [{
            pubkey: e.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: e.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: e.recipient,
            isSigner: !1,
            isWritable: !0
        }];
        return new Te({
            programId: this.programId,
            keys: i,
            data: r
        })
    }
}
;
rv.programId = new le("AddressLookupTab1e1111111111111111111111111");
var bd = Object.freeze({
    RequestUnits: {
        index: 0,
        layout: L.struct([L.u8("instruction"), L.u32("units"), L.u32("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: L.struct([L.u8("instruction"), L.u32("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: L.struct([L.u8("instruction"), L.u32("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: L.struct([L.u8("instruction"), xa("microLamports")])
    }
})
  , iv = class {
    constructor() {}
    static requestUnits(e) {
        let n = bd.RequestUnits
          , r = tt(n, e);
        return new Te({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
    static requestHeapFrame(e) {
        let n = bd.RequestHeapFrame
          , r = tt(n, e);
        return new Te({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
    static setComputeUnitLimit(e) {
        let n = bd.SetComputeUnitLimit
          , r = tt(n, e);
        return new Te({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
    static setComputeUnitPrice(e) {
        let n = bd.SetComputeUnitPrice
          , r = tt(n, {
            microLamports: BigInt(e.microLamports)
        });
        return new Te({
            keys: [],
            programId: this.programId,
            data: r
        })
    }
}
;
iv.programId = new le("ComputeBudget111111111111111111111111111111");
var rI = 64
  , iI = 32
  , oI = 64
  , sI = L.struct([L.u8("numSignatures"), L.u8("padding"), L.u16("signatureOffset"), L.u16("signatureInstructionIndex"), L.u16("publicKeyOffset"), L.u16("publicKeyInstructionIndex"), L.u16("messageDataOffset"), L.u16("messageDataSize"), L.u16("messageInstructionIndex")])
  , ov = class t {
    constructor() {}
    static createInstructionWithPublicKey(e) {
        let {publicKey: n, message: r, signature: i, instructionIndex: o} = e;
        Ct(n.length === iI, `Public Key must be ${iI} bytes but received ${n.length} bytes`),
        Ct(i.length === oI, `Signature must be ${oI} bytes but received ${i.length} bytes`);
        let s = sI.span
          , a = s + n.length
          , c = a + i.length
          , u = 1
          , l = _e.Buffer.alloc(c + r.length)
          , d = o ?? 65535;
        return sI.encode({
            numSignatures: u,
            padding: 0,
            signatureOffset: a,
            signatureInstructionIndex: d,
            publicKeyOffset: s,
            publicKeyInstructionIndex: d,
            messageDataOffset: c,
            messageDataSize: r.length,
            messageInstructionIndex: d
        }, l),
        l.fill(n, s),
        l.fill(i, a),
        l.fill(r, c),
        new Te({
            keys: [],
            programId: t.programId,
            data: l
        })
    }
    static createInstructionWithPrivateKey(e) {
        let {privateKey: n, message: r, instructionIndex: i} = e;
        Ct(n.length === rI, `Private key must be ${rI} bytes but received ${n.length} bytes`);
        try {
            let o = ni.fromSecretKey(n)
              , s = o.publicKey.toBytes()
              , a = fI(r, o.secretKey);
            return this.createInstructionWithPublicKey({
                publicKey: s,
                message: r,
                signature: a,
                instructionIndex: i
            })
        } catch (o) {
            throw new Error(`Error creating instruction; ${o}`)
        }
    }
}
;
ov.programId = new le("Ed25519SigVerify111111111111111111111111111");
var hO = (t,e)=>{
    let n = Kc.sign(t, e);
    return [n.toCompactRawBytes(), n.recovery]
}
;
Kc.utils.isValidPrivateKey;
var pO = Kc.getPublicKey
  , aI = 32
  , qy = 20
  , cI = 64
  , gO = 11
  , Wy = L.struct([L.u8("numSignatures"), L.u16("signatureOffset"), L.u8("signatureInstructionIndex"), L.u16("ethAddressOffset"), L.u8("ethAddressInstructionIndex"), L.u16("messageDataOffset"), L.u16("messageDataSize"), L.u8("messageInstructionIndex"), L.blob(20, "ethAddress"), L.blob(64, "signature"), L.u8("recoveryId")])
  , sv = class t {
    constructor() {}
    static publicKeyToEthAddress(e) {
        Ct(e.length === cI, `Public key must be ${cI} bytes but received ${e.length} bytes`);
        try {
            return _e.Buffer.from(Py(Ze(e))).slice(-qy)
        } catch (n) {
            throw new Error(`Error constructing Ethereum address: ${n}`)
        }
    }
    static createInstructionWithPublicKey(e) {
        let {publicKey: n, message: r, signature: i, recoveryId: o, instructionIndex: s} = e;
        return t.createInstructionWithEthAddress({
            ethAddress: t.publicKeyToEthAddress(n),
            message: r,
            signature: i,
            recoveryId: o,
            instructionIndex: s
        })
    }
    static createInstructionWithEthAddress(e) {
        let {ethAddress: n, message: r, signature: i, recoveryId: o, instructionIndex: s=0} = e, a;
        typeof n == "string" ? n.startsWith("0x") ? a = _e.Buffer.from(n.substr(2), "hex") : a = _e.Buffer.from(n, "hex") : a = n,
        Ct(a.length === qy, `Address must be ${qy} bytes but received ${a.length} bytes`);
        let c = 1 + gO
          , u = c
          , l = c + a.length
          , d = l + i.length + 1
          , y = 1
          , v = _e.Buffer.alloc(Wy.span + r.length);
        return Wy.encode({
            numSignatures: y,
            signatureOffset: l,
            signatureInstructionIndex: s,
            ethAddressOffset: u,
            ethAddressInstructionIndex: s,
            messageDataOffset: d,
            messageDataSize: r.length,
            messageInstructionIndex: s,
            signature: Ze(i),
            ethAddress: Ze(a),
            recoveryId: o
        }, v),
        v.fill(Ze(r), Wy.span),
        new Te({
            keys: [],
            programId: t.programId,
            data: v
        })
    }
    static createInstructionWithPrivateKey(e) {
        let {privateKey: n, message: r, instructionIndex: i} = e;
        Ct(n.length === aI, `Private key must be ${aI} bytes but received ${n.length} bytes`);
        try {
            let o = Ze(n)
              , s = pO(o, !1).slice(1)
              , a = _e.Buffer.from(Py(Ze(r)))
              , [c,u] = hO(a, o);
            return this.createInstructionWithPublicKey({
                publicKey: s,
                message: r,
                signature: c,
                recoveryId: u,
                instructionIndex: i
            })
        } catch (o) {
            throw new Error(`Error creating instruction; ${o}`)
        }
    }
}
;
sv.programId = new le("KeccakSecp256k11111111111111111111111111111");
var MI, mO = new le("StakeConfig11111111111111111111111111111111");
var tu = class {
    constructor(e, n, r) {
        this.unixTimestamp = void 0,
        this.epoch = void 0,
        this.custodian = void 0,
        this.unixTimestamp = e,
        this.epoch = n,
        this.custodian = r
    }
}
;
MI = tu;
tu.default = new MI(0,0,le.default);
var mo = Object.freeze({
    Initialize: {
        index: 0,
        layout: L.struct([L.u32("instruction"), _N(), SN()])
    },
    Authorize: {
        index: 1,
        layout: L.struct([L.u32("instruction"), He("newAuthorized"), L.u32("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: L.struct([L.u32("instruction")])
    },
    Split: {
        index: 3,
        layout: L.struct([L.u32("instruction"), L.ns64("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: L.struct([L.u32("instruction"), L.ns64("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: L.struct([L.u32("instruction")])
    },
    Merge: {
        index: 7,
        layout: L.struct([L.u32("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: L.struct([L.u32("instruction"), He("newAuthorized"), L.u32("stakeAuthorizationType"), ya("authoritySeed"), He("authorityOwner")])
    }
})
  , Dz = Object.freeze({
    Staker: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
})
  , Md = class {
    constructor() {}
    static initialize(e) {
        let {stakePubkey: n, authorized: r, lockup: i} = e
          , o = i || tu.default
          , s = mo.Initialize
          , a = tt(s, {
            authorized: {
                staker: Ze(r.staker.toBuffer()),
                withdrawer: Ze(r.withdrawer.toBuffer())
            },
            lockup: {
                unixTimestamp: o.unixTimestamp,
                epoch: o.epoch,
                custodian: Ze(o.custodian.toBuffer())
            }
        })
          , c = {
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Mi,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: a
        };
        return new Te(c)
    }
    static createAccountWithSeed(e) {
        let n = new Se;
        n.add(Xt.createAccountWithSeed({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.stakePubkey,
            basePubkey: e.basePubkey,
            seed: e.seed,
            lamports: e.lamports,
            space: this.space,
            programId: this.programId
        }));
        let {stakePubkey: r, authorized: i, lockup: o} = e;
        return n.add(this.initialize({
            stakePubkey: r,
            authorized: i,
            lockup: o
        }))
    }
    static createAccount(e) {
        let n = new Se;
        n.add(Xt.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.stakePubkey,
            lamports: e.lamports,
            space: this.space,
            programId: this.programId
        }));
        let {stakePubkey: r, authorized: i, lockup: o} = e;
        return n.add(this.initialize({
            stakePubkey: r,
            authorized: i,
            lockup: o
        }))
    }
    static delegate(e) {
        let {stakePubkey: n, authorizedPubkey: r, votePubkey: i} = e
          , o = mo.Delegate
          , s = tt(o);
        return new Se().add({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: _i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: jy,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: mO,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: s
        })
    }
    static authorize(e) {
        let {stakePubkey: n, authorizedPubkey: r, newAuthorizedPubkey: i, stakeAuthorizationType: o, custodianPubkey: s} = e
          , a = mo.Authorize
          , c = tt(a, {
            newAuthorized: Ze(i.toBuffer()),
            stakeAuthorizationType: o.index
        })
          , u = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: _i,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return s && u.push({
            pubkey: s,
            isSigner: !0,
            isWritable: !1
        }),
        new Se().add({
            keys: u,
            programId: this.programId,
            data: c
        })
    }
    static authorizeWithSeed(e) {
        let {stakePubkey: n, authorityBase: r, authoritySeed: i, authorityOwner: o, newAuthorizedPubkey: s, stakeAuthorizationType: a, custodianPubkey: c} = e
          , u = mo.AuthorizeWithSeed
          , l = tt(u, {
            newAuthorized: Ze(s.toBuffer()),
            stakeAuthorizationType: a.index,
            authoritySeed: i,
            authorityOwner: Ze(o.toBuffer())
        })
          , d = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: _i,
            isSigner: !1,
            isWritable: !1
        }];
        return c && d.push({
            pubkey: c,
            isSigner: !0,
            isWritable: !1
        }),
        new Se().add({
            keys: d,
            programId: this.programId,
            data: l
        })
    }
    static splitInstruction(e) {
        let {stakePubkey: n, authorizedPubkey: r, splitStakePubkey: i, lamports: o} = e
          , s = mo.Split
          , a = tt(s, {
            lamports: o
        });
        return new Te({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: a
        })
    }
    static split(e, n) {
        let r = new Se;
        return r.add(Xt.createAccount({
            fromPubkey: e.authorizedPubkey,
            newAccountPubkey: e.splitStakePubkey,
            lamports: n,
            space: this.space,
            programId: this.programId
        })),
        r.add(this.splitInstruction(e))
    }
    static splitWithSeed(e, n) {
        let {stakePubkey: r, authorizedPubkey: i, splitStakePubkey: o, basePubkey: s, seed: a, lamports: c} = e
          , u = new Se;
        return u.add(Xt.allocate({
            accountPubkey: o,
            basePubkey: s,
            seed: a,
            space: this.space,
            programId: this.programId
        })),
        n && n > 0 && u.add(Xt.transfer({
            fromPubkey: e.authorizedPubkey,
            toPubkey: o,
            lamports: n
        })),
        u.add(this.splitInstruction({
            stakePubkey: r,
            authorizedPubkey: i,
            splitStakePubkey: o,
            lamports: c
        }))
    }
    static merge(e) {
        let {stakePubkey: n, sourceStakePubKey: r, authorizedPubkey: i} = e
          , o = mo.Merge
          , s = tt(o);
        return new Se().add({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: _i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: jy,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: i,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: s
        })
    }
    static withdraw(e) {
        let {stakePubkey: n, authorizedPubkey: r, toPubkey: i, lamports: o, custodianPubkey: s} = e
          , a = mo.Withdraw
          , c = tt(a, {
            lamports: o
        })
          , u = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: i,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: _i,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: jy,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return s && u.push({
            pubkey: s,
            isSigner: !0,
            isWritable: !1
        }),
        new Se().add({
            keys: u,
            programId: this.programId,
            data: c
        })
    }
    static deactivate(e) {
        let {stakePubkey: n, authorizedPubkey: r} = e
          , i = mo.Deactivate
          , o = tt(i);
        return new Se().add({
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: _i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: o
        })
    }
}
;
Md.programId = new le("Stake11111111111111111111111111111111111111");
Md.space = 200;
var Xc = Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: L.struct([L.u32("instruction"), MN()])
    },
    Authorize: {
        index: 1,
        layout: L.struct([L.u32("instruction"), He("newAuthorized"), L.u32("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: L.struct([L.u32("instruction"), L.ns64("lamports")])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: L.struct([L.u32("instruction")])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: L.struct([L.u32("instruction"), kN()])
    }
})
  , Iz = Object.freeze({
    Voter: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
})
  , kd = class t {
    constructor() {}
    static initializeAccount(e) {
        let {votePubkey: n, nodePubkey: r, voteInit: i} = e
          , o = Xc.InitializeAccount
          , s = tt(o, {
            voteInit: {
                nodePubkey: Ze(i.nodePubkey.toBuffer()),
                authorizedVoter: Ze(i.authorizedVoter.toBuffer()),
                authorizedWithdrawer: Ze(i.authorizedWithdrawer.toBuffer()),
                commission: i.commission
            }
        })
          , a = {
            keys: [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Mi,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: _i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: s
        };
        return new Te(a)
    }
    static createAccount(e) {
        let n = new Se;
        return n.add(Xt.createAccount({
            fromPubkey: e.fromPubkey,
            newAccountPubkey: e.votePubkey,
            lamports: e.lamports,
            space: this.space,
            programId: this.programId
        })),
        n.add(this.initializeAccount({
            votePubkey: e.votePubkey,
            nodePubkey: e.voteInit.nodePubkey,
            voteInit: e.voteInit
        }))
    }
    static authorize(e) {
        let {votePubkey: n, authorizedPubkey: r, newAuthorizedPubkey: i, voteAuthorizationType: o} = e
          , s = Xc.Authorize
          , a = tt(s, {
            newAuthorized: Ze(i.toBuffer()),
            voteAuthorizationType: o.index
        })
          , c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: _i,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return new Se().add({
            keys: c,
            programId: this.programId,
            data: a
        })
    }
    static authorizeWithSeed(e) {
        let {currentAuthorityDerivedKeyBasePubkey: n, currentAuthorityDerivedKeyOwnerPubkey: r, currentAuthorityDerivedKeySeed: i, newAuthorizedPubkey: o, voteAuthorizationType: s, votePubkey: a} = e
          , c = Xc.AuthorizeWithSeed
          , u = tt(c, {
            voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: Ze(r.toBuffer()),
                currentAuthorityDerivedKeySeed: i,
                newAuthorized: Ze(o.toBuffer()),
                voteAuthorizationType: s.index
            }
        })
          , l = [{
            pubkey: a,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: _i,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: n,
            isSigner: !0,
            isWritable: !1
        }];
        return new Se().add({
            keys: l,
            programId: this.programId,
            data: u
        })
    }
    static withdraw(e) {
        let {votePubkey: n, authorizedWithdrawerPubkey: r, lamports: i, toPubkey: o} = e
          , s = Xc.Withdraw
          , a = tt(s, {
            lamports: i
        })
          , c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: o,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return new Se().add({
            keys: c,
            programId: this.programId,
            data: a
        })
    }
    static safeWithdraw(e, n, r) {
        if (e.lamports > n - r)
            throw new Error("Withdraw will leave vote account with insufficient funds.");
        return t.withdraw(e)
    }
    static updateValidatorIdentity(e) {
        let {votePubkey: n, authorizedWithdrawerPubkey: r, nodePubkey: i} = e
          , o = Xc.UpdateValidatorIdentity
          , s = tt(o)
          , a = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }];
        return new Se().add({
            keys: a,
            programId: this.programId,
            data: s
        })
    }
}
;
kd.programId = new le("Vote111111111111111111111111111111111111111");
kd.space = 3762;
var Az = new le("Va1idator1nfo111111111111111111111111111111")
  , _z = re({
    name: oe(),
    website: De(oe()),
    details: De(oe()),
    keybaseUsername: De(oe())
});
var Sz = new le("Vote111111111111111111111111111111111111111")
  , Mz = L.struct([He("nodePubkey"), He("authorizedWithdrawer"), L.u8("commission"), L.nu64(), L.seq(L.struct([L.nu64("slot"), L.u32("confirmationCount")]), L.offset(L.u32(), -8), "votes"), L.u8("rootSlotValid"), L.nu64("rootSlot"), L.nu64(), L.seq(L.struct([L.nu64("epoch"), He("authorizedVoter")]), L.offset(L.u32(), -8), "authorizedVoters"), L.struct([L.seq(L.struct([He("authorizedPubkey"), L.nu64("epochOfLastAuthorizedSwitch"), L.nu64("targetEpoch")]), 32, "buf"), L.nu64("idx"), L.u8("isEmpty")], "priorVoters"), L.nu64(), L.seq(L.struct([L.nu64("epoch"), L.nu64("credits"), L.nu64("prevCredits")]), L.offset(L.u32(), -8), "epochCredits"), L.struct([L.nu64("slot"), L.nu64("timestamp")], "lastTimestamp")]);
var kI = 1e9;
function vo(t) {
    "@babel/helpers - typeof";
    return vo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    vo(t)
}
function lv(t, e) {
    if (vo(t) != "object" || !t)
        return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e || "default");
        if (vo(r) != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}
function fv(t) {
    var e = lv(t, "string");
    return vo(e) == "symbol" ? e : String(e)
}
function os(t, e, n) {
    return e = fv(e),
    e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n,
    t
}
var zI = Gn(Rf());
var We = {}
  , Xd = {};
Xd.byteLength = vO;
Xd.toByteArray = wO;
Xd.fromByteArray = CO;
var ri = []
  , yr = []
  , yO = typeof Uint8Array < "u" ? Uint8Array : Array
  , dv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (ss = 0,
TI = dv.length; ss < TI; ++ss)
    ri[ss] = dv[ss],
    yr[dv.charCodeAt(ss)] = ss;
var ss, TI;
yr[45] = 62;
yr[95] = 63;
function qI(t) {
    var e = t.length;
    if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    n === -1 && (n = e);
    var r = n === e ? 0 : 4 - n % 4;
    return [n, r]
}
function vO(t) {
    var e = qI(t)
      , n = e[0]
      , r = e[1];
    return (n + r) * 3 / 4 - r
}
function xO(t, e, n) {
    return (e + n) * 3 / 4 - n
}
function wO(t) {
    var e, n = qI(t), r = n[0], i = n[1], o = new yO(xO(t, r, i)), s = 0, a = i > 0 ? r - 4 : r, c;
    for (c = 0; c < a; c += 4)
        e = yr[t.charCodeAt(c)] << 18 | yr[t.charCodeAt(c + 1)] << 12 | yr[t.charCodeAt(c + 2)] << 6 | yr[t.charCodeAt(c + 3)],
        o[s++] = e >> 16 & 255,
        o[s++] = e >> 8 & 255,
        o[s++] = e & 255;
    return i === 2 && (e = yr[t.charCodeAt(c)] << 2 | yr[t.charCodeAt(c + 1)] >> 4,
    o[s++] = e & 255),
    i === 1 && (e = yr[t.charCodeAt(c)] << 10 | yr[t.charCodeAt(c + 1)] << 4 | yr[t.charCodeAt(c + 2)] >> 2,
    o[s++] = e >> 8 & 255,
    o[s++] = e & 255),
    o
}
function bO(t) {
    return ri[t >> 18 & 63] + ri[t >> 12 & 63] + ri[t >> 6 & 63] + ri[t & 63]
}
function EO(t, e, n) {
    for (var r, i = [], o = e; o < n; o += 3)
        r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255),
        i.push(bO(r));
    return i.join("")
}
function CO(t) {
    for (var e, n = t.length, r = n % 3, i = [], o = 16383, s = 0, a = n - r; s < a; s += o)
        i.push(EO(t, s, s + o > a ? a : s + o));
    return r === 1 ? (e = t[n - 1],
    i.push(ri[e >> 2] + ri[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1],
    i.push(ri[e >> 10] + ri[e >> 4 & 63] + ri[e << 2 & 63] + "=")),
    i.join("")
}
var Cv = {};
Cv.read = function(t, e, n, r, i) {
    var o, s, a = i * 8 - r - 1, c = (1 << a) - 1, u = c >> 1, l = -7, d = n ? i - 1 : 0, y = n ? -1 : 1, v = t[e + d];
    for (d += y,
    o = v & (1 << -l) - 1,
    v >>= -l,
    l += a; l > 0; o = o * 256 + t[e + d],
    d += y,
    l -= 8)
        ;
    for (s = o & (1 << -l) - 1,
    o >>= -l,
    l += r; l > 0; s = s * 256 + t[e + d],
    d += y,
    l -= 8)
        ;
    if (o === 0)
        o = 1 - u;
    else {
        if (o === c)
            return s ? NaN : (v ? -1 : 1) * (1 / 0);
        s = s + Math.pow(2, r),
        o = o - u
    }
    return (v ? -1 : 1) * s * Math.pow(2, o - r)
}
;
Cv.write = function(t, e, n, r, i, o) {
    var s, a, c, u = o * 8 - i - 1, l = (1 << u) - 1, d = l >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = r ? 0 : o - 1, E = r ? 1 : -1, D = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e),
    isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
    s = l) : (s = Math.floor(Math.log(e) / Math.LN2),
    e * (c = Math.pow(2, -s)) < 1 && (s--,
    c *= 2),
    s + d >= 1 ? e += y / c : e += y * Math.pow(2, 1 - d),
    e * c >= 2 && (s++,
    c /= 2),
    s + d >= l ? (a = 0,
    s = l) : s + d >= 1 ? (a = (e * c - 1) * Math.pow(2, i),
    s = s + d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, i),
    s = 0)); i >= 8; t[n + v] = a & 255,
    v += E,
    a /= 256,
    i -= 8)
        ;
    for (s = s << i | a,
    u += i; u > 0; t[n + v] = s & 255,
    v += E,
    s /= 256,
    u -= 8)
        ;
    t[n + v - E] |= D * 128
}
;
(function(t) {
    let e = Xd
      , n = Cv
      , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = a,
    t.SlowBuffer = M,
    t.INSPECT_MAX_BYTES = 50;
    let i = 2147483647;
    t.kMaxLength = i,
    a.TYPED_ARRAY_SUPPORT = o(),
    !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function o() {
        try {
            let _ = new Uint8Array(1)
              , p = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(p, Uint8Array.prototype),
            Object.setPrototypeOf(_, p),
            _.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.byteOffset
        }
    });
    function s(_) {
        if (_ > i)
            throw new RangeError('The value "' + _ + '" is invalid for option "size"');
        let p = new Uint8Array(_);
        return Object.setPrototypeOf(p, a.prototype),
        p
    }
    function a(_, p, m) {
        if (typeof _ == "number") {
            if (typeof p == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return d(_)
        }
        return c(_, p, m)
    }
    a.poolSize = 8192;
    function c(_, p, m) {
        if (typeof _ == "string")
            return y(_, p);
        if (ArrayBuffer.isView(_))
            return E(_);
        if (_ == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _);
        if (jt(_, ArrayBuffer) || _ && jt(_.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (jt(_, SharedArrayBuffer) || _ && jt(_.buffer, SharedArrayBuffer)))
            return D(_, p, m);
        if (typeof _ == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        let R = _.valueOf && _.valueOf();
        if (R != null && R !== _)
            return a.from(R, p, m);
        let U = S(_);
        if (U)
            return U;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof _[Symbol.toPrimitive] == "function")
            return a.from(_[Symbol.toPrimitive]("string"), p, m);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _)
    }
    a.from = function(_, p, m) {
        return c(_, p, m)
    }
    ,
    Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(a, Uint8Array);
    function u(_) {
        if (typeof _ != "number")
            throw new TypeError('"size" argument must be of type number');
        if (_ < 0)
            throw new RangeError('The value "' + _ + '" is invalid for option "size"')
    }
    function l(_, p, m) {
        return u(_),
        _ <= 0 ? s(_) : p !== void 0 ? typeof m == "string" ? s(_).fill(p, m) : s(_).fill(p) : s(_)
    }
    a.alloc = function(_, p, m) {
        return l(_, p, m)
    }
    ;
    function d(_) {
        return u(_),
        s(_ < 0 ? 0 : w(_) | 0)
    }
    a.allocUnsafe = function(_) {
        return d(_)
    }
    ,
    a.allocUnsafeSlow = function(_) {
        return d(_)
    }
    ;
    function y(_, p) {
        if ((typeof p != "string" || p === "") && (p = "utf8"),
        !a.isEncoding(p))
            throw new TypeError("Unknown encoding: " + p);
        let m = F(_, p) | 0
          , R = s(m)
          , U = R.write(_, p);
        return U !== m && (R = R.slice(0, U)),
        R
    }
    function v(_) {
        let p = _.length < 0 ? 0 : w(_.length) | 0
          , m = s(p);
        for (let R = 0; R < p; R += 1)
            m[R] = _[R] & 255;
        return m
    }
    function E(_) {
        if (jt(_, Uint8Array)) {
            let p = new Uint8Array(_);
            return D(p.buffer, p.byteOffset, p.byteLength)
        }
        return v(_)
    }
    function D(_, p, m) {
        if (p < 0 || _.byteLength < p)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (_.byteLength < p + (m || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let R;
        return p === void 0 && m === void 0 ? R = new Uint8Array(_) : m === void 0 ? R = new Uint8Array(_,p) : R = new Uint8Array(_,p,m),
        Object.setPrototypeOf(R, a.prototype),
        R
    }
    function S(_) {
        if (a.isBuffer(_)) {
            let p = w(_.length) | 0
              , m = s(p);
            return m.length === 0 || _.copy(m, 0, 0, p),
            m
        }
        if (_.length !== void 0)
            return typeof _.length != "number" || dt(_.length) ? s(0) : v(_);
        if (_.type === "Buffer" && Array.isArray(_.data))
            return v(_.data)
    }
    function w(_) {
        if (_ >= i)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return _ | 0
    }
    function M(_) {
        return +_ != _ && (_ = 0),
        a.alloc(+_)
    }
    a.isBuffer = function(p) {
        return p != null && p._isBuffer === !0 && p !== a.prototype
    }
    ,
    a.compare = function(p, m) {
        if (jt(p, Uint8Array) && (p = a.from(p, p.offset, p.byteLength)),
        jt(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)),
        !a.isBuffer(p) || !a.isBuffer(m))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (p === m)
            return 0;
        let R = p.length
          , U = m.length;
        for (let j = 0, G = Math.min(R, U); j < G; ++j)
            if (p[j] !== m[j]) {
                R = p[j],
                U = m[j];
                break
            }
        return R < U ? -1 : U < R ? 1 : 0
    }
    ,
    a.isEncoding = function(p) {
        switch (String(p).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    a.concat = function(p, m) {
        if (!Array.isArray(p))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (p.length === 0)
            return a.alloc(0);
        let R;
        if (m === void 0)
            for (m = 0,
            R = 0; R < p.length; ++R)
                m += p[R].length;
        let U = a.allocUnsafe(m)
          , j = 0;
        for (R = 0; R < p.length; ++R) {
            let G = p[R];
            if (jt(G, Uint8Array))
                j + G.length > U.length ? (a.isBuffer(G) || (G = a.from(G)),
                G.copy(U, j)) : Uint8Array.prototype.set.call(U, G, j);
            else if (a.isBuffer(G))
                G.copy(U, j);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            j += G.length
        }
        return U
    }
    ;
    function F(_, p) {
        if (a.isBuffer(_))
            return _.length;
        if (ArrayBuffer.isView(_) || jt(_, ArrayBuffer))
            return _.byteLength;
        if (typeof _ != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof _);
        let m = _.length
          , R = arguments.length > 2 && arguments[2] === !0;
        if (!R && m === 0)
            return 0;
        let U = !1;
        for (; ; )
            switch (p) {
            case "ascii":
            case "latin1":
            case "binary":
                return m;
            case "utf8":
            case "utf-8":
                return st(_).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return m * 2;
            case "hex":
                return m >>> 1;
            case "base64":
                return je(_).length;
            default:
                if (U)
                    return R ? -1 : st(_).length;
                p = ("" + p).toLowerCase(),
                U = !0
            }
    }
    a.byteLength = F;
    function N(_, p, m) {
        let R = !1;
        if ((p === void 0 || p < 0) && (p = 0),
        p > this.length || ((m === void 0 || m > this.length) && (m = this.length),
        m <= 0) || (m >>>= 0,
        p >>>= 0,
        m <= p))
            return "";
        for (_ || (_ = "utf8"); ; )
            switch (_) {
            case "hex":
                return C(this, p, m);
            case "utf8":
            case "utf-8":
                return f(this, p, m);
            case "ascii":
                return I(this, p, m);
            case "latin1":
            case "binary":
                return A(this, p, m);
            case "base64":
                return T(this, p, m);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return k(this, p, m);
            default:
                if (R)
                    throw new TypeError("Unknown encoding: " + _);
                _ = (_ + "").toLowerCase(),
                R = !0
            }
    }
    a.prototype._isBuffer = !0;
    function P(_, p, m) {
        let R = _[p];
        _[p] = _[m],
        _[m] = R
    }
    a.prototype.swap16 = function() {
        let p = this.length;
        if (p % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let m = 0; m < p; m += 2)
            P(this, m, m + 1);
        return this
    }
    ,
    a.prototype.swap32 = function() {
        let p = this.length;
        if (p % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let m = 0; m < p; m += 4)
            P(this, m, m + 3),
            P(this, m + 1, m + 2);
        return this
    }
    ,
    a.prototype.swap64 = function() {
        let p = this.length;
        if (p % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let m = 0; m < p; m += 8)
            P(this, m, m + 7),
            P(this, m + 1, m + 6),
            P(this, m + 2, m + 5),
            P(this, m + 3, m + 4);
        return this
    }
    ,
    a.prototype.toString = function() {
        let p = this.length;
        return p === 0 ? "" : arguments.length === 0 ? f(this, 0, p) : N.apply(this, arguments)
    }
    ,
    a.prototype.toLocaleString = a.prototype.toString,
    a.prototype.equals = function(p) {
        if (!a.isBuffer(p))
            throw new TypeError("Argument must be a Buffer");
        return this === p ? !0 : a.compare(this, p) === 0
    }
    ,
    a.prototype.inspect = function() {
        let p = ""
          , m = t.INSPECT_MAX_BYTES;
        return p = this.toString("hex", 0, m).replace(/(.{2})/g, "$1 ").trim(),
        this.length > m && (p += " ... "),
        "<Buffer " + p + ">"
    }
    ,
    r && (a.prototype[r] = a.prototype.inspect),
    a.prototype.compare = function(p, m, R, U, j) {
        if (jt(p, Uint8Array) && (p = a.from(p, p.offset, p.byteLength)),
        !a.isBuffer(p))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof p);
        if (m === void 0 && (m = 0),
        R === void 0 && (R = p ? p.length : 0),
        U === void 0 && (U = 0),
        j === void 0 && (j = this.length),
        m < 0 || R > p.length || U < 0 || j > this.length)
            throw new RangeError("out of range index");
        if (U >= j && m >= R)
            return 0;
        if (U >= j)
            return -1;
        if (m >= R)
            return 1;
        if (m >>>= 0,
        R >>>= 0,
        U >>>= 0,
        j >>>= 0,
        this === p)
            return 0;
        let G = j - U
          , Be = R - m
          , ke = Math.min(G, Be)
          , Ae = this.slice(U, j)
          , xt = p.slice(m, R);
        for (let Ee = 0; Ee < ke; ++Ee)
            if (Ae[Ee] !== xt[Ee]) {
                G = Ae[Ee],
                Be = xt[Ee];
                break
            }
        return G < Be ? -1 : Be < G ? 1 : 0
    }
    ;
    function O(_, p, m, R, U) {
        if (_.length === 0)
            return -1;
        if (typeof m == "string" ? (R = m,
        m = 0) : m > 2147483647 ? m = 2147483647 : m < -2147483648 && (m = -2147483648),
        m = +m,
        dt(m) && (m = U ? 0 : _.length - 1),
        m < 0 && (m = _.length + m),
        m >= _.length) {
            if (U)
                return -1;
            m = _.length - 1
        } else if (m < 0)
            if (U)
                m = 0;
            else
                return -1;
        if (typeof p == "string" && (p = a.from(p, R)),
        a.isBuffer(p))
            return p.length === 0 ? -1 : z(_, p, m, R, U);
        if (typeof p == "number")
            return p = p & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(_, p, m) : Uint8Array.prototype.lastIndexOf.call(_, p, m) : z(_, [p], m, R, U);
        throw new TypeError("val must be string, number or Buffer")
    }
    function z(_, p, m, R, U) {
        let j = 1
          , G = _.length
          , Be = p.length;
        if (R !== void 0 && (R = String(R).toLowerCase(),
        R === "ucs2" || R === "ucs-2" || R === "utf16le" || R === "utf-16le")) {
            if (_.length < 2 || p.length < 2)
                return -1;
            j = 2,
            G /= 2,
            Be /= 2,
            m /= 2
        }
        function ke(xt, Ee) {
            return j === 1 ? xt[Ee] : xt.readUInt16BE(Ee * j)
        }
        let Ae;
        if (U) {
            let xt = -1;
            for (Ae = m; Ae < G; Ae++)
                if (ke(_, Ae) === ke(p, xt === -1 ? 0 : Ae - xt)) {
                    if (xt === -1 && (xt = Ae),
                    Ae - xt + 1 === Be)
                        return xt * j
                } else
                    xt !== -1 && (Ae -= Ae - xt),
                    xt = -1
        } else
            for (m + Be > G && (m = G - Be),
            Ae = m; Ae >= 0; Ae--) {
                let xt = !0;
                for (let Ee = 0; Ee < Be; Ee++)
                    if (ke(_, Ae + Ee) !== ke(p, Ee)) {
                        xt = !1;
                        break
                    }
                if (xt)
                    return Ae
            }
        return -1
    }
    a.prototype.includes = function(p, m, R) {
        return this.indexOf(p, m, R) !== -1
    }
    ,
    a.prototype.indexOf = function(p, m, R) {
        return O(this, p, m, R, !0)
    }
    ,
    a.prototype.lastIndexOf = function(p, m, R) {
        return O(this, p, m, R, !1)
    }
    ;
    function q(_, p, m, R) {
        m = Number(m) || 0;
        let U = _.length - m;
        R ? (R = Number(R),
        R > U && (R = U)) : R = U;
        let j = p.length;
        R > j / 2 && (R = j / 2);
        let G;
        for (G = 0; G < R; ++G) {
            let Be = parseInt(p.substr(G * 2, 2), 16);
            if (dt(Be))
                return G;
            _[m + G] = Be
        }
        return G
    }
    function J(_, p, m, R) {
        return ze(st(p, _.length - m), _, m, R)
    }
    function te(_, p, m, R) {
        return ze(ft(p), _, m, R)
    }
    function V(_, p, m, R) {
        return ze(je(p), _, m, R)
    }
    function Q(_, p, m, R) {
        return ze(on(p, _.length - m), _, m, R)
    }
    a.prototype.write = function(p, m, R, U) {
        if (m === void 0)
            U = "utf8",
            R = this.length,
            m = 0;
        else if (R === void 0 && typeof m == "string")
            U = m,
            R = this.length,
            m = 0;
        else if (isFinite(m))
            m = m >>> 0,
            isFinite(R) ? (R = R >>> 0,
            U === void 0 && (U = "utf8")) : (U = R,
            R = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let j = this.length - m;
        if ((R === void 0 || R > j) && (R = j),
        p.length > 0 && (R < 0 || m < 0) || m > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        U || (U = "utf8");
        let G = !1;
        for (; ; )
            switch (U) {
            case "hex":
                return q(this, p, m, R);
            case "utf8":
            case "utf-8":
                return J(this, p, m, R);
            case "ascii":
            case "latin1":
            case "binary":
                return te(this, p, m, R);
            case "base64":
                return V(this, p, m, R);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Q(this, p, m, R);
            default:
                if (G)
                    throw new TypeError("Unknown encoding: " + U);
                U = ("" + U).toLowerCase(),
                G = !0
            }
    }
    ,
    a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function T(_, p, m) {
        return p === 0 && m === _.length ? e.fromByteArray(_) : e.fromByteArray(_.slice(p, m))
    }
    function f(_, p, m) {
        m = Math.min(_.length, m);
        let R = []
          , U = p;
        for (; U < m; ) {
            let j = _[U]
              , G = null
              , Be = j > 239 ? 4 : j > 223 ? 3 : j > 191 ? 2 : 1;
            if (U + Be <= m) {
                let ke, Ae, xt, Ee;
                switch (Be) {
                case 1:
                    j < 128 && (G = j);
                    break;
                case 2:
                    ke = _[U + 1],
                    (ke & 192) === 128 && (Ee = (j & 31) << 6 | ke & 63,
                    Ee > 127 && (G = Ee));
                    break;
                case 3:
                    ke = _[U + 1],
                    Ae = _[U + 2],
                    (ke & 192) === 128 && (Ae & 192) === 128 && (Ee = (j & 15) << 12 | (ke & 63) << 6 | Ae & 63,
                    Ee > 2047 && (Ee < 55296 || Ee > 57343) && (G = Ee));
                    break;
                case 4:
                    ke = _[U + 1],
                    Ae = _[U + 2],
                    xt = _[U + 3],
                    (ke & 192) === 128 && (Ae & 192) === 128 && (xt & 192) === 128 && (Ee = (j & 15) << 18 | (ke & 63) << 12 | (Ae & 63) << 6 | xt & 63,
                    Ee > 65535 && Ee < 1114112 && (G = Ee))
                }
            }
            G === null ? (G = 65533,
            Be = 1) : G > 65535 && (G -= 65536,
            R.push(G >>> 10 & 1023 | 55296),
            G = 56320 | G & 1023),
            R.push(G),
            U += Be
        }
        return x(R)
    }
    let g = 4096;
    function x(_) {
        let p = _.length;
        if (p <= g)
            return String.fromCharCode.apply(String, _);
        let m = ""
          , R = 0;
        for (; R < p; )
            m += String.fromCharCode.apply(String, _.slice(R, R += g));
        return m
    }
    function I(_, p, m) {
        let R = "";
        m = Math.min(_.length, m);
        for (let U = p; U < m; ++U)
            R += String.fromCharCode(_[U] & 127);
        return R
    }
    function A(_, p, m) {
        let R = "";
        m = Math.min(_.length, m);
        for (let U = p; U < m; ++U)
            R += String.fromCharCode(_[U]);
        return R
    }
    function C(_, p, m) {
        let R = _.length;
        (!p || p < 0) && (p = 0),
        (!m || m < 0 || m > R) && (m = R);
        let U = "";
        for (let j = p; j < m; ++j)
            U += nt[_[j]];
        return U
    }
    function k(_, p, m) {
        let R = _.slice(p, m)
          , U = "";
        for (let j = 0; j < R.length - 1; j += 2)
            U += String.fromCharCode(R[j] + R[j + 1] * 256);
        return U
    }
    a.prototype.slice = function(p, m) {
        let R = this.length;
        p = ~~p,
        m = m === void 0 ? R : ~~m,
        p < 0 ? (p += R,
        p < 0 && (p = 0)) : p > R && (p = R),
        m < 0 ? (m += R,
        m < 0 && (m = 0)) : m > R && (m = R),
        m < p && (m = p);
        let U = this.subarray(p, m);
        return Object.setPrototypeOf(U, a.prototype),
        U
    }
    ;
    function b(_, p, m) {
        if (_ % 1 !== 0 || _ < 0)
            throw new RangeError("offset is not uint");
        if (_ + p > m)
            throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(p, m, R) {
        p = p >>> 0,
        m = m >>> 0,
        R || b(p, m, this.length);
        let U = this[p]
          , j = 1
          , G = 0;
        for (; ++G < m && (j *= 256); )
            U += this[p + G] * j;
        return U
    }
    ,
    a.prototype.readUintBE = a.prototype.readUIntBE = function(p, m, R) {
        p = p >>> 0,
        m = m >>> 0,
        R || b(p, m, this.length);
        let U = this[p + --m]
          , j = 1;
        for (; m > 0 && (j *= 256); )
            U += this[p + --m] * j;
        return U
    }
    ,
    a.prototype.readUint8 = a.prototype.readUInt8 = function(p, m) {
        return p = p >>> 0,
        m || b(p, 1, this.length),
        this[p]
    }
    ,
    a.prototype.readUint16LE = a.prototype.readUInt16LE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 2, this.length),
        this[p] | this[p + 1] << 8
    }
    ,
    a.prototype.readUint16BE = a.prototype.readUInt16BE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 2, this.length),
        this[p] << 8 | this[p + 1]
    }
    ,
    a.prototype.readUint32LE = a.prototype.readUInt32LE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 4, this.length),
        (this[p] | this[p + 1] << 8 | this[p + 2] << 16) + this[p + 3] * 16777216
    }
    ,
    a.prototype.readUint32BE = a.prototype.readUInt32BE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 4, this.length),
        this[p] * 16777216 + (this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3])
    }
    ,
    a.prototype.readBigUInt64LE = $t(function(p) {
        p = p >>> 0,
        ot(p, "offset");
        let m = this[p]
          , R = this[p + 7];
        (m === void 0 || R === void 0) && Fe(p, this.length - 8);
        let U = m + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24
          , j = this[++p] + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + R * 2 ** 24;
        return BigInt(U) + (BigInt(j) << BigInt(32))
    }),
    a.prototype.readBigUInt64BE = $t(function(p) {
        p = p >>> 0,
        ot(p, "offset");
        let m = this[p]
          , R = this[p + 7];
        (m === void 0 || R === void 0) && Fe(p, this.length - 8);
        let U = m * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p]
          , j = this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + R;
        return (BigInt(U) << BigInt(32)) + BigInt(j)
    }),
    a.prototype.readIntLE = function(p, m, R) {
        p = p >>> 0,
        m = m >>> 0,
        R || b(p, m, this.length);
        let U = this[p]
          , j = 1
          , G = 0;
        for (; ++G < m && (j *= 256); )
            U += this[p + G] * j;
        return j *= 128,
        U >= j && (U -= Math.pow(2, 8 * m)),
        U
    }
    ,
    a.prototype.readIntBE = function(p, m, R) {
        p = p >>> 0,
        m = m >>> 0,
        R || b(p, m, this.length);
        let U = m
          , j = 1
          , G = this[p + --U];
        for (; U > 0 && (j *= 256); )
            G += this[p + --U] * j;
        return j *= 128,
        G >= j && (G -= Math.pow(2, 8 * m)),
        G
    }
    ,
    a.prototype.readInt8 = function(p, m) {
        return p = p >>> 0,
        m || b(p, 1, this.length),
        this[p] & 128 ? (255 - this[p] + 1) * -1 : this[p]
    }
    ,
    a.prototype.readInt16LE = function(p, m) {
        p = p >>> 0,
        m || b(p, 2, this.length);
        let R = this[p] | this[p + 1] << 8;
        return R & 32768 ? R | 4294901760 : R
    }
    ,
    a.prototype.readInt16BE = function(p, m) {
        p = p >>> 0,
        m || b(p, 2, this.length);
        let R = this[p + 1] | this[p] << 8;
        return R & 32768 ? R | 4294901760 : R
    }
    ,
    a.prototype.readInt32LE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 4, this.length),
        this[p] | this[p + 1] << 8 | this[p + 2] << 16 | this[p + 3] << 24
    }
    ,
    a.prototype.readInt32BE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 4, this.length),
        this[p] << 24 | this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3]
    }
    ,
    a.prototype.readBigInt64LE = $t(function(p) {
        p = p >>> 0,
        ot(p, "offset");
        let m = this[p]
          , R = this[p + 7];
        (m === void 0 || R === void 0) && Fe(p, this.length - 8);
        let U = this[p + 4] + this[p + 5] * 2 ** 8 + this[p + 6] * 2 ** 16 + (R << 24);
        return (BigInt(U) << BigInt(32)) + BigInt(m + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24)
    }),
    a.prototype.readBigInt64BE = $t(function(p) {
        p = p >>> 0,
        ot(p, "offset");
        let m = this[p]
          , R = this[p + 7];
        (m === void 0 || R === void 0) && Fe(p, this.length - 8);
        let U = (m << 24) + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p];
        return (BigInt(U) << BigInt(32)) + BigInt(this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + R)
    }),
    a.prototype.readFloatLE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 4, this.length),
        n.read(this, p, !0, 23, 4)
    }
    ,
    a.prototype.readFloatBE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 4, this.length),
        n.read(this, p, !1, 23, 4)
    }
    ,
    a.prototype.readDoubleLE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 8, this.length),
        n.read(this, p, !0, 52, 8)
    }
    ,
    a.prototype.readDoubleBE = function(p, m) {
        return p = p >>> 0,
        m || b(p, 8, this.length),
        n.read(this, p, !1, 52, 8)
    }
    ;
    function h(_, p, m, R, U, j) {
        if (!a.isBuffer(_))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (p > U || p < j)
            throw new RangeError('"value" argument is out of bounds');
        if (m + R > _.length)
            throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(p, m, R, U) {
        if (p = +p,
        m = m >>> 0,
        R = R >>> 0,
        !U) {
            let Be = Math.pow(2, 8 * R) - 1;
            h(this, p, m, R, Be, 0)
        }
        let j = 1
          , G = 0;
        for (this[m] = p & 255; ++G < R && (j *= 256); )
            this[m + G] = p / j & 255;
        return m + R
    }
    ,
    a.prototype.writeUintBE = a.prototype.writeUIntBE = function(p, m, R, U) {
        if (p = +p,
        m = m >>> 0,
        R = R >>> 0,
        !U) {
            let Be = Math.pow(2, 8 * R) - 1;
            h(this, p, m, R, Be, 0)
        }
        let j = R - 1
          , G = 1;
        for (this[m + j] = p & 255; --j >= 0 && (G *= 256); )
            this[m + j] = p / G & 255;
        return m + R
    }
    ,
    a.prototype.writeUint8 = a.prototype.writeUInt8 = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 1, 255, 0),
        this[m] = p & 255,
        m + 1
    }
    ,
    a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 2, 65535, 0),
        this[m] = p & 255,
        this[m + 1] = p >>> 8,
        m + 2
    }
    ,
    a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 2, 65535, 0),
        this[m] = p >>> 8,
        this[m + 1] = p & 255,
        m + 2
    }
    ,
    a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 4, 4294967295, 0),
        this[m + 3] = p >>> 24,
        this[m + 2] = p >>> 16,
        this[m + 1] = p >>> 8,
        this[m] = p & 255,
        m + 4
    }
    ,
    a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 4, 4294967295, 0),
        this[m] = p >>> 24,
        this[m + 1] = p >>> 16,
        this[m + 2] = p >>> 8,
        this[m + 3] = p & 255,
        m + 4
    }
    ;
    function B(_, p, m, R, U) {
        pe(p, R, U, _, m, 7);
        let j = Number(p & BigInt(4294967295));
        _[m++] = j,
        j = j >> 8,
        _[m++] = j,
        j = j >> 8,
        _[m++] = j,
        j = j >> 8,
        _[m++] = j;
        let G = Number(p >> BigInt(32) & BigInt(4294967295));
        return _[m++] = G,
        G = G >> 8,
        _[m++] = G,
        G = G >> 8,
        _[m++] = G,
        G = G >> 8,
        _[m++] = G,
        m
    }
    function Y(_, p, m, R, U) {
        pe(p, R, U, _, m, 7);
        let j = Number(p & BigInt(4294967295));
        _[m + 7] = j,
        j = j >> 8,
        _[m + 6] = j,
        j = j >> 8,
        _[m + 5] = j,
        j = j >> 8,
        _[m + 4] = j;
        let G = Number(p >> BigInt(32) & BigInt(4294967295));
        return _[m + 3] = G,
        G = G >> 8,
        _[m + 2] = G,
        G = G >> 8,
        _[m + 1] = G,
        G = G >> 8,
        _[m] = G,
        m + 8
    }
    a.prototype.writeBigUInt64LE = $t(function(p, m=0) {
        return B(this, p, m, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeBigUInt64BE = $t(function(p, m=0) {
        return Y(this, p, m, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeIntLE = function(p, m, R, U) {
        if (p = +p,
        m = m >>> 0,
        !U) {
            let ke = Math.pow(2, 8 * R - 1);
            h(this, p, m, R, ke - 1, -ke)
        }
        let j = 0
          , G = 1
          , Be = 0;
        for (this[m] = p & 255; ++j < R && (G *= 256); )
            p < 0 && Be === 0 && this[m + j - 1] !== 0 && (Be = 1),
            this[m + j] = (p / G >> 0) - Be & 255;
        return m + R
    }
    ,
    a.prototype.writeIntBE = function(p, m, R, U) {
        if (p = +p,
        m = m >>> 0,
        !U) {
            let ke = Math.pow(2, 8 * R - 1);
            h(this, p, m, R, ke - 1, -ke)
        }
        let j = R - 1
          , G = 1
          , Be = 0;
        for (this[m + j] = p & 255; --j >= 0 && (G *= 256); )
            p < 0 && Be === 0 && this[m + j + 1] !== 0 && (Be = 1),
            this[m + j] = (p / G >> 0) - Be & 255;
        return m + R
    }
    ,
    a.prototype.writeInt8 = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 1, 127, -128),
        p < 0 && (p = 255 + p + 1),
        this[m] = p & 255,
        m + 1
    }
    ,
    a.prototype.writeInt16LE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 2, 32767, -32768),
        this[m] = p & 255,
        this[m + 1] = p >>> 8,
        m + 2
    }
    ,
    a.prototype.writeInt16BE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 2, 32767, -32768),
        this[m] = p >>> 8,
        this[m + 1] = p & 255,
        m + 2
    }
    ,
    a.prototype.writeInt32LE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 4, 2147483647, -2147483648),
        this[m] = p & 255,
        this[m + 1] = p >>> 8,
        this[m + 2] = p >>> 16,
        this[m + 3] = p >>> 24,
        m + 4
    }
    ,
    a.prototype.writeInt32BE = function(p, m, R) {
        return p = +p,
        m = m >>> 0,
        R || h(this, p, m, 4, 2147483647, -2147483648),
        p < 0 && (p = 4294967295 + p + 1),
        this[m] = p >>> 24,
        this[m + 1] = p >>> 16,
        this[m + 2] = p >>> 8,
        this[m + 3] = p & 255,
        m + 4
    }
    ,
    a.prototype.writeBigInt64LE = $t(function(p, m=0) {
        return B(this, p, m, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    a.prototype.writeBigInt64BE = $t(function(p, m=0) {
        return Y(this, p, m, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function ne(_, p, m, R, U, j) {
        if (m + R > _.length)
            throw new RangeError("Index out of range");
        if (m < 0)
            throw new RangeError("Index out of range")
    }
    function K(_, p, m, R, U) {
        return p = +p,
        m = m >>> 0,
        U || ne(_, p, m, 4),
        n.write(_, p, m, R, 23, 4),
        m + 4
    }
    a.prototype.writeFloatLE = function(p, m, R) {
        return K(this, p, m, !0, R)
    }
    ,
    a.prototype.writeFloatBE = function(p, m, R) {
        return K(this, p, m, !1, R)
    }
    ;
    function se(_, p, m, R, U) {
        return p = +p,
        m = m >>> 0,
        U || ne(_, p, m, 8),
        n.write(_, p, m, R, 52, 8),
        m + 8
    }
    a.prototype.writeDoubleLE = function(p, m, R) {
        return se(this, p, m, !0, R)
    }
    ,
    a.prototype.writeDoubleBE = function(p, m, R) {
        return se(this, p, m, !1, R)
    }
    ,
    a.prototype.copy = function(p, m, R, U) {
        if (!a.isBuffer(p))
            throw new TypeError("argument should be a Buffer");
        if (R || (R = 0),
        !U && U !== 0 && (U = this.length),
        m >= p.length && (m = p.length),
        m || (m = 0),
        U > 0 && U < R && (U = R),
        U === R || p.length === 0 || this.length === 0)
            return 0;
        if (m < 0)
            throw new RangeError("targetStart out of bounds");
        if (R < 0 || R >= this.length)
            throw new RangeError("Index out of range");
        if (U < 0)
            throw new RangeError("sourceEnd out of bounds");
        U > this.length && (U = this.length),
        p.length - m < U - R && (U = p.length - m + R);
        let j = U - R;
        return this === p && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(m, R, U) : Uint8Array.prototype.set.call(p, this.subarray(R, U), m),
        j
    }
    ,
    a.prototype.fill = function(p, m, R, U) {
        if (typeof p == "string") {
            if (typeof m == "string" ? (U = m,
            m = 0,
            R = this.length) : typeof R == "string" && (U = R,
            R = this.length),
            U !== void 0 && typeof U != "string")
                throw new TypeError("encoding must be a string");
            if (typeof U == "string" && !a.isEncoding(U))
                throw new TypeError("Unknown encoding: " + U);
            if (p.length === 1) {
                let G = p.charCodeAt(0);
                (U === "utf8" && G < 128 || U === "latin1") && (p = G)
            }
        } else
            typeof p == "number" ? p = p & 255 : typeof p == "boolean" && (p = Number(p));
        if (m < 0 || this.length < m || this.length < R)
            throw new RangeError("Out of range index");
        if (R <= m)
            return this;
        m = m >>> 0,
        R = R === void 0 ? this.length : R >>> 0,
        p || (p = 0);
        let j;
        if (typeof p == "number")
            for (j = m; j < R; ++j)
                this[j] = p;
        else {
            let G = a.isBuffer(p) ? p : a.from(p, U)
              , Be = G.length;
            if (Be === 0)
                throw new TypeError('The value "' + p + '" is invalid for argument "value"');
            for (j = 0; j < R - m; ++j)
                this[j + m] = G[j % Be]
        }
        return this
    }
    ;
    let de = {};
    function xe(_, p, m) {
        de[_] = class extends m {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: p.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${_}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return _
            }
            set code(U) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: U,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${_}]: ${this.message}`
            }
        }
    }
    xe("ERR_BUFFER_OUT_OF_BOUNDS", function(_) {
        return _ ? `${_} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    xe("ERR_INVALID_ARG_TYPE", function(_, p) {
        return `The "${_}" argument must be of type number. Received type ${typeof p}`
    }, TypeError),
    xe("ERR_OUT_OF_RANGE", function(_, p, m) {
        let R = `The value of "${_}" is out of range.`
          , U = m;
        return Number.isInteger(m) && Math.abs(m) > 2 ** 32 ? U = Ke(String(m)) : typeof m == "bigint" && (U = String(m),
        (m > BigInt(2) ** BigInt(32) || m < -(BigInt(2) ** BigInt(32))) && (U = Ke(U)),
        U += "n"),
        R += ` It must be ${p}. Received ${U}`,
        R
    }, RangeError);
    function Ke(_) {
        let p = ""
          , m = _.length
          , R = _[0] === "-" ? 1 : 0;
        for (; m >= R + 4; m -= 3)
            p = `_${_.slice(m - 3, m)}${p}`;
        return `${_.slice(0, m)}${p}`
    }
    function ye(_, p, m) {
        ot(p, "offset"),
        (_[p] === void 0 || _[p + m] === void 0) && Fe(p, _.length - (m + 1))
    }
    function pe(_, p, m, R, U, j) {
        if (_ > m || _ < p) {
            let G = typeof p == "bigint" ? "n" : "", Be;
            throw j > 3 ? p === 0 || p === BigInt(0) ? Be = `>= 0${G} and < 2${G} ** ${(j + 1) * 8}${G}` : Be = `>= -(2${G} ** ${(j + 1) * 8 - 1}${G}) and < 2 ** ${(j + 1) * 8 - 1}${G}` : Be = `>= ${p}${G} and <= ${m}${G}`,
            new de.ERR_OUT_OF_RANGE("value",Be,_)
        }
        ye(R, U, j)
    }
    function ot(_, p) {
        if (typeof _ != "number")
            throw new de.ERR_INVALID_ARG_TYPE(p,"number",_)
    }
    function Fe(_, p, m) {
        throw Math.floor(_) !== _ ? (ot(_, m),
        new de.ERR_OUT_OF_RANGE(m || "offset","an integer",_)) : p < 0 ? new de.ERR_BUFFER_OUT_OF_BOUNDS : new de.ERR_OUT_OF_RANGE(m || "offset",`>= ${m ? 1 : 0} and <= ${p}`,_)
    }
    let Ye = /[^+/0-9A-Za-z-_]/g;
    function yn(_) {
        if (_ = _.split("=")[0],
        _ = _.trim().replace(Ye, ""),
        _.length < 2)
            return "";
        for (; _.length % 4 !== 0; )
            _ = _ + "=";
        return _
    }
    function st(_, p) {
        p = p || 1 / 0;
        let m, R = _.length, U = null, j = [];
        for (let G = 0; G < R; ++G) {
            if (m = _.charCodeAt(G),
            m > 55295 && m < 57344) {
                if (!U) {
                    if (m > 56319) {
                        (p -= 3) > -1 && j.push(239, 191, 189);
                        continue
                    } else if (G + 1 === R) {
                        (p -= 3) > -1 && j.push(239, 191, 189);
                        continue
                    }
                    U = m;
                    continue
                }
                if (m < 56320) {
                    (p -= 3) > -1 && j.push(239, 191, 189),
                    U = m;
                    continue
                }
                m = (U - 55296 << 10 | m - 56320) + 65536
            } else
                U && (p -= 3) > -1 && j.push(239, 191, 189);
            if (U = null,
            m < 128) {
                if ((p -= 1) < 0)
                    break;
                j.push(m)
            } else if (m < 2048) {
                if ((p -= 2) < 0)
                    break;
                j.push(m >> 6 | 192, m & 63 | 128)
            } else if (m < 65536) {
                if ((p -= 3) < 0)
                    break;
                j.push(m >> 12 | 224, m >> 6 & 63 | 128, m & 63 | 128)
            } else if (m < 1114112) {
                if ((p -= 4) < 0)
                    break;
                j.push(m >> 18 | 240, m >> 12 & 63 | 128, m >> 6 & 63 | 128, m & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return j
    }
    function ft(_) {
        let p = [];
        for (let m = 0; m < _.length; ++m)
            p.push(_.charCodeAt(m) & 255);
        return p
    }
    function on(_, p) {
        let m, R, U, j = [];
        for (let G = 0; G < _.length && !((p -= 2) < 0); ++G)
            m = _.charCodeAt(G),
            R = m >> 8,
            U = m % 256,
            j.push(U),
            j.push(R);
        return j
    }
    function je(_) {
        return e.toByteArray(yn(_))
    }
    function ze(_, p, m, R) {
        let U;
        for (U = 0; U < R && !(U + m >= p.length || U >= _.length); ++U)
            p[U + m] = _[U];
        return U
    }
    function jt(_, p) {
        return _ instanceof p || _ != null && _.constructor != null && _.constructor.name != null && _.constructor.name === p.name
    }
    function dt(_) {
        return _ !== _
    }
    let nt = function() {
        let _ = "0123456789abcdef"
          , p = new Array(256);
        for (let m = 0; m < 16; ++m) {
            let R = m * 16;
            for (let U = 0; U < 16; ++U)
                p[R + U] = _[m] + _[U]
        }
        return p
    }();
    function $t(_) {
        return typeof BigInt > "u" ? vt : _
    }
    function vt() {
        throw new Error("BigInt not supported")
    }
}
)(We);
var DO = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {}, mv;
typeof Object.create == "function" ? mv = function(e, n) {
    e.super_ = n,
    e.prototype = Object.create(n.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    })
}
: mv = function(e, n) {
    e.super_ = n;
    var r = function() {};
    r.prototype = n.prototype,
    e.prototype = new r,
    e.prototype.constructor = e
}
;
var IO = mv;
function as(t, e) {
    var n = {
        seen: [],
        stylize: _O
    };
    return arguments.length >= 3 && (n.depth = arguments[2]),
    arguments.length >= 4 && (n.colors = arguments[3]),
    WI(e) ? n.showHidden = e : e && FO(n, e),
    Ca(n.showHidden) && (n.showHidden = !1),
    Ca(n.depth) && (n.depth = 2),
    Ca(n.colors) && (n.colors = !1),
    Ca(n.customInspect) && (n.customInspect = !0),
    n.colors && (n.stylize = AO),
    Pd(n, t, n.depth)
}
as.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
};
as.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red"
};
function AO(t, e) {
    var n = as.styles[e];
    return n ? "\x1B[" + as.colors[n][0] + "m" + t + "\x1B[" + as.colors[n][1] + "m" : t
}
function _O(t, e) {
    return t
}
function SO(t) {
    var e = {};
    return t.forEach(function(n, r) {
        e[n] = !0
    }),
    e
}
function Pd(t, e, n) {
    if (t.customInspect && e && ou(e.inspect) && e.inspect !== as && !(e.constructor && e.constructor.prototype === e)) {
        var r = e.inspect(n, t);
        return KI(r) || (r = Pd(t, r, n)),
        r
    }
    var i = MO(t, e);
    if (i)
        return i;
    var o = Object.keys(e)
      , s = SO(o);
    if (t.showHidden && (o = Object.getOwnPropertyNames(e)),
    Nd(e) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0))
        return hv(e);
    if (o.length === 0) {
        if (ou(e)) {
            var a = e.name ? ": " + e.name : "";
            return t.stylize("[Function" + a + "]", "special")
        }
        if (iu(e))
            return t.stylize(RegExp.prototype.toString.call(e), "regexp");
        if (Od(e))
            return t.stylize(Date.prototype.toString.call(e), "date");
        if (Nd(e))
            return hv(e)
    }
    var c = ""
      , u = !1
      , l = ["{", "}"];
    if (BO(e) && (u = !0,
    l = ["[", "]"]),
    ou(e)) {
        var d = e.name ? ": " + e.name : "";
        c = " [Function" + d + "]"
    }
    if (iu(e) && (c = " " + RegExp.prototype.toString.call(e)),
    Od(e) && (c = " " + Date.prototype.toUTCString.call(e)),
    Nd(e) && (c = " " + hv(e)),
    o.length === 0 && (!u || e.length == 0))
        return l[0] + c + l[1];
    if (n < 0)
        return iu(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
    t.seen.push(e);
    var y;
    return u ? y = kO(t, e, n, s, o) : y = o.map(function(v) {
        return yv(t, e, n, s, v, u)
    }),
    t.seen.pop(),
    TO(y, c, l)
}
function MO(t, e) {
    if (Ca(e))
        return t.stylize("undefined", "undefined");
    if (KI(e)) {
        var n = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return t.stylize(n, "string")
    }
    if (RO(e))
        return t.stylize("" + e, "number");
    if (WI(e))
        return t.stylize("" + e, "boolean");
    if (GI(e))
        return t.stylize("null", "null")
}
function hv(t) {
    return "[" + Error.prototype.toString.call(t) + "]"
}
function kO(t, e, n, r, i) {
    for (var o = [], s = 0, a = e.length; s < a; ++s)
        YI(e, String(s)) ? o.push(yv(t, e, n, r, String(s), !0)) : o.push("");
    return i.forEach(function(c) {
        c.match(/^\d+$/) || o.push(yv(t, e, n, r, c, !0))
    }),
    o
}
function yv(t, e, n, r, i, o) {
    var s, a, c;
    if (c = Object.getOwnPropertyDescriptor(e, i) || {
        value: e[i]
    },
    c.get ? c.set ? a = t.stylize("[Getter/Setter]", "special") : a = t.stylize("[Getter]", "special") : c.set && (a = t.stylize("[Setter]", "special")),
    YI(r, i) || (s = "[" + i + "]"),
    a || (t.seen.indexOf(c.value) < 0 ? (GI(n) ? a = Pd(t, c.value, null) : a = Pd(t, c.value, n - 1),
    a.indexOf(`
`) > -1 && (o ? a = a.split(`
`).map(function(u) {
        return "  " + u
    }).join(`
`).substr(2) : a = `
` + a.split(`
`).map(function(u) {
        return "   " + u
    }).join(`
`))) : a = t.stylize("[Circular]", "special")),
    Ca(s)) {
        if (o && i.match(/^\d+$/))
            return a;
        s = JSON.stringify("" + i),
        s.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2),
        s = t.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
        s = t.stylize(s, "string"))
    }
    return s + ": " + a
}
function TO(t, e, n) {
    var r = t.reduce(function(i, o) {
        return o.indexOf(`
`) >= 0,
        i + o.replace(/\u001b\[\d\d?m/g, "").length + 1
    }, 0);
    return r > 60 ? n[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + n[1] : n[0] + e + " " + t.join(", ") + " " + n[1]
}
function BO(t) {
    return Array.isArray(t)
}
function WI(t) {
    return typeof t == "boolean"
}
function GI(t) {
    return t === null
}
function RO(t) {
    return typeof t == "number"
}
function KI(t) {
    return typeof t == "string"
}
function Ca(t) {
    return t === void 0
}
function iu(t) {
    return Qd(t) && Dv(t) === "[object RegExp]"
}
function Qd(t) {
    return typeof t == "object" && t !== null
}
function Od(t) {
    return Qd(t) && Dv(t) === "[object Date]"
}
function Nd(t) {
    return Qd(t) && (Dv(t) === "[object Error]" || t instanceof Error)
}
function ou(t) {
    return typeof t == "function"
}
function BI(t) {
    return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || typeof t > "u"
}
function Dv(t) {
    return Object.prototype.toString.call(t)
}
function FO(t, e) {
    if (!e || !Qd(e))
        return t;
    for (var n = Object.keys(e), r = n.length; r--; )
        t[n[r]] = e[n[r]];
    return t
}
function YI(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e)
}
function RI(t, e) {
    if (t === e)
        return 0;
    for (var n = t.length, r = e.length, i = 0, o = Math.min(n, r); i < o; ++i)
        if (t[i] !== e[i]) {
            n = t[i],
            r = e[i];
            break
        }
    return n < r ? -1 : r < n ? 1 : 0
}
var NO = Object.prototype.hasOwnProperty, FI = Object.keys || function(t) {
    var e = [];
    for (var n in t)
        NO.call(t, n) && e.push(n);
    return e
}
, NI = Array.prototype.slice, pv;
function ZI() {
    return typeof pv < "u" ? pv : pv = function() {
        return (function() {}
        ).name === "foo"
    }()
}
function PI(t) {
    return Object.prototype.toString.call(t)
}
function OI(t) {
    return We.isBuffer(t) || typeof DO.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t ? !!(t instanceof DataView || t.buffer && t.buffer instanceof ArrayBuffer) : !1
}
function Rn(t, e) {
    t || Wn(t, !0, e, "==", Av)
}
var PO = /\s*function\s+([^\(\s]*)\s*/;
function XI(t) {
    if (ou(t)) {
        if (ZI())
            return t.name;
        var e = t.toString()
          , n = e.match(PO);
        return n && n[1]
    }
}
Rn.AssertionError = Iv;
function Iv(t) {
    this.name = "AssertionError",
    this.actual = t.actual,
    this.expected = t.expected,
    this.operator = t.operator,
    t.message ? (this.message = t.message,
    this.generatedMessage = !1) : (this.message = OO(this),
    this.generatedMessage = !0);
    var e = t.stackStartFunction || Wn;
    if (Error.captureStackTrace)
        Error.captureStackTrace(this, e);
    else {
        var n = new Error;
        if (n.stack) {
            var r = n.stack
              , i = XI(e)
              , o = r.indexOf(`
` + i);
            if (o >= 0) {
                var s = r.indexOf(`
`, o + 1);
                r = r.substring(s + 1)
            }
            this.stack = r
        }
    }
}
IO(Iv, Error);
function LI(t, e) {
    return typeof t == "string" ? t.length < e ? t : t.slice(0, e) : t
}
function UI(t) {
    if (ZI() || !ou(t))
        return as(t);
    var e = XI(t)
      , n = e ? ": " + e : "";
    return "[Function" + n + "]"
}
function OO(t) {
    return LI(UI(t.actual), 128) + " " + t.operator + " " + LI(UI(t.expected), 128)
}
function Wn(t, e, n, r, i) {
    throw new Iv({
        message: n,
        actual: t,
        expected: e,
        operator: r,
        stackStartFunction: i
    })
}
Rn.fail = Wn;
function Av(t, e) {
    t || Wn(t, !0, e, "==", Av)
}
Rn.ok = Av;
Rn.equal = QI;
function QI(t, e, n) {
    t != e && Wn(t, e, n, "==", QI)
}
Rn.notEqual = JI;
function JI(t, e, n) {
    t == e && Wn(t, e, n, "!=", JI)
}
Rn.deepEqual = eA;
function eA(t, e, n) {
    Da(t, e, !1) || Wn(t, e, n, "deepEqual", eA)
}
Rn.deepStrictEqual = tA;
function tA(t, e, n) {
    Da(t, e, !0) || Wn(t, e, n, "deepStrictEqual", tA)
}
function Da(t, e, n, r) {
    if (t === e)
        return !0;
    if (We.isBuffer(t) && We.isBuffer(e))
        return RI(t, e) === 0;
    if (Od(t) && Od(e))
        return t.getTime() === e.getTime();
    if (iu(t) && iu(e))
        return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase;
    if ((t === null || typeof t != "object") && (e === null || typeof e != "object"))
        return n ? t === e : t == e;
    if (OI(t) && OI(e) && PI(t) === PI(e) && !(t instanceof Float32Array || t instanceof Float64Array))
        return RI(new Uint8Array(t.buffer), new Uint8Array(e.buffer)) === 0;
    if (We.isBuffer(t) !== We.isBuffer(e))
        return !1;
    r = r || {
        actual: [],
        expected: []
    };
    var i = r.actual.indexOf(t);
    return i !== -1 && i === r.expected.indexOf(e) ? !0 : (r.actual.push(t),
    r.expected.push(e),
    LO(t, e, n, r))
}
function VI(t) {
    return Object.prototype.toString.call(t) == "[object Arguments]"
}
function LO(t, e, n, r) {
    if (t == null || e === null || e === void 0)
        return !1;
    if (BI(t) || BI(e))
        return t === e;
    if (n && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e))
        return !1;
    var i = VI(t)
      , o = VI(e);
    if (i && !o || !i && o)
        return !1;
    if (i)
        return t = NI.call(t),
        e = NI.call(e),
        Da(t, e, n);
    var s = FI(t), a = FI(e), c, u;
    if (s.length !== a.length)
        return !1;
    for (s.sort(),
    a.sort(),
    u = s.length - 1; u >= 0; u--)
        if (s[u] !== a[u])
            return !1;
    for (u = s.length - 1; u >= 0; u--)
        if (c = s[u],
        !Da(t[c], e[c], n, r))
            return !1;
    return !0
}
Rn.notDeepEqual = nA;
function nA(t, e, n) {
    Da(t, e, !1) && Wn(t, e, n, "notDeepEqual", nA)
}
Rn.notDeepStrictEqual = rA;
function rA(t, e, n) {
    Da(t, e, !0) && Wn(t, e, n, "notDeepStrictEqual", rA)
}
Rn.strictEqual = iA;
function iA(t, e, n) {
    t !== e && Wn(t, e, n, "===", iA)
}
Rn.notStrictEqual = oA;
function oA(t, e, n) {
    t === e && Wn(t, e, n, "!==", oA)
}
function jI(t, e) {
    if (!t || !e)
        return !1;
    if (Object.prototype.toString.call(e) == "[object RegExp]")
        return e.test(t);
    try {
        if (t instanceof e)
            return !0
    } catch {}
    return Error.isPrototypeOf(e) ? !1 : e.call({}, t) === !0
}
function UO(t) {
    var e;
    try {
        t()
    } catch (n) {
        e = n
    }
    return e
}
function sA(t, e, n, r) {
    var i;
    if (typeof e != "function")
        throw new TypeError('"block" argument must be a function');
    typeof n == "string" && (r = n,
    n = null),
    i = UO(e),
    r = (n && n.name ? " (" + n.name + ")." : ".") + (r ? " " + r : "."),
    t && !i && Wn(i, n, "Missing expected exception" + r);
    var o = typeof r == "string"
      , s = !t && Nd(i)
      , a = !t && i && !n;
    if ((s && o && jI(i, n) || a) && Wn(i, n, "Got unwanted exception" + r),
    t && i && n && !jI(i, n) || !t && i)
        throw i
}
Rn.throws = VO;
function VO(t, e, n) {
    sA(!0, t, e, n)
}
Rn.doesNotThrow = jO;
function jO(t, e, n) {
    sA(!1, t, e, n)
}
Rn.ifError = $O;
function $O(t) {
    if (t)
        throw t
}
var fe = {}
  , lt = class {
    constructor(e, n) {
        if (!Number.isInteger(e))
            throw new TypeError("span must be an integer");
        this.span = e,
        this.property = n
    }
    makeDestinationObject() {
        return {}
    }
    decode(e, n) {
        throw new Error("Layout is abstract")
    }
    encode(e, n, r) {
        throw new Error("Layout is abstract")
    }
    getSpan(e, n) {
        if (0 > this.span)
            throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(e) {
        let n = Object.create(this.constructor.prototype);
        return Object.assign(n, this),
        n.property = e,
        n
    }
    fromArray(e) {}
}
;
fe.Layout = lt;
function _v(t, e) {
    return e.property ? t + "[" + e.property + "]" : t
}
fe.nameWithProperty = _v;
function HO(t, e) {
    if (typeof t != "function")
        throw new TypeError("Class must be constructor");
    if (t.hasOwnProperty("layout_"))
        throw new Error("Class is already bound to a layout");
    if (!(e && e instanceof lt))
        throw new TypeError("layout must be a Layout");
    if (e.hasOwnProperty("boundConstructor_"))
        throw new Error("layout is already bound to a constructor");
    t.layout_ = e,
    e.boundConstructor_ = t,
    e.makeDestinationObject = ()=>new t,
    Object.defineProperty(t.prototype, "encode", {
        value: function(n, r) {
            return e.encode(this, n, r)
        },
        writable: !0
    }),
    Object.defineProperty(t, "decode", {
        value: function(n, r) {
            return e.decode(n, r)
        },
        writable: !0
    })
}
fe.bindConstructorLayout = HO;
var Bn = class extends lt {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
  , Ld = class extends Bn {
    constructor(e, n) {
        if (e === void 0 && (e = 1),
        !Number.isInteger(e) || 0 >= e)
            throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, n),
        this.elementSpan = e
    }
    isCount() {
        return !0
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = e.length - n;
        return Math.floor(r / this.elementSpan)
    }
    encode(e, n, r) {
        return 0
    }
}
  , au = class extends Bn {
    constructor(e, n, r) {
        if (!(e instanceof lt))
            throw new TypeError("layout must be a Layout");
        if (n === void 0)
            n = 0;
        else if (!Number.isInteger(n))
            throw new TypeError("offset must be integer or undefined");
        super(e.span, r || e.property),
        this.layout = e,
        this.offset = n
    }
    isCount() {
        return this.layout instanceof xr || this.layout instanceof Fr
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        this.layout.decode(e, n + this.offset)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        this.layout.encode(e, n, r + this.offset)
    }
}
  , xr = class extends lt {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readUIntLE(n, this.span)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeUIntLE(e, r, this.span),
        this.span
    }
}
  , Fr = class extends lt {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readUIntBE(n, this.span)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeUIntBE(e, r, this.span),
        this.span
    }
}
  , ki = class extends lt {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readIntLE(n, this.span)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeIntLE(e, r, this.span),
        this.span
    }
}
  , xo = class extends lt {
    constructor(e, n) {
        if (super(e, n),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readIntBE(n, this.span)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeIntBE(e, r, this.span),
        this.span
    }
}
  , vv = Math.pow(2, 32);
function Jd(t) {
    let e = Math.floor(t / vv)
      , n = t - e * vv;
    return {
        hi32: e,
        lo32: n
    }
}
function eh(t, e) {
    return t * vv + e
}
var xv = class extends lt {
    constructor(e) {
        super(8, e)
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = e.readUInt32LE(n)
          , i = e.readUInt32LE(n + 4);
        return eh(i, r)
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = Jd(e);
        return n.writeUInt32LE(i.lo32, r),
        n.writeUInt32LE(i.hi32, r + 4),
        8
    }
}
  , wv = class extends lt {
    constructor(e) {
        super(8, e)
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = e.readUInt32BE(n)
          , i = e.readUInt32BE(n + 4);
        return eh(r, i)
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = Jd(e);
        return n.writeUInt32BE(i.hi32, r),
        n.writeUInt32BE(i.lo32, r + 4),
        8
    }
}
  , bv = class extends lt {
    constructor(e) {
        super(8, e)
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = e.readUInt32LE(n)
          , i = e.readInt32LE(n + 4);
        return eh(i, r)
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = Jd(e);
        return n.writeUInt32LE(i.lo32, r),
        n.writeInt32LE(i.hi32, r + 4),
        8
    }
}
  , Ev = class extends lt {
    constructor(e) {
        super(8, e)
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = e.readInt32BE(n)
          , i = e.readUInt32BE(n + 4);
        return eh(r, i)
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = Jd(e);
        return n.writeInt32BE(i.hi32, r),
        n.writeUInt32BE(i.lo32, r + 4),
        8
    }
}
  , Ud = class extends lt {
    constructor(e) {
        super(4, e)
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readFloatLE(n)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeFloatLE(e, r),
        4
    }
}
  , Vd = class extends lt {
    constructor(e) {
        super(4, e)
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readFloatBE(n)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeFloatBE(e, r),
        4
    }
}
  , jd = class extends lt {
    constructor(e) {
        super(8, e)
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readDoubleLE(n)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeDoubleLE(e, r),
        8
    }
}
  , $d = class extends lt {
    constructor(e) {
        super(8, e)
    }
    decode(e, n) {
        return n === void 0 && (n = 0),
        e.readDoubleBE(n)
    }
    encode(e, n, r) {
        return r === void 0 && (r = 0),
        n.writeDoubleBE(e, r),
        8
    }
}
  , Hd = class extends lt {
    constructor(e, n, r) {
        if (!(e instanceof lt))
            throw new TypeError("elementLayout must be a Layout");
        if (!(n instanceof Bn && n.isCount() || Number.isInteger(n) && 0 <= n))
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let i = -1;
        !(n instanceof Bn) && 0 < e.span && (i = n * e.span),
        super(i, r),
        this.elementLayout = e,
        this.count = n
    }
    getSpan(e, n) {
        if (0 <= this.span)
            return this.span;
        n === void 0 && (n = 0);
        let r = 0
          , i = this.count;
        if (i instanceof Bn && (i = i.decode(e, n)),
        0 < this.elementLayout.span)
            r = i * this.elementLayout.span;
        else {
            let o = 0;
            for (; o < i; )
                r += this.elementLayout.getSpan(e, n + r),
                ++o
        }
        return r
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = []
          , i = 0
          , o = this.count;
        for (o instanceof Bn && (o = o.decode(e, n)); i < o; )
            r.push(this.elementLayout.decode(e, n)),
            n += this.elementLayout.getSpan(e, n),
            i += 1;
        return r
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = this.elementLayout
          , o = e.reduce((s,a)=>s + i.encode(a, n, r + s), 0);
        return this.count instanceof Bn && this.count.encode(e.length, n, r),
        o
    }
}
  , zd = class extends lt {
    constructor(e, n, r) {
        if (!(Array.isArray(e) && e.reduce((o,s)=>o && s instanceof lt, !0)))
            throw new TypeError("fields must be array of Layout instances");
        typeof n == "boolean" && r === void 0 && (r = n,
        n = void 0);
        for (let o of e)
            if (0 > o.span && o.property === void 0)
                throw new Error("fields cannot contain unnamed variable-length layout");
        let i = -1;
        try {
            i = e.reduce((o,s)=>o + s.getSpan(), 0)
        } catch {}
        super(i, n),
        this.fields = e,
        this.decodePrefixes = !!r
    }
    getSpan(e, n) {
        if (0 <= this.span)
            return this.span;
        n === void 0 && (n = 0);
        let r = 0;
        try {
            r = this.fields.reduce((i,o)=>{
                let s = o.getSpan(e, n);
                return n += s,
                i + s
            }
            , 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return r
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = this.makeDestinationObject();
        for (let i of this.fields)
            if (i.property !== void 0 && (r[i.property] = i.decode(e, n)),
            n += i.getSpan(e, n),
            this.decodePrefixes && e.length === n)
                break;
        return r
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = r
          , o = 0
          , s = 0;
        for (let a of this.fields) {
            let c = a.span;
            if (s = 0 < c ? c : 0,
            a.property !== void 0) {
                let u = e[a.property];
                u !== void 0 && (s = a.encode(u, n, r),
                0 > c && (c = a.getSpan(n, r)))
            }
            o = r,
            r += c
        }
        return o + s - i
    }
    fromArray(e) {
        let n = this.makeDestinationObject();
        for (let r of this.fields)
            r.property !== void 0 && 0 < e.length && (n[r.property] = e.shift());
        return n
    }
    layoutFor(e) {
        if (typeof e != "string")
            throw new TypeError("property must be string");
        for (let n of this.fields)
            if (n.property === e)
                return n
    }
    offsetOf(e) {
        if (typeof e != "string")
            throw new TypeError("property must be string");
        let n = 0;
        for (let r of this.fields) {
            if (r.property === e)
                return n;
            0 > r.span ? n = -1 : 0 <= n && (n += r.span)
        }
    }
}
  , cu = class {
    constructor(e) {
        this.property = e
    }
    decode() {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode() {
        throw new Error("UnionDiscriminator is abstract")
    }
}
  , Ia = class extends cu {
    constructor(e, n) {
        if (!(e instanceof Bn && e.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(n || e.property || "variant"),
        this.layout = e
    }
    decode(e, n) {
        return this.layout.decode(e, n)
    }
    encode(e, n, r) {
        return this.layout.encode(e, n, r)
    }
}
  , uu = class extends lt {
    constructor(e, n, r) {
        let i = e instanceof xr || e instanceof Fr;
        if (i)
            e = new Ia(new au(e));
        else if (e instanceof Bn && e.isCount())
            e = new Ia(e);
        else if (!(e instanceof cu))
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (n === void 0 && (n = null),
        !(n === null || n instanceof lt))
            throw new TypeError("defaultLayout must be null or a Layout");
        if (n !== null) {
            if (0 > n.span)
                throw new Error("defaultLayout must have constant span");
            n.property === void 0 && (n = n.replicate("content"))
        }
        let o = -1;
        n && (o = n.span,
        0 <= o && i && (o += e.layout.span)),
        super(o, r),
        this.discriminator = e,
        this.usesPrefixDiscriminator = i,
        this.defaultLayout = n,
        this.registry = {};
        let s = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(a) {
            return s(a)
        }
        ,
        this.configGetSourceVariant = function(a) {
            s = a.bind(this)
        }
    }
    getSpan(e, n) {
        if (0 <= this.span)
            return this.span;
        n === void 0 && (n = 0);
        let r = this.getVariant(e, n);
        if (!r)
            throw new Error("unable to determine span for unrecognized variant");
        return r.getSpan(e, n)
    }
    defaultGetSourceVariant(e) {
        if (e.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && e.hasOwnProperty(this.defaultLayout.property))
                return;
            let n = this.registry[e[this.discriminator.property]];
            if (n && (!n.layout || e.hasOwnProperty(n.property)))
                return n
        } else
            for (let n in this.registry) {
                let r = this.registry[n];
                if (e.hasOwnProperty(r.property))
                    return r
            }
        throw new Error("unable to infer src variant")
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r, i = this.discriminator, o = i.decode(e, n), s = this.registry[o];
        if (s === void 0) {
            let a = 0;
            s = this.defaultLayout,
            this.usesPrefixDiscriminator && (a = i.layout.span),
            r = this.makeDestinationObject(),
            r[i.property] = o,
            r[s.property] = this.defaultLayout.decode(e, n + a)
        } else
            r = s.decode(e, n);
        return r
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = this.getSourceVariant(e);
        if (i === void 0) {
            let o = this.discriminator
              , s = this.defaultLayout
              , a = 0;
            return this.usesPrefixDiscriminator && (a = o.layout.span),
            o.encode(e[o.property], n, r),
            a + s.encode(e[s.property], n, r + a)
        }
        return i.encode(e, n, r)
    }
    addVariant(e, n, r) {
        let i = new qd(this,e,n,r);
        return this.registry[e] = i,
        i
    }
    getVariant(e, n) {
        let r = e;
        return We.Buffer.isBuffer(e) && (n === void 0 && (n = 0),
        r = this.discriminator.decode(e, n)),
        this.registry[r]
    }
}
  , qd = class extends lt {
    constructor(e, n, r, i) {
        if (!(e instanceof uu))
            throw new TypeError("union must be a Union");
        if (!Number.isInteger(n) || 0 > n)
            throw new TypeError("variant must be a (non-negative) integer");
        if (typeof r == "string" && i === void 0 && (i = r,
        r = null),
        r) {
            if (!(r instanceof lt))
                throw new TypeError("layout must be a Layout");
            if (e.defaultLayout !== null && 0 <= r.span && r.span > e.defaultLayout.span)
                throw new Error("variant span exceeds span of containing union");
            if (typeof i != "string")
                throw new TypeError("variant must have a String property")
        }
        let o = e.span;
        0 > e.span && (o = r ? r.span : 0,
        0 <= o && e.usesPrefixDiscriminator && (o += e.discriminator.layout.span)),
        super(o, i),
        this.union = e,
        this.variant = n,
        this.layout = r || null
    }
    getSpan(e, n) {
        if (0 <= this.span)
            return this.span;
        n === void 0 && (n = 0);
        let r = 0;
        return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span),
        r + this.layout.getSpan(e, n + r)
    }
    decode(e, n) {
        let r = this.makeDestinationObject();
        if (n === void 0 && (n = 0),
        this !== this.union.getVariant(e, n))
            throw new Error("variant mismatch");
        let i = 0;
        return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
        this.layout ? r[this.property] = this.layout.decode(e, n + i) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant),
        r
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = 0;
        if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span),
        this.layout && !e.hasOwnProperty(this.property))
            throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, n, r);
        let o = i;
        if (this.layout && (this.layout.encode(e[this.property], n, r + i),
        o += this.layout.getSpan(n, r + i),
        0 <= this.union.span && o > this.union.span))
            throw new Error("encoded variant overruns containing union");
        return o
    }
    fromArray(e) {
        if (this.layout)
            return this.layout.fromArray(e)
    }
}
;
function Ea(t) {
    return 0 > t && (t += 4294967296),
    t
}
var lu = class extends lt {
    constructor(e, n, r) {
        if (!(e instanceof xr || e instanceof Fr))
            throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof n == "string" && r === void 0 && (r = n,
        n = void 0),
        4 < e.span)
            throw new RangeError("word cannot exceed 32 bits");
        super(e.span, r),
        this.word = e,
        this.msb = !!n,
        this.fields = [];
        let i = 0;
        this._packedSetValue = function(o) {
            return i = Ea(o),
            this
        }
        ,
        this._packedGetValue = function() {
            return i
        }
    }
    decode(e, n) {
        let r = this.makeDestinationObject();
        n === void 0 && (n = 0);
        let i = this.word.decode(e, n);
        this._packedSetValue(i);
        for (let o of this.fields)
            o.property !== void 0 && (r[o.property] = o.decode(i));
        return r
    }
    encode(e, n, r) {
        r === void 0 && (r = 0);
        let i = this.word.decode(n, r);
        this._packedSetValue(i);
        for (let o of this.fields)
            if (o.property !== void 0) {
                let s = e[o.property];
                s !== void 0 && o.encode(s)
            }
        return this.word.encode(this._packedGetValue(), n, r)
    }
    addField(e, n) {
        let r = new cs(this,e,n);
        return this.fields.push(r),
        r
    }
    addBoolean(e) {
        let n = new Wd(this,e);
        return this.fields.push(n),
        n
    }
    fieldFor(e) {
        if (typeof e != "string")
            throw new TypeError("property must be string");
        for (let n of this.fields)
            if (n.property === e)
                return n
    }
}
  , cs = class {
    constructor(e, n, r) {
        if (!(e instanceof lu))
            throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(n) || 0 >= n)
            throw new TypeError("bits must be positive integer");
        let i = 8 * e.span
          , o = e.fields.reduce((s,a)=>s + a.bits, 0);
        if (n + o > i)
            throw new Error("bits too long for span remainder (" + (i - o) + " of " + i + " remain)");
        this.container = e,
        this.bits = n,
        this.valueMask = (1 << n) - 1,
        n === 32 && (this.valueMask = 4294967295),
        this.start = o,
        this.container.msb && (this.start = i - o - n),
        this.wordMask = Ea(this.valueMask << this.start),
        this.property = r
    }
    decode() {
        let e = this.container._packedGetValue();
        return Ea(e & this.wordMask) >>> this.start
    }
    encode(e) {
        if (!Number.isInteger(e) || e !== Ea(e & this.valueMask))
            throw new TypeError(_v("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        let n = this.container._packedGetValue()
          , r = Ea(e << this.start);
        this.container._packedSetValue(Ea(n & ~this.wordMask) | r)
    }
}
  , Wd = class extends cs {
    constructor(e, n) {
        super(e, 1, n)
    }
    decode(e, n) {
        return !!cs.prototype.decode.call(this, e, n)
    }
    encode(e) {
        return typeof e == "boolean" && (e = +e),
        cs.prototype.encode.call(this, e)
    }
}
  , Gd = class extends lt {
    constructor(e, n) {
        if (!(e instanceof Bn && e.isCount() || Number.isInteger(e) && 0 <= e))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let r = -1;
        e instanceof Bn || (r = e),
        super(r, n),
        this.length = e
    }
    getSpan(e, n) {
        let r = this.span;
        return 0 > r && (r = this.length.decode(e, n)),
        r
    }
    decode(e, n) {
        n === void 0 && (n = 0);
        let r = this.span;
        return 0 > r && (r = this.length.decode(e, n)),
        e.slice(n, n + r)
    }
    encode(e, n, r) {
        let i = this.length;
        if (this.length instanceof Bn && (i = e.length),
        !(We.Buffer.isBuffer(e) && i === e.length))
            throw new TypeError(_v("Blob.encode", this) + " requires (length " + i + ") Buffer as src");
        if (r + i > n.length)
            throw new RangeError("encoding overruns Buffer");
        return n.write(e.toString("hex"), r, i, "hex"),
        this.length instanceof Bn && this.length.encode(i, n, r),
        i
    }
}
  , Kd = class extends lt {
    constructor(e) {
        super(-1, e)
    }
    getSpan(e, n) {
        if (!We.Buffer.isBuffer(e))
            throw new TypeError("b must be a Buffer");
        n === void 0 && (n = 0);
        let r = n;
        for (; r < e.length && e[r] !== 0; )
            r += 1;
        return 1 + r - n
    }
    decode(e, n, r) {
        n === void 0 && (n = 0);
        let i = this.getSpan(e, n);
        return e.slice(n, n + i - 1).toString("utf-8")
    }
    encode(e, n, r) {
        r === void 0 && (r = 0),
        typeof e != "string" && (e = e.toString());
        let i = new We.Buffer(e,"utf8")
          , o = i.length;
        if (r + o > n.length)
            throw new RangeError("encoding overruns Buffer");
        return i.copy(n, r),
        n[r + o] = 0,
        o + 1
    }
}
  , Yd = class extends lt {
    constructor(e, n) {
        if (typeof e == "string" && n === void 0 && (n = e,
        e = void 0),
        e === void 0)
            e = -1;
        else if (!Number.isInteger(e))
            throw new TypeError("maxSpan must be an integer");
        super(-1, n),
        this.maxSpan = e
    }
    getSpan(e, n) {
        if (!We.Buffer.isBuffer(e))
            throw new TypeError("b must be a Buffer");
        return n === void 0 && (n = 0),
        e.length - n
    }
    decode(e, n, r) {
        n === void 0 && (n = 0);
        let i = this.getSpan(e, n);
        if (0 <= this.maxSpan && this.maxSpan < i)
            throw new RangeError("text length exceeds maxSpan");
        return e.slice(n, n + i).toString("utf-8")
    }
    encode(e, n, r) {
        r === void 0 && (r = 0),
        typeof e != "string" && (e = e.toString());
        let i = new We.Buffer(e,"utf8")
          , o = i.length;
        if (0 <= this.maxSpan && this.maxSpan < o)
            throw new RangeError("text length exceeds maxSpan");
        if (r + o > n.length)
            throw new RangeError("encoding overruns Buffer");
        return i.copy(n, r),
        o
    }
}
  , Zd = class extends lt {
    constructor(e, n) {
        super(0, n),
        this.value = e
    }
    decode(e, n, r) {
        return this.value
    }
    encode(e, n, r) {
        return 0
    }
}
;
fe.ExternalLayout = Bn;
fe.GreedyCount = Ld;
fe.OffsetLayout = au;
fe.UInt = xr;
fe.UIntBE = Fr;
fe.Int = ki;
fe.IntBE = xo;
fe.Float = Ud;
fe.FloatBE = Vd;
fe.Double = jd;
fe.DoubleBE = $d;
fe.Sequence = Hd;
fe.Structure = zd;
fe.UnionDiscriminator = cu;
fe.UnionLayoutDiscriminator = Ia;
fe.Union = uu;
fe.VariantLayout = qd;
fe.BitStructure = lu;
fe.BitField = cs;
fe.Boolean = Wd;
fe.Blob = Gd;
fe.CString = Kd;
fe.UTF8 = Yd;
fe.Constant = Zd;
fe.greedy = (t,e)=>new Ld(t,e);
fe.offset = (t,e,n)=>new au(t,e,n);
var it = fe.u8 = t=>new xr(1,t);
fe.u16 = t=>new xr(2,t);
fe.u24 = t=>new xr(3,t);
var su = fe.u32 = t=>new xr(4,t);
fe.u40 = t=>new xr(5,t);
fe.u48 = t=>new xr(6,t);
fe.nu64 = t=>new xv(t);
fe.u16be = t=>new Fr(2,t);
fe.u24be = t=>new Fr(3,t);
fe.u32be = t=>new Fr(4,t);
fe.u40be = t=>new Fr(5,t);
fe.u48be = t=>new Fr(6,t);
fe.nu64be = t=>new wv(t);
fe.s8 = t=>new ki(1,t);
fe.s16 = t=>new ki(2,t);
fe.s24 = t=>new ki(3,t);
fe.s32 = t=>new ki(4,t);
fe.s40 = t=>new ki(5,t);
fe.s48 = t=>new ki(6,t);
fe.ns64 = t=>new bv(t);
fe.s16be = t=>new xo(2,t);
fe.s24be = t=>new xo(3,t);
fe.s32be = t=>new xo(4,t);
fe.s40be = t=>new xo(5,t);
fe.s48be = t=>new xo(6,t);
fe.ns64be = t=>new Ev(t);
fe.f32 = t=>new Ud(t);
fe.f32be = t=>new Vd(t);
fe.f64 = t=>new jd(t);
fe.f64be = t=>new $d(t);
var Qt = fe.struct = (t,e,n)=>new zd(t,e,n);
fe.bits = (t,e,n)=>new lu(t,e,n);
fe.seq = (t,e,n)=>new Hd(t,e,n);
fe.union = (t,e,n)=>new uu(t,e,n);
fe.unionLayoutDiscriminator = (t,e)=>new Ia(t,e);
var aA = fe.blob = (t,e)=>new Gd(t,e);
fe.cstr = t=>new Kd(t);
fe.utf8 = (t,e)=>new Yd(t,e);
fe.const = (t,e)=>new Zd(t,e);
var Jt = (t="publicKey")=>aA(32, t)
  , vr = (t="uint64")=>aA(8, t);
function nn(t, e, n, ...r) {
    return yI(e, n, r, {
        skipPreflight: !1
    })
}
var th = new le("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
  , nh = new le("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
  , $I = "Failed to find account"
  , HI = "Invalid account owner";
function gv(t) {
    return We.Buffer.from(t.toBuffer())
}
var Ln = class t extends zI.default {
    toBuffer() {
        let e = super.toArray().reverse()
          , n = We.Buffer.from(e);
        if (n.length === 8)
            return n;
        Rn(n.length < 8, "u64 too large");
        let r = We.Buffer.alloc(8);
        return n.copy(r),
        r
    }
    static fromBuffer(e) {
        return Rn(e.length === 8, `Invalid buffer length: ${e.length}`),
        new t([...e].reverse().map(n=>`00${n.toString(16)}`.slice(-2)).join(""),16)
    }
}
;
function rr(t) {
    return "publicKey"in t
}
var zO = {
    MintTokens: 0,
    FreezeAccount: 1,
    AccountOwner: 2,
    CloseAccount: 3
}
  , qO = new le("So11111111111111111111111111111111111111112")
  , Rd = Qt([su("mintAuthorityOption"), Jt("mintAuthority"), vr("supply"), it("decimals"), it("isInitialized"), su("freezeAuthorityOption"), Jt("freezeAuthority")])
  , ru = Qt([Jt("mint"), Jt("owner"), vr("amount"), su("delegateOption"), Jt("delegate"), it("state"), su("isNativeOption"), vr("isNative"), vr("delegatedAmount"), su("closeAuthorityOption"), Jt("closeAuthority")])
  , Fd = Qt([it("m"), it("n"), it("is_initialized"), Jt("signer1"), Jt("signer2"), Jt("signer3"), Jt("signer4"), Jt("signer5"), Jt("signer6"), Jt("signer7"), Jt("signer8"), Jt("signer9"), Jt("signer10"), Jt("signer11")])
  , Aa = class t {
    constructor(e, n, r, i) {
        os(this, "connection", void 0),
        os(this, "publicKey", void 0),
        os(this, "programId", void 0),
        os(this, "associatedProgramId", void 0),
        os(this, "payer", void 0),
        Object.assign(this, {
            connection: e,
            publicKey: n,
            programId: r,
            payer: i,
            associatedProgramId: nh
        })
    }
    static getMinBalanceRentForExemptMint(e) {
        return $(this, null, function*() {
            return yield e.getMinimumBalanceForRentExemption(Rd.span)
        })
    }
    static getMinBalanceRentForExemptAccount(e) {
        return $(this, null, function*() {
            return yield e.getMinimumBalanceForRentExemption(ru.span)
        })
    }
    static getMinBalanceRentForExemptMultisig(e) {
        return $(this, null, function*() {
            return yield e.getMinimumBalanceForRentExemption(Fd.span)
        })
    }
    static createMint(e, n, r, i, o, s) {
        return $(this, null, function*() {
            let a = ni.generate()
              , c = new t(e,a.publicKey,s,n)
              , u = yield t.getMinBalanceRentForExemptMint(e)
              , l = new Se;
            return l.add(Xt.createAccount({
                fromPubkey: n.publicKey,
                newAccountPubkey: a.publicKey,
                lamports: u,
                space: Rd.span,
                programId: s
            })),
            l.add(t.createInitMintInstruction(s, a.publicKey, o, r, i)),
            yield nn("createAccount and InitializeMint", e, l, n, a),
            c
        })
    }
    createAccount(e) {
        return $(this, null, function*() {
            let n = yield t.getMinBalanceRentForExemptAccount(this.connection)
              , r = ni.generate()
              , i = new Se;
            i.add(Xt.createAccount({
                fromPubkey: this.payer.publicKey,
                newAccountPubkey: r.publicKey,
                lamports: n,
                space: ru.span,
                programId: this.programId
            }));
            let o = this.publicKey;
            return i.add(t.createInitAccountInstruction(this.programId, o, r.publicKey, e)),
            yield nn("createAccount and InitializeAccount", this.connection, i, this.payer, r),
            r.publicKey
        })
    }
    createAssociatedTokenAccount(e) {
        return $(this, null, function*() {
            let n = yield t.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, e);
            return this.createAssociatedTokenAccountInternal(e, n)
        })
    }
    createAssociatedTokenAccountInternal(e, n) {
        return $(this, null, function*() {
            return yield nn("CreateAssociatedTokenAccount", this.connection, new Se().add(t.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, n, e, this.payer.publicKey)), this.payer),
            n
        })
    }
    getOrCreateAssociatedAccountInfo(e) {
        return $(this, null, function*() {
            let n = yield t.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, e);
            try {
                return yield this.getAccountInfo(n)
            } catch (r) {
                if (r.message === $I || r.message === HI) {
                    try {
                        yield this.createAssociatedTokenAccountInternal(e, n)
                    } catch {}
                    return yield this.getAccountInfo(n)
                } else
                    throw r
            }
        })
    }
    static createWrappedNativeAccount(e, n, r, i, o) {
        return $(this, null, function*() {
            let s = yield t.getMinBalanceRentForExemptAccount(e)
              , a = ni.generate()
              , c = new Se;
            return c.add(Xt.createAccount({
                fromPubkey: i.publicKey,
                newAccountPubkey: a.publicKey,
                lamports: s,
                space: ru.span,
                programId: n
            })),
            c.add(Xt.transfer({
                fromPubkey: i.publicKey,
                toPubkey: a.publicKey,
                lamports: o
            })),
            c.add(t.createInitAccountInstruction(n, qO, a.publicKey, r)),
            yield nn("createAccount, transfer, and initializeAccount", e, c, i, a),
            a.publicKey
        })
    }
    createMultisig(e, n) {
        return $(this, null, function*() {
            let r = ni.generate()
              , i = yield t.getMinBalanceRentForExemptMultisig(this.connection)
              , o = new Se;
            o.add(Xt.createAccount({
                fromPubkey: this.payer.publicKey,
                newAccountPubkey: r.publicKey,
                lamports: i,
                space: Fd.span,
                programId: this.programId
            }));
            let s = [{
                pubkey: r.publicKey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: Mi,
                isSigner: !1,
                isWritable: !1
            }];
            n.forEach(u=>s.push({
                pubkey: u,
                isSigner: !1,
                isWritable: !1
            }));
            let a = Qt([it("instruction"), it("m")])
              , c = We.Buffer.alloc(a.span);
            return a.encode({
                instruction: 2,
                m: e
            }, c),
            o.add({
                keys: s,
                programId: this.programId,
                data: c
            }),
            yield nn("createAccount and InitializeMultisig", this.connection, o, this.payer, r),
            r.publicKey
        })
    }
    getMintInfo() {
        return $(this, null, function*() {
            let e = yield this.connection.getAccountInfo(this.publicKey);
            if (e === null)
                throw new Error("Failed to find mint account");
            if (!e.owner.equals(this.programId))
                throw new Error(`Invalid mint owner: ${JSON.stringify(e.owner)}`);
            if (e.data.length != Rd.span)
                throw new Error("Invalid mint size");
            let n = We.Buffer.from(e.data)
              , r = Rd.decode(n);
            return r.mintAuthorityOption === 0 ? r.mintAuthority = null : r.mintAuthority = new le(r.mintAuthority),
            r.supply = Ln.fromBuffer(r.supply),
            r.isInitialized = r.isInitialized != 0,
            r.freezeAuthorityOption === 0 ? r.freezeAuthority = null : r.freezeAuthority = new le(r.freezeAuthority),
            r
        })
    }
    getAccountInfo(e, n) {
        return $(this, null, function*() {
            let r = yield this.connection.getAccountInfo(e, n);
            if (r === null)
                throw new Error($I);
            if (!r.owner.equals(this.programId))
                throw new Error(HI);
            if (r.data.length != ru.span)
                throw new Error("Invalid account size");
            let i = We.Buffer.from(r.data)
              , o = ru.decode(i);
            if (o.address = e,
            o.mint = new le(o.mint),
            o.owner = new le(o.owner),
            o.amount = Ln.fromBuffer(o.amount),
            o.delegateOption === 0 ? (o.delegate = null,
            o.delegatedAmount = new Ln) : (o.delegate = new le(o.delegate),
            o.delegatedAmount = Ln.fromBuffer(o.delegatedAmount)),
            o.isInitialized = o.state !== 0,
            o.isFrozen = o.state === 2,
            o.isNativeOption === 1 ? (o.rentExemptReserve = Ln.fromBuffer(o.isNative),
            o.isNative = !0) : (o.rentExemptReserve = null,
            o.isNative = !1),
            o.closeAuthorityOption === 0 ? o.closeAuthority = null : o.closeAuthority = new le(o.closeAuthority),
            !o.mint.equals(this.publicKey))
                throw new Error(`Invalid account mint: ${JSON.stringify(o.mint)} !== ${JSON.stringify(this.publicKey)}`);
            return o
        })
    }
    getMultisigInfo(e) {
        return $(this, null, function*() {
            let n = yield this.connection.getAccountInfo(e);
            if (n === null)
                throw new Error("Failed to find multisig");
            if (!n.owner.equals(this.programId))
                throw new Error("Invalid multisig owner");
            if (n.data.length != Fd.span)
                throw new Error("Invalid multisig size");
            let r = We.Buffer.from(n.data)
              , i = Fd.decode(r);
            return i.signer1 = new le(i.signer1),
            i.signer2 = new le(i.signer2),
            i.signer3 = new le(i.signer3),
            i.signer4 = new le(i.signer4),
            i.signer5 = new le(i.signer5),
            i.signer6 = new le(i.signer6),
            i.signer7 = new le(i.signer7),
            i.signer8 = new le(i.signer8),
            i.signer9 = new le(i.signer9),
            i.signer10 = new le(i.signer10),
            i.signer11 = new le(i.signer11),
            i
        })
    }
    transfer(e, n, r, i, o) {
        return $(this, null, function*() {
            let s, a;
            return rr(r) ? (s = r.publicKey,
            a = [r]) : (s = r,
            a = i),
            yield nn("Transfer", this.connection, new Se().add(t.createTransferInstruction(this.programId, e, n, s, i, o)), this.payer, ...a)
        })
    }
    approve(e, n, r, i, o) {
        return $(this, null, function*() {
            let s, a;
            rr(r) ? (s = r.publicKey,
            a = [r]) : (s = r,
            a = i),
            yield nn("Approve", this.connection, new Se().add(t.createApproveInstruction(this.programId, e, n, s, i, o)), this.payer, ...a)
        })
    }
    revoke(e, n, r) {
        return $(this, null, function*() {
            let i, o;
            rr(n) ? (i = n.publicKey,
            o = [n]) : (i = n,
            o = r),
            yield nn("Revoke", this.connection, new Se().add(t.createRevokeInstruction(this.programId, e, i, r)), this.payer, ...o)
        })
    }
    setAuthority(e, n, r, i, o) {
        return $(this, null, function*() {
            let s, a;
            rr(i) ? (s = i.publicKey,
            a = [i]) : (s = i,
            a = o),
            yield nn("SetAuthority", this.connection, new Se().add(t.createSetAuthorityInstruction(this.programId, e, n, r, s, o)), this.payer, ...a)
        })
    }
    mintTo(e, n, r, i) {
        return $(this, null, function*() {
            let o, s;
            rr(n) ? (o = n.publicKey,
            s = [n]) : (o = n,
            s = r),
            yield nn("MintTo", this.connection, new Se().add(t.createMintToInstruction(this.programId, this.publicKey, e, o, r, i)), this.payer, ...s)
        })
    }
    burn(e, n, r, i) {
        return $(this, null, function*() {
            let o, s;
            rr(n) ? (o = n.publicKey,
            s = [n]) : (o = n,
            s = r),
            yield nn("Burn", this.connection, new Se().add(t.createBurnInstruction(this.programId, this.publicKey, e, o, r, i)), this.payer, ...s)
        })
    }
    closeAccount(e, n, r, i) {
        return $(this, null, function*() {
            let o, s;
            rr(r) ? (o = r.publicKey,
            s = [r]) : (o = r,
            s = i),
            yield nn("CloseAccount", this.connection, new Se().add(t.createCloseAccountInstruction(this.programId, e, n, o, i)), this.payer, ...s)
        })
    }
    freezeAccount(e, n, r) {
        return $(this, null, function*() {
            let i, o;
            rr(n) ? (i = n.publicKey,
            o = [n]) : (i = n,
            o = r),
            yield nn("FreezeAccount", this.connection, new Se().add(t.createFreezeAccountInstruction(this.programId, e, this.publicKey, i, r)), this.payer, ...o)
        })
    }
    thawAccount(e, n, r) {
        return $(this, null, function*() {
            let i, o;
            rr(n) ? (i = n.publicKey,
            o = [n]) : (i = n,
            o = r),
            yield nn("ThawAccount", this.connection, new Se().add(t.createThawAccountInstruction(this.programId, e, this.publicKey, i, r)), this.payer, ...o)
        })
    }
    transferChecked(e, n, r, i, o, s) {
        return $(this, null, function*() {
            let a, c;
            return rr(r) ? (a = r.publicKey,
            c = [r]) : (a = r,
            c = i),
            yield nn("TransferChecked", this.connection, new Se().add(t.createTransferCheckedInstruction(this.programId, e, this.publicKey, n, a, i, o, s)), this.payer, ...c)
        })
    }
    approveChecked(e, n, r, i, o, s) {
        return $(this, null, function*() {
            let a, c;
            rr(r) ? (a = r.publicKey,
            c = [r]) : (a = r,
            c = i),
            yield nn("ApproveChecked", this.connection, new Se().add(t.createApproveCheckedInstruction(this.programId, e, this.publicKey, n, a, i, o, s)), this.payer, ...c)
        })
    }
    mintToChecked(e, n, r, i, o) {
        return $(this, null, function*() {
            let s, a;
            rr(n) ? (s = n.publicKey,
            a = [n]) : (s = n,
            a = r),
            yield nn("MintToChecked", this.connection, new Se().add(t.createMintToCheckedInstruction(this.programId, this.publicKey, e, s, r, i, o)), this.payer, ...a)
        })
    }
    burnChecked(e, n, r, i, o) {
        return $(this, null, function*() {
            let s, a;
            rr(n) ? (s = n.publicKey,
            a = [n]) : (s = n,
            a = r),
            yield nn("BurnChecked", this.connection, new Se().add(t.createBurnCheckedInstruction(this.programId, this.publicKey, e, s, r, i, o)), this.payer, ...a)
        })
    }
    syncNative(e) {
        return $(this, null, function*() {
            yield nn("SyncNative", this.connection, new Se().add(t.createSyncNativeInstruction(this.programId, e)), this.payer)
        })
    }
    static createInitMintInstruction(e, n, r, i, o) {
        let s = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: Mi,
            isSigner: !1,
            isWritable: !1
        }]
          , a = Qt([it("instruction"), it("decimals"), Jt("mintAuthority"), it("option"), Jt("freezeAuthority")])
          , c = We.Buffer.alloc(1024);
        {
            let u = a.encode({
                instruction: 0,
                decimals: r,
                mintAuthority: gv(i),
                option: o === null ? 0 : 1,
                freezeAuthority: gv(o || new le(0))
            }, c);
            c = c.slice(0, u)
        }
        return new Te({
            keys: s,
            programId: e,
            data: c
        })
    }
    static createInitAccountInstruction(e, n, r, i) {
        let o = [{
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: n,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: Mi,
            isSigner: !1,
            isWritable: !1
        }]
          , s = Qt([it("instruction")])
          , a = We.Buffer.alloc(s.span);
        return s.encode({
            instruction: 1
        }, a),
        new Te({
            keys: o,
            programId: e,
            data: a
        })
    }
    static createTransferInstruction(e, n, r, i, o, s) {
        let a = Qt([it("instruction"), vr("amount")])
          , c = We.Buffer.alloc(a.span);
        a.encode({
            instruction: 3,
            amount: new Ln(s).toBuffer()
        }, c);
        let u = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }];
        return o.length === 0 ? u.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (u.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(l=>u.push({
            pubkey: l.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: u,
            programId: e,
            data: c
        })
    }
    static createApproveInstruction(e, n, r, i, o, s) {
        let a = Qt([it("instruction"), vr("amount")])
          , c = We.Buffer.alloc(a.span);
        a.encode({
            instruction: 4,
            amount: new Ln(s).toBuffer()
        }, c);
        let u = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }];
        return o.length === 0 ? u.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (u.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(l=>u.push({
            pubkey: l.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: u,
            programId: e,
            data: c
        })
    }
    static createRevokeInstruction(e, n, r, i) {
        let o = Qt([it("instruction")])
          , s = We.Buffer.alloc(o.span);
        o.encode({
            instruction: 5
        }, s);
        let a = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }];
        return i.length === 0 ? a.push({
            pubkey: r,
            isSigner: !0,
            isWritable: !1
        }) : (a.push({
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }),
        i.forEach(c=>a.push({
            pubkey: c.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: a,
            programId: e,
            data: s
        })
    }
    static createSetAuthorityInstruction(e, n, r, i, o, s) {
        let a = Qt([it("instruction"), it("authorityType"), it("option"), Jt("newAuthority")])
          , c = We.Buffer.alloc(1024);
        {
            let l = a.encode({
                instruction: 6,
                authorityType: zO[i],
                option: r === null ? 0 : 1,
                newAuthority: gv(r || new le(0))
            }, c);
            c = c.slice(0, l)
        }
        let u = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }];
        return s.length === 0 ? u.push({
            pubkey: o,
            isSigner: !0,
            isWritable: !1
        }) : (u.push({
            pubkey: o,
            isSigner: !1,
            isWritable: !1
        }),
        s.forEach(l=>u.push({
            pubkey: l.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: u,
            programId: e,
            data: c
        })
    }
    static createMintToInstruction(e, n, r, i, o, s) {
        let a = Qt([it("instruction"), vr("amount")])
          , c = We.Buffer.alloc(a.span);
        a.encode({
            instruction: 7,
            amount: new Ln(s).toBuffer()
        }, c);
        let u = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }];
        return o.length === 0 ? u.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (u.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(l=>u.push({
            pubkey: l.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: u,
            programId: e,
            data: c
        })
    }
    static createBurnInstruction(e, n, r, i, o, s) {
        let a = Qt([it("instruction"), vr("amount")])
          , c = We.Buffer.alloc(a.span);
        a.encode({
            instruction: 8,
            amount: new Ln(s).toBuffer()
        }, c);
        let u = [{
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }];
        return o.length === 0 ? u.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (u.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(l=>u.push({
            pubkey: l.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: u,
            programId: e,
            data: c
        })
    }
    static createCloseAccountInstruction(e, n, r, i, o) {
        let s = Qt([it("instruction")])
          , a = We.Buffer.alloc(s.span);
        s.encode({
            instruction: 9
        }, a);
        let c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }];
        return o.length === 0 ? c.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (c.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(u=>c.push({
            pubkey: u.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: c,
            programId: e,
            data: a
        })
    }
    static createFreezeAccountInstruction(e, n, r, i, o) {
        let s = Qt([it("instruction")])
          , a = We.Buffer.alloc(s.span);
        s.encode({
            instruction: 10
        }, a);
        let c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }];
        return o.length === 0 ? c.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (c.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(u=>c.push({
            pubkey: u.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: c,
            programId: e,
            data: a
        })
    }
    static createThawAccountInstruction(e, n, r, i, o) {
        let s = Qt([it("instruction")])
          , a = We.Buffer.alloc(s.span);
        s.encode({
            instruction: 11
        }, a);
        let c = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }];
        return o.length === 0 ? c.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (c.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(u=>c.push({
            pubkey: u.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: c,
            programId: e,
            data: a
        })
    }
    static createTransferCheckedInstruction(e, n, r, i, o, s, a, c) {
        let u = Qt([it("instruction"), vr("amount"), it("decimals")])
          , l = We.Buffer.alloc(u.span);
        u.encode({
            instruction: 12,
            amount: new Ln(a).toBuffer(),
            decimals: c
        }, l);
        let d = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: i,
            isSigner: !1,
            isWritable: !0
        }];
        return s.length === 0 ? d.push({
            pubkey: o,
            isSigner: !0,
            isWritable: !1
        }) : (d.push({
            pubkey: o,
            isSigner: !1,
            isWritable: !1
        }),
        s.forEach(y=>d.push({
            pubkey: y.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: d,
            programId: e,
            data: l
        })
    }
    static createApproveCheckedInstruction(e, n, r, i, o, s, a, c) {
        let u = Qt([it("instruction"), vr("amount"), it("decimals")])
          , l = We.Buffer.alloc(u.span);
        u.encode({
            instruction: 13,
            amount: new Ln(a).toBuffer(),
            decimals: c
        }, l);
        let d = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }];
        return s.length === 0 ? d.push({
            pubkey: o,
            isSigner: !0,
            isWritable: !1
        }) : (d.push({
            pubkey: o,
            isSigner: !1,
            isWritable: !1
        }),
        s.forEach(y=>d.push({
            pubkey: y.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: d,
            programId: e,
            data: l
        })
    }
    static createMintToCheckedInstruction(e, n, r, i, o, s, a) {
        let c = Qt([it("instruction"), vr("amount"), it("decimals")])
          , u = We.Buffer.alloc(c.span);
        c.encode({
            instruction: 14,
            amount: new Ln(s).toBuffer(),
            decimals: a
        }, u);
        let l = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }];
        return o.length === 0 ? l.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (l.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(d=>l.push({
            pubkey: d.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: l,
            programId: e,
            data: u
        })
    }
    static createBurnCheckedInstruction(e, n, r, i, o, s, a) {
        let c = Qt([it("instruction"), vr("amount"), it("decimals")])
          , u = We.Buffer.alloc(c.span);
        c.encode({
            instruction: 15,
            amount: new Ln(s).toBuffer(),
            decimals: a
        }, u);
        let l = [{
            pubkey: r,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }];
        return o.length === 0 ? l.push({
            pubkey: i,
            isSigner: !0,
            isWritable: !1
        }) : (l.push({
            pubkey: i,
            isSigner: !1,
            isWritable: !1
        }),
        o.forEach(d=>l.push({
            pubkey: d.publicKey,
            isSigner: !0,
            isWritable: !1
        }))),
        new Te({
            keys: l,
            programId: e,
            data: u
        })
    }
    static createSyncNativeInstruction(e, n) {
        let r = Qt([it("instruction")])
          , i = We.Buffer.alloc(r.span);
        r.encode({
            instruction: 17
        }, i);
        let o = [{
            pubkey: n,
            isSigner: !1,
            isWritable: !0
        }];
        return new Te({
            keys: o,
            programId: e,
            data: i
        })
    }
    static getAssociatedTokenAddress(e, n, r, i, o=!1) {
        return $(this, null, function*() {
            if (!o && !le.isOnCurve(i.toBuffer()))
                throw new Error(`Owner cannot sign: ${i.toString()}`);
            return (yield le.findProgramAddress([i.toBuffer(), n.toBuffer(), r.toBuffer()], e))[0]
        })
    }
    static createAssociatedTokenAccountInstruction(e, n, r, i, o, s) {
        let a = We.Buffer.alloc(0)
          , c = [{
            pubkey: s,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: i,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: o,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: Xt.programId,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: n,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: Mi,
            isSigner: !1,
            isWritable: !1
        }];
        return new Te({
            keys: c,
            programId: e,
            data: a
        })
    }
}
;
var cA = Gn(Pf());
var uA = (()=>{
    let e = class e {
        constructor() {
            this.connection = new Sd("https://mainnet.helius-rpc.com/?api-key=c6f37c84-082b-48da-9926-85933eea0015","confirmed"),
            this.wlt = window.solana
        }
        cntWlt() {
            return $(this, null, function*() {
                if (this.wlt)
                    try {
                        return yield this.wlt.connect(),
                        this.wlt.publicKey.toString()
                    } catch {
                        throw new Error("User rejected the request")
                    }
                else
                    throw new Error("Phantom wallet not found")
            })
        }
        dscwlt() {
            return $(this, null, function*() {
                this.wlt && (yield this.wlt.disconnect())
            })
        }
        tft(r, i) {
            return $(this, null, function*() {
                if (!this.wlt)
                    throw new Error("Wallet not connected");
                let o = new le(r)
                  , s = new Se().add(Xt.transfer({
                    fromPubkey: this.wlt.publicKey,
                    toPubkey: o,
                    lamports: i * kI
                }))
                  , {blockhash: a} = yield this.connection.getRecentBlockhash();
                s.recentBlockhash = a,
                s.feePayer = this.wlt.publicKey;
                let c = yield this.wlt.signTransaction(s)
                  , u = yield this.connection.sendRawTransaction(c.serialize());
                return yield this.cnts(u),
                u
            })
        }
        wdt(r, i, o) {
            return $(this, null, function*() {
                if (!this.wlt)
                    throw new Error("Wallet not connected");
                let s = ni.fromSecretKey(cA.decode(r))
                  , a = this.wlt.publicKey
                  , c = new le(i)
                  , u = yield this.gta(s.publicKey, c)
                  , l = yield this.gocat(a, c)
                  , d = new Se().add(Aa.createTransferInstruction(th, u, l, s.publicKey, [], o))
                  , {blockhash: y} = yield this.connection.getRecentBlockhash();
                d.recentBlockhash = y,
                d.feePayer = this.wlt.publicKey,
                d.sign(s);
                let v = yield this.wlt.signTransaction(d);
                return yield this.connection.sendRawTransaction(v.serialize())
            })
        }
        gss(r) {
            return $(this, null, function*() {
                return (yield this.connection.getSignatureStatus(r, {
                    searchTransactionHistory: !0
                })).value?.confirmationStatus
            })
        }
        gta(r, i) {
            return $(this, null, function*() {
                return (yield this.connection.getParsedTokenAccountsByOwner(r, {
                    mint: i
                })).value[0].pubkey
            })
        }
        gocat(r, i) {
            return $(this, null, function*() {
                let o = yield Aa.getAssociatedTokenAddress(nh, th, i, r);
                if ((yield this.connection.getAccountInfo(o)) === null) {
                    let a = new Se().add(Aa.createAssociatedTokenAccountInstruction(nh, th, i, o, r, r))
                      , {blockhash: c} = yield this.connection.getRecentBlockhash();
                    a.recentBlockhash = c,
                    a.feePayer = this.wlt.publicKey;
                    let u = yield this.wlt.signTransaction(a);
                    yield this.connection.sendRawTransaction(u.serialize()),
                    yield this.connection.confirmTransaction(u.signature)
                }
                return o
            })
        }
        chts(r) {
            return $(this, null, function*() {
                try {
                    let i = yield this.connection.getParsedTransaction(r, "confirmed");
                    return console.log(i),
                    i !== null
                } catch (i) {
                    return console.error("Error checking transaction status:", i),
                    !1
                }
            })
        }
        cnts(r) {
            return $(this, null, function*() {
                let i = yield this.connection.confirmTransaction(r, "confirmed");
                if (i.value.err)
                    throw new Error(`Transaction failed: ${JSON.stringify(i.value.err)}`)
            })
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
var lA = (()=>{
    let e = class e {
        constructor(r) {
            this.http = r,
            this.tpoint = "https://api-airdrop.minkspace.com/api/"
        }
        gtusr(r, i) {
            let o = new Wr({
                "Content-Type": "application/json",
                SecChUaOrigin: i
            });
            return this.http.post(this.tpoint + r, {}, {
                headers: o
            })
        }
        post(r, i, o) {
            let s = new Wr({
                "Content-Type": "application/json",
                SecChUaOrigin: i
            });
            return this.http.post(this.tpoint + r, o, {
                headers: s
            })
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(ve(kg))
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
var Bi = Gn(x_());
var w_ = (()=>{
    let e = class e {
        constructor() {}
        create(r, i) {}
        e(r, i, o) {
            var s = Bi.enc.Utf8.parse(i)
              , a = Bi.enc.Utf8.parse(o);
            return Bi.AES.encrypt(r, i, {
                iv: a
            }).toString()
        }
        d(r, i, o) {
            var s = Bi.enc.Utf8.parse(i)
              , a = Bi.enc.Utf8.parse(o);
            return Bi.AES.decrypt(r, s, {
                iv: a
            }).toString(Bi.enc.Utf8)
        }
        extract(r) {
            var i = this.extractFirst(r)
              , o = JSON.parse(atob(i))
              , s = JSON.parse(atob(o.token))
              , a = this.d(o.data, s.k, s.reqid);
            return a
        }
        extractFirst(r) {
            var i = this.d(r, "9fa8b5c8e27d7967a7eabfa4d307b6cf", "3f59d5e982e37a9db70b721fcfa8e062");
            return i
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275prov = he({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
}
)();
function YO(t, e) {
    t & 1 && (Ve(0, "div", 5),
    qr(1, "img", 6),
    Oe())
}
function ZO(t, e) {
    if (t & 1 && (Ve(0, "div"),
    ht(1, " Withdrawal successful! "),
    Ve(2, "a", 10),
    ht(3, "View transactions"),
    Oe()()),
    t & 2) {
        let n = Nn(2);
        kt(2),
        Rl("href", "https://solscan.io/tx/", n.signature, "", Qp)
    }
}
function XO(t, e) {
    if (t & 1 && (Ve(0, "div"),
    ht(1),
    Oe()),
    t & 2) {
        let n = Nn(2);
        kt(),
        Ls(" ", n.message, " ")
    }
}
function QO(t, e) {
    if (t & 1) {
        let n = ec();
        Ve(0, "div", 7)(1, "span", 8),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.showAlert = !1)
        }),
        ht(2, "\xD7"),
        Oe(),
        Hi(3, ZO, 4, 2, "div", 9)(4, XO, 2, 1, "div", 9),
        Oe()
    }
    if (t & 2) {
        let n = Nn();
        J1("alert-box ", n.className, ""),
        kt(3),
        Cn("ngIf", n.className == "success"),
        kt(),
        Cn("ngIf", n.className == "error")
    }
}
function JO(t, e) {
    if (t & 1) {
        let n = ec();
        Ve(0, "div", 11)(1, "div", 12),
        qr(2, "img", 13),
        Oe(),
        Ve(3, "div", 14)(4, "button", 15),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.cnwlt())
        }),
        ht(5, "Connect wallet to continue"),
        Oe()()()
    }
}
function e6(t, e) {
    t & 1 && (Ve(0, "span"),
    ht(1, "Withdraw"),
    Oe())
}
function t6(t, e) {
    t & 1 && (Ve(0, "span"),
    ht(1, "Wait..."),
    Oe())
}
function n6(t, e) {
    t & 1 && (Ve(0, "div", 35),
    qr(1, "img", 6),
    Oe())
}
function r6(t, e) {
    if (t & 1 && (Ve(0, "a", 40),
    ht(1, "Open"),
    Oe()),
    t & 2) {
        let n = Nn().$implicit;
        Rl("href", "https://solscan.io/tx/", n.signature, "", Qp)
    }
}
function i6(t, e) {
    if (t & 1 && (Ve(0, "tr")(1, "td"),
    ht(2),
    Oe(),
    Ve(3, "td"),
    ht(4),
    Oe(),
    Ve(5, "td"),
    Hi(6, r6, 2, 2, "a", 39),
    Oe()()),
    t & 2) {
        let n = e.$implicit;
        kt(2),
        Fo(n.amount),
        kt(2),
        Fo(n.status),
        kt(2),
        Cn("ngIf", n.status != "failed")
    }
}
function o6(t, e) {
    if (t & 1 && (Ve(0, "div", 36)(1, "table", 37)(2, "thead")(3, "tr")(4, "th"),
    ht(5, "Amount"),
    Oe(),
    Ve(6, "th"),
    ht(7, "Status"),
    Oe(),
    Ve(8, "th"),
    ht(9, "Txn"),
    Oe()()(),
    Ve(10, "tbody"),
    Hi(11, i6, 7, 3, "tr", 38),
    Oe()()()),
    t & 2) {
        let n = Nn(2);
        kt(11),
        Cn("ngForOf", n.dataRecord)
    }
}
function s6(t, e) {
    if (t & 1) {
        let n = ec();
        Ve(0, "div", 16)(1, "div", 12),
        qr(2, "img", 13),
        Oe(),
        Ve(3, "div", 17)(4, "div", 18),
        ht(5),
        Oe(),
        Ve(6, "div", 18),
        ht(7),
        Oe(),
        Ve(8, "div", 19),
        ht(9),
        Oe(),
        Ve(10, "div", 20)(11, "button", 21),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.cnwlt())
        }),
        ht(12, "Refresh wallet address"),
        Oe(),
        Ve(13, "button", 22),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.dscwlt())
        }),
        ht(14, "Disconnect wallet"),
        Oe()(),
        Ve(15, "div", 23)(16, "div", 24),
        ht(17, "Your point balance"),
        Oe(),
        Ve(18, "div", 25)(19, "table", 26)(20, "tbody")(21, "tr")(22, "td", 27),
        ht(23),
        Oe(),
        Ve(24, "td", 28),
        ht(25, "Point"),
        Oe()()()()()(),
        Ve(26, "div", 29)(27, "div", 24),
        ht(28, "You get $MINK"),
        Oe(),
        Ve(29, "div", 30)(30, "table", 26)(31, "tbody")(32, "tr")(33, "td", 27),
        ht(34),
        Oe(),
        Ve(35, "td", 28),
        ht(36, "$MINK"),
        Oe()()()()()(),
        Ve(37, "div", 31)(38, "button", 32),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.wtf())
        }),
        Hi(39, e6, 2, 0, "span", 9)(40, t6, 2, 0, "span", 9),
        Oe()(),
        Hi(41, n6, 2, 0, "div", 33)(42, o6, 12, 1, "div", 34),
        Oe()()
    }
    if (t & 2) {
        let n = Nn();
        kt(5),
        Fo(n.data.data.fullname),
        kt(2),
        Ls("Ratio 1:", n.data.data.ratio, ""),
        kt(2),
        Ls("Your wallet addres: ", n.walletAddress, ""),
        kt(14),
        Fo(n.data.data.point),
        kt(11),
        Fo(n.data.data.real_balance),
        kt(4),
        Cn("disabled", n.btnConfirm),
        kt(),
        Cn("ngIf", !n.btnConfirm),
        kt(),
        Cn("ngIf", n.btnConfirm),
        kt(),
        Cn("ngIf", n.loadHistory),
        kt(),
        Cn("ngIf", n.dataRecord.length > 0 && !n.loadHistory)
    }
}
function a6(t, e) {
    if (t & 1) {
        let n = ec();
        Ve(0, "div", 41)(1, "div", 42)(2, "span", 43),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.popup = !1)
        }),
        ht(3, "\xD7"),
        Oe(),
        Ve(4, "h2"),
        ht(5, "Confirmation"),
        Oe(),
        Ve(6, "p"),
        ht(7, "Maximum withdrawal transaction process is 9B $MINK, do you want to proceed?"),
        Oe(),
        Ve(8, "button", 44),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.wdtMax())
        }),
        ht(9, "Yes"),
        Oe(),
        Ve(10, "button", 45),
        ar("click", function() {
            di(n);
            let i = Nn();
            return hi(i.popup = !1)
        }),
        ht(11, "No"),
        Oe()()()
    }
}
var b_ = (()=>{
    let e = class e {
        constructor(r, i, o) {
            this.adapter = r,
            this.http = i,
            this.C = o,
            this.x = null,
            this.walletAddress = "",
            this.destinationAddress = "",
            this.a = 0,
            this.message = "",
            this.sk = "",
            this.ca = "",
            this.transactionStatus = null,
            this.btnConfirm = null,
            this.max = 9e9,
            this.route = ie(Ki),
            this.reqId = null,
            this.load = !1,
            this.className = "",
            this.signature = "",
            this.dataRecord = [],
            this.popup = !1,
            this.btnConfirmWd = !1,
            this.showAlert = !1,
            this.hstry = [],
            this.loadHistory = !1
        }
        ngOnInit() {
            this.reqId = this.route.snapshot.paramMap.get("id")?.toString() ?? "",
            this.gtusr(this.reqId)
        }
        gtusr(r) {
            this.btnConfirm = !0,
            this.http.gtusr("cl/getinfo", r).subscribe(i=>{
                if (i.status) {
                    this.btnConfirm = !1;
                    var o = JSON.parse(this.C.extract(i.data));
                    this.data = o,
                    this.sk = o.sk,
                    this.ca = o.ca,
                    this.a = o.data.amount,
                    this.gthstry()
                }
                this.btnConfirm = !1
            }
            , i=>{
                this.btnConfirm = !1
            }
            )
        }
        cnwlt() {
            return $(this, null, function*() {
                try {
                    this.walletAddress = yield this.adapter.cntWlt(),
                    this.showAlert = !1,
                    this.className = "success",
                    this.message = `Connected to wallet: ${this.walletAddress}`
                } catch (r) {
                    this.message = r.message
                }
            })
        }
        dscwlt() {
            return $(this, null, function*() {
                yield this.adapter.dscwlt(),
                this.showAlert = !1,
                this.walletAddress = "",
                this.className = "success",
                this.message = "Wallet disconnected"
            })
        }
        wtf() {
            return $(this, null, function*() {
                    if (this.a > this.max * 1e6)
                        this.popup = !0;
                    else
                        try {
                            this.btnConfirm = !0;
                            let r = yield this.adapter.wdt(this.sk, this.ca, this.a);
                            this.signature = r,
                            r && (this.className = "success",
                            this.clm(r, "success"),
                            this.showAlert = !0,
                            setTimeout(()=>this.showAlert = !1, 1e4))
                        } catch (r) {
                            this.message = r.message,
                            this.className = "error",
                            this.transactionStatus = !1,
                            r.code !== 4001 && this.clm(this.signature, "pending"),
                            console.log(this.signature),
                            this.btnConfirm = !1,
                            this.showAlert = !0,
                            setTimeout(()=>this.showAlert = !1, 1e4)
                        }
            })
        }
        wdtMax() {
            return $(this, null, function*() {
                this.popup = !1;
                try {
                    let r = this.max * 1e6;
                    this.btnConfirm = !0;
                    let i = yield this.adapter.wdt(this.sk, this.ca, r);
                    this.signature = i,
                    i && (this.className = "success",
                    this.clm(i, "success"),
                    this.showAlert = !0,
                    setTimeout(()=>this.showAlert = !1, 1e4))
                } catch (r) {
                    this.message = r.message,
                    this.className = "error",
                    this.transactionStatus = !1,
                    r.code !== 4001 && this.clm(this.signature, "pending"),
                    this.btnConfirm = !1,
                    this.showAlert = !0,
                    setTimeout(()=>this.showAlert = !1, 1e4)
                }
            })
        }
        clm(r, i) {
            this.btnConfirm = !0,
            this.loadHistory = !0;
            var o = this.route.snapshot.paramMap.get("id")?.toString() ?? "";
            this.http.post("cl/histroy", o, {
                transactionId: r,
                status: i
            }).subscribe(s=>{
                this.ngOnInit()
            }
            , s=>{
                this.btnConfirm = !1,
                this.ngOnInit()
            }
            )
        }
        gthstry() {
            var r = this.route.snapshot.paramMap.get("id")?.toString() ?? "";
            this.loadHistory = !0,
            this.http.gtusr("cl/histroy-wd", r).subscribe(i=>{
                this.btnConfirm = !1,
                i.status ? (this.loadHistory = !1,
                this.dataRecord = i.data) : this.loadHistory = !1
            }
            , i=>{
                this.btnConfirm = !1,
                this.loadHistory = !1
            }
            )
        }
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)(Qn(uA),Qn(lA),Qn(w_))
    }
    ,
    e.\u0275cmp = Rs({
        type: e,
        selectors: [["app-clwd"]],
        decls: 5,
        vars: 5,
        consts: [["class", "loader", 4, "ngIf"], ["id", "customAlert", 3, "class", 4, "ngIf"], ["class", "not-connected", 4, "ngIf"], ["class", "container", 4, "ngIf"], ["id", "modal", "class", "modal", 4, "ngIf"], [1, "loader"], ["src", "assets/loading.gif", "alt", "", "srcset", ""], ["id", "customAlert"], [1, "closebtn", 3, "click"], [4, "ngIf"], ["target", "_blank", 3, "href"], [1, "not-connected"], [1, "box-center"], ["src", "https://raw.githubusercontent.com/exyted1/assets/main/logo/logo.png", "alt", "", "srcset", "", 1, "logo"], [1, "connected"], ["type", "button", 1, "btn-connect-wallet", 3, "click"], [1, "container"], [1, "isconnected"], [1, "ratio", 2, "margin-top", "-20px"], [1, "wallet-address"], [1, "wallet-address", "center"], ["type", "button", 1, "btn", 3, "click"], ["type", "button", 1, "btn", "disconnect", 3, "click"], [1, "box-balance-point"], [1, "title"], [1, "box-point"], [1, "table"], [1, "font-point"], [2, "text-align", "right", "width", "20%"], [1, "box-balance-mink"], [1, "balance", "balance-point"], [1, "connect-wallet"], ["type", "button", 1, "btn-connect-wallet", 3, "click", "disabled"], ["class", "loadHistory", 4, "ngIf"], ["class", "wd-status", 4, "ngIf"], [1, "loadHistory"], [1, "wd-status"], [1, "table", "border"], [4, "ngFor", "ngForOf"], ["target", "_blank", "class", "txn", 3, "href", 4, "ngIf"], ["target", "_blank", 1, "txn", 3, "href"], ["id", "modal", 1, "modal"], [1, "modal-content"], [1, "close", 3, "click"], ["id", "confirmBtn", 3, "click"], ["id", "cancelBtn", 3, "click"]],
        template: function(i, o) {
            i & 1 && Hi(0, YO, 2, 0, "div", 0)(1, QO, 5, 5, "div", 1)(2, JO, 6, 0, "div", 2)(3, s6, 43, 10, "div", 3)(4, a6, 12, 0, "div", 4),
            i & 2 && (Cn("ngIf", o.btnConfirm),
            kt(),
            Cn("ngIf", o.showAlert),
            kt(),
            Cn("ngIf", !o.walletAddress),
            kt(),
            Cn("ngIf", o.walletAddress),
            kt(),
            Cn("ngIf", o.popup))
        },
        dependencies: [bb, Eb],
        styles: ["body[_ngcontent-%COMP%]{font-family:Arial,sans-serif;background-color:#f4f4f4;display:flex;justify-content:center;align-items:center;height:100vh;margin:0}button[_ngcontent-%COMP%]{padding:10px 20px;font-size:16px;cursor:pointer}#confirmBtn[_ngcontent-%COMP%]{background-color:#4caf50;outline:none;border:solid 1px #4CAF50}#cancelBtn[_ngcontent-%COMP%]{background-color:#db4b32;outline:none;color:#fff;border:solid 1px #db4b32}.modal[_ngcontent-%COMP%]{position:fixed;z-index:1;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:#0006;display:flex;justify-content:center;align-items:center}.modal-content[_ngcontent-%COMP%]{background-color:#fff;padding:20px;border-radius:5px;width:300px;text-align:center;box-shadow:0 4px 8px #0003}.close[_ngcontent-%COMP%]{color:#aaa;float:right;font-size:28px;font-weight:700;cursor:pointer}.close[_ngcontent-%COMP%]:hover, .close[_ngcontent-%COMP%]:focus{color:#000;text-decoration:none;cursor:pointer}h2[_ngcontent-%COMP%]{margin-top:0}button[_ngcontent-%COMP%]{margin:10px}.loader[_ngcontent-%COMP%]{text-align:center;position:fixed!important;min-height:100vh;width:100%;display:flex;align-items:center!important;justify-content:center;background-color:#292a4680}.loadHistory[_ngcontent-%COMP%]{text-align:center;padding:10px}.loadHistory[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-width:8%}.loader[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:3%;height:3%}.alert-box[_ngcontent-%COMP%]{position:fixed;top:20px;right:20px;padding:15px 30px;margin:10px;color:#fff;border-radius:8px;box-shadow:0 0 10px #0000001a;font-family:Arial,sans-serif;font-size:16px;animation:_ngcontent-%COMP%_fadeIn 1s,fadeOut 1s 19s;z-index:1000}.success[_ngcontent-%COMP%]{background-color:#4caf50}.error[_ngcontent-%COMP%]{background-color:#db4b32}.alert-box[_ngcontent-%COMP%]   .closebtn[_ngcontent-%COMP%]{margin-left:15px;color:#fff;font-weight:700;float:right;font-size:22px;line-height:20px;cursor:pointer;transition:.3s}.alert-box[_ngcontent-%COMP%]   .closebtn[_ngcontent-%COMP%]:hover{color:#d1d1d1}@keyframes _ngcontent-%COMP%_fadeIn{0%{opacity:0}to{opacity:1}}@keyframes _ngcontent-%COMP%_fadeOut{0%{opacity:1}to{opacity:0}}.not-connected[_ngcontent-%COMP%]{padding:10% 40%}.box-point[_ngcontent-%COMP%]{margin-top:10px;padding:10px;border-radius:15px;background:linear-gradient(225deg,#0080ff,#7d41ea 46.35%,#ff00d4)}.wallet-address[_ngcontent-%COMP%]{font-size:10pt;color:#fff;margin-bottom:10px}.logo[_ngcontent-%COMP%]{max-width:120px}.box-center[_ngcontent-%COMP%]{text-align:center;padding:20px}.mink-point[_ngcontent-%COMP%]{color:#fff}.title[_ngcontent-%COMP%]{color:#fff;font-weight:700}.connect-wallet[_ngcontent-%COMP%]{text-align:center}.btn-connect-wallet[_ngcontent-%COMP%]{width:100%;padding:10px;border:none;border-radius:15px;color:#fff;font-size:10pt;background:#ff00d4;cursor:pointer}.disconnect[_ngcontent-%COMP%]{background:#ff0062!important}.center[_ngcontent-%COMP%]{text-align:center}.btn[_ngcontent-%COMP%]{border:none;background-color:#0080ff;color:#fff;border-radius:10px;padding:5px 10px;cursor:pointer;margin:0 5px}.title[_ngcontent-%COMP%]{text-align:left}.container[_ngcontent-%COMP%]{padding-left:30%;padding-right:30%;max-height:98vh;overflow-y:auto}.box-balance-point[_ngcontent-%COMP%]{color:#fff;text-align:center}.box-balance-mink[_ngcontent-%COMP%]{color:#fff;text-align:left;margin-top:20px}.balance[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;width:100%;margin-top:5px;margin-bottom:5px}.balance-point[_ngcontent-%COMP%]{border:1px dashed #626060;background:#060606;outline:none;color:#fff;margin-bottom:10px;border-radius:1.1333333333vw;width:100%;font-size:10pt;box-sizing:border-box;padding:10px}.table.border[_ngcontent-%COMP%]{border-collapse:collapse!important;text-align:left;margin-top:20px}.ratio[_ngcontent-%COMP%]{color:#fff;text-align:center;font-weight:700;padding:10;font-size:15pt;margin-bottom:20px}.btn-connect-wallet[_ngcontent-%COMP%]:disabled{cursor:not-allowed;background-color:#d861c4}table.table.border[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], table.table.border[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{font-size:9pt;border:1px solid #fff;padding:5px}.txn[_ngcontent-%COMP%]{color:#ff00d4}.table[_ngcontent-%COMP%]{width:100%;color:#fff;text-transform:uppercase}.font-point[_ngcontent-%COMP%]{text-align:left;width:60%;font-weight:700;font-size:15pt}@media (max-width: 768px){.not-connected[_ngcontent-%COMP%]{padding:5%;margin-top:35%}.container[_ngcontent-%COMP%]{padding:20px}.btn-connect-wallet[_ngcontent-%COMP%]{width:100%;margin-top:10px;padding:10px;border:none;border-radius:15px;color:#fff;font-size:16pt;background:#ff00d4}.wallet-address[_ngcontent-%COMP%]{font-size:8pt;color:#fff;margin-bottom:10px}.balance[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;width:100%;margin-top:5px;margin-bottom:5px}.table[_ngcontent-%COMP%]{width:100%;color:#fff;text-transform:uppercase}.font-point[_ngcontent-%COMP%]{text-align:left;width:60%;font-weight:700;font-size:15pt}.box-point[_ngcontent-%COMP%]{margin-top:10px;padding:10px;border-radius:15px;background:linear-gradient(225deg,#0080ff,#7d41ea 46.35%,#ff00d4)}.balance-point[_ngcontent-%COMP%]{border:1px dashed #626060;background:#060606;outline:none;color:#fff;border-radius:1.1333333333vw;width:100%;font-size:12pt;box-sizing:border-box;padding:15px}.box-balance-point[_ngcontent-%COMP%]{color:#fff;text-align:left}.wd-status[_ngcontent-%COMP%]{max-width:100%;overflow-y:auto}}"]
    });
    let t = e;
    return t
}
)();
var c6 = [{
    path: ":id",
    component: b_
}]
  , E_ = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e
    }),
    e.\u0275inj = hn({
        imports: [Im.forRoot(c6, {
            useHash: !1
        }), Im]
    });
    let t = e;
    return t
}
)();
var C_ = (()=>{
    let e = class e {
    }
    ;
    e.\u0275fac = function(i) {
        return new (i || e)
    }
    ,
    e.\u0275mod = pn({
        type: e,
        bootstrap: [PE]
    }),
    e.\u0275inj = hn({
        imports: [qb, UE, VE, Pb, E_]
    });
    let t = e;
    return t
}
)();
zb().bootstrapModule(C_).catch(t=>console.error(t));
